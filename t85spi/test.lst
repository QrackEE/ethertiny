GAS LISTING /tmp/ccouZRfQ.s 			page 1


   1               		.file	"test.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 114               	.global	delay_ms
 116               	delay_ms:
 117               		.stabd	46,0,0
   1:test.c        **** /*
   2:test.c        **** 
   3:test.c        **** 	WARNING: Connecting an AVR to ethernet without magnetics is VERY DANGEROUS.
   4:test.c        **** 	It may cause high voltages to go through the AVR and destroy it in DANGEROUS
   5:test.c        **** 	that may harm personal safety.  Do only at your own risk.
   6:test.c        **** 
   7:test.c        **** */
   8:test.c        **** 
   9:test.c        **** /*
  10:test.c        ****     Copyright (C) 2014 <>< Charles Lohr
  11:test.c        **** 
  12:test.c        **** 
  13:test.c        ****     Permission is hereby granted, free of charge, to any person obtaining a
  14:test.c        **** 	copy of this software and associated documentation files (the "Software"),
  15:test.c        **** 	to deal in the Software without restriction, including without limitation
  16:test.c        **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  17:test.c        **** 	and/or sell copies of the Software, and to permit persons to whom the
  18:test.c        **** 	Software is furnished to do so, subject to the following conditions:
  19:test.c        **** 
  20:test.c        ****     The above copyright notice and this permission notice shall be included
  21:test.c        **** 	in all copies or substantial portions of the Software.
  22:test.c        **** 
  23:test.c        ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  24:test.c        **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  25:test.c        **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  26:test.c        **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  27:test.c        **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  28:test.c        **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  29:test.c        **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  30:test.c        **** */
  31:test.c        **** 
  32:test.c        **** 
  33:test.c        **** #include <avr/io.h>
  34:test.c        **** #include <avr/interrupt.h>
  35:test.c        **** #include <avr/sleep.h>
  36:test.c        **** #include <util/delay.h>
  37:test.c        **** 
  38:test.c        **** #include "net_compat.h"
  39:test.c        **** #include "sendpack.h"
  40:test.c        **** #include "packetmater.h"
  41:test.c        **** #include "hlprocess.h"
  42:test.c        **** 
  43:test.c        **** void delay_ms(uint32_t time) {
 119               	.LM0:
 120               	.LFBB1:
 121 0000 0F93      		push r16
GAS LISTING /tmp/ccouZRfQ.s 			page 2


 122 0002 1F93      		push r17
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 2 */
 126               	.L__stack_usage = 2
  44:test.c        ****   uint32_t i;
  45:test.c        ****   for (i = 0; i < time; i++) {
 128               	.LM1:
 129 0004 00E0      		ldi r16,0
 130 0006 10E0      		ldi r17,0
 131 0008 9801      		movw r18,r16
 132               	.L2:
 134               	.LM2:
 135 000a 0617      		cp r16,r22
 136 000c 1707      		cpc r17,r23
 137 000e 2807      		cpc r18,r24
 138 0010 3907      		cpc r19,r25
 139 0012 01F0      		breq .L5
 140               	.LBB4:
 141               	.LBB5:
 143               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
GAS LISTING /tmp/ccouZRfQ.s 			page 3


  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/ccouZRfQ.s 			page 4


  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
GAS LISTING /tmp/ccouZRfQ.s 			page 5


 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 145               	.LM3:
 146 0014 E7E8      		ldi r30,lo8(4999)
 147 0016 F3E1      		ldi r31,hi8(4999)
 148 0018 3197      		1: sbiw r30,1
 149 001a 01F4      		brne 1b
 150 001c 00C0      		rjmp .
 151 001e 0000      		nop
 152               	.LBE5:
 153               	.LBE4:
 155               	.Ltext2:
 157               	.LM4:
 158 0020 0F5F      		subi r16,-1
 159 0022 1F4F      		sbci r17,-1
 160 0024 2F4F      		sbci r18,-1
 161 0026 3F4F      		sbci r19,-1
 162 0028 00C0      		rjmp .L2
 163               	.L5:
 164               	/* epilogue start */
  46:test.c        ****     _delay_ms(1);
  47:test.c        ****   }
  48:test.c        **** }
 166               	.LM5:
 167 002a 1F91      		pop r17
 168 002c 0F91      		pop r16
 169 002e 0895      		ret
 174               	.Lscope1:
 176               		.stabd	78,0,0
 177               		.section	.text.startup,"ax",@progbits
 179               	.global	main
 181               	main:
 182               		.stabd	46,0,0
  49:test.c        **** 
  50:test.c        **** #define NOOP asm volatile("nop" ::)
  51:test.c        **** 
  52:test.c        **** static void setup_clock( void )
  53:test.c        **** {
  54:test.c        **** 	/*Examine Page 33*/
  55:test.c        **** 
  56:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
  57:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
  58:test.c        **** 
  59:test.c        **** 
  60:test.c        **** }
GAS LISTING /tmp/ccouZRfQ.s 			page 6


  61:test.c        **** 
  62:test.c        **** //#define SMARTPWR
  63:test.c        **** 
  64:test.c        **** 
  65:test.c        **** //unsigned char ETbuffer[390];
  66:test.c        **** 
  67:test.c        **** void SendTestASM( const unsigned char * c, uint8_t len );
  68:test.c        **** int MaybeHaveDataASM( unsigned char * c, uint8_t lenX2 ); //returns the number of pairs.
  69:test.c        **** 
  70:test.c        **** 
  71:test.c        **** 
  72:test.c        **** int main( )
  73:test.c        **** {
 184               	.LM6:
 185               	.LFBB2:
 186               	/* prologue: function */
 187               	/* frame size = 0 */
 188               	/* stack size = 0 */
 189               	.L__stack_usage = 0
  74:test.c        **** 	int i;
  75:test.c        **** 	cli();
 191               	.LM7:
 192               	/* #APP */
 193               	 ;  75 "test.c" 1
 194 0000 F894      		cli
 195               	 ;  0 "" 2
 196               	/* #NOAPP */
 197               	.LBB10:
 198               	.LBB11:
  56:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
 200               	.LM8:
 201 0002 80E8      		ldi r24,lo8(-128)
 202 0004 86BD      		out 0x26,r24
  57:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
 204               	.LM9:
 205 0006 16BC      		out 0x26,__zero_reg__
 206               	.LBE11:
 207               	.LBE10:
  76:test.c        **** 
  77:test.c        **** 	setup_clock();
  78:test.c        **** 
  79:test.c        **** 	DDRB = _BV(1);
 209               	.LM10:
 210 0008 82E0      		ldi r24,lo8(2)
 211 000a 87BB      		out 0x17,r24
  80:test.c        **** 
  81:test.c        **** 	//1st let's see how fast we can clock the pin.
  82:test.c        **** 	et_init( MyMAC );
 213               	.LM11:
 214 000c 80E0      		ldi r24,lo8(MyMAC)
 215 000e 90E0      		ldi r25,hi8(MyMAC)
 216 0010 00D0      		rcall et_init
 217 0012 80E0      		ldi r24,lo8(PacketA)
 218 0014 90E0      		ldi r25,hi8(PacketA)
 219 0016 A0E0      		ldi r26,lo8(ETbuffer)
 220 0018 B0E0      		ldi r27,hi8(ETbuffer)
 221               	.L8:
GAS LISTING /tmp/ccouZRfQ.s 			page 7


 222               	.LBB12:
  83:test.c        **** 
  84:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
  85:test.c        **** 	{
  86:test.c        **** 		ETbuffer[i] = pgm_read_word( &PacketA[i] );
 224               	.LM12:
 225 001a FC01      		movw r30,r24
 226               	/* #APP */
 227               	 ;  86 "test.c" 1
 228 001c 2591      		lpm r18, Z+
 229 001e 3491      		lpm r19, Z
 230               		
 231               	 ;  0 "" 2
 232               	/* #NOAPP */
 233               	.LBE12:
 234 0020 2D93      		st X+,r18
 235 0022 0196      		adiw r24,1
  84:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
 237               	.LM13:
 238 0024 20E0      		ldi r18,hi8(PacketA+76)
 239 0026 8030      		cpi r24,lo8(PacketA+76)
 240 0028 9207      		cpc r25,r18
 241 002a 01F4      		brne .L8
 242               	.LBB13:
  87:test.c        **** 	}
  88:test.c        **** 
  89:test.c        **** 	i = 0;
  90:test.c        **** 
  91:test.c        **** 	int frame = 0;
  92:test.c        **** 
  93:test.c        **** 	struct EthernetPacket * sbe = (struct EthernetPacket*)ETbuffer;
  94:test.c        **** 
  95:test.c        **** 	while(1)
  96:test.c        **** 	{
  97:test.c        **** 	//	SendTestASM( ETbuffer, PacketABytes/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
  98:test.c        **** 	//	continue;
  99:test.c        **** 		et_recvpack();
 100:test.c        **** 
 101:test.c        **** 		i++;
 102:test.c        **** 
 103:test.c        **** 		if( i == 20 )
 104:test.c        **** 		{
 105:test.c        **** #ifdef SMARTPWR
 106:test.c        **** 			DDRB |= _BV(1);
 107:test.c        **** #endif
 108:test.c        **** 
 109:test.c        **** 			//UDP Data starts at byte #50
 110:test.c        **** 			struct EthernetPacket * sbe = (struct EthernetPacket*)ETbuffer;
 111:test.c        **** //			sbe->payload[0] = 0xBB;
 112:test.c        **** //			sbe->payload[1] = frame++;
 113:test.c        **** 			sbe->addyfrom = 0x450a000a;
 244               	.LM14:
 245 002c 9AE0      		ldi r25,lo8(10)
 246 002e C92E      		mov r12,r25
 247 0030 D12C      		mov r13,__zero_reg__
 248 0032 EC2C      		mov r14,r12
 249 0034 95E4      		ldi r25,lo8(69)
GAS LISTING /tmp/ccouZRfQ.s 			page 8


 250 0036 F92E      		mov r15,r25
 251               	.L12:
 252               	.LBE13:
  73:test.c        **** {
 254               	.LM15:
 255 0038 C4E1      		ldi r28,lo8(20)
 256 003a D0E0      		ldi r29,0
 257               	.L10:
  99:test.c        **** 		et_recvpack();
 259               	.LM16:
 260 003c 00D0      		rcall et_recvpack
 261 003e 2197      		sbiw r28,1
 103:test.c        **** 		if( i == 20 )
 263               	.LM17:
 264 0040 2097      		sbiw r28,0
 265 0042 01F4      		brne .L10
 266               	.LBB14:
 268               	.LM18:
 269 0044 C092 0000 		sts ETbuffer+26,r12
 270 0048 D092 0000 		sts ETbuffer+26+1,r13
 271 004c E092 0000 		sts ETbuffer+26+2,r14
 272 0050 F092 0000 		sts ETbuffer+26+3,r15
 114:test.c        **** 			int rr = Ethernetize( ETbuffer, PacketABytes, 320);
 274               	.LM19:
 275 0054 40E4      		ldi r20,lo8(64)
 276 0056 51E0      		ldi r21,lo8(1)
 277 0058 6CE4      		ldi r22,lo8(76)
 278 005a 70E0      		ldi r23,0
 279 005c 80E0      		ldi r24,lo8(ETbuffer)
 280 005e 90E0      		ldi r25,hi8(ETbuffer)
 281 0060 00D0      		rcall Ethernetize
 115:test.c        **** 
 116:test.c        **** 			SendTestASM( ETbuffer, rr/4 + 3 - 2 ); //MUST BE DIVISIBLE BY 2 # of bytes.
 283               	.LM20:
 284 0062 97FD      		sbrc r25,7
 285 0064 0396      		adiw r24,3
 286               	.L11:
 287 0066 BC01      		movw r22,r24
 288 0068 7595      		asr r23
 289 006a 6795      		ror r22
 290 006c 7595      		asr r23
 291 006e 6795      		ror r22
 292 0070 6F5F      		subi r22,lo8(-(1))
 293 0072 80E0      		ldi r24,lo8(ETbuffer)
 294 0074 90E0      		ldi r25,hi8(ETbuffer)
 295 0076 00D0      		rcall SendTestASM
 296 0078 00C0      		rjmp .L12
 297               	.LBE14:
 299               	.Lscope2:
 301               		.stabd	78,0,0
 302               		.text
 304               	.Letext0:
 305               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccouZRfQ.s 			page 9


DEFINED SYMBOLS
                            *ABS*:0000000000000000 test.c
     /tmp/ccouZRfQ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccouZRfQ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccouZRfQ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccouZRfQ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccouZRfQ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccouZRfQ.s:116    .text:0000000000000000 delay_ms
     /tmp/ccouZRfQ.s:181    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
MyMAC
et_init
PacketA
ETbuffer
et_recvpack
Ethernetize
SendTestASM
GAS LISTING /tmp/ccouZRfQ.s 			page 1


   1               	# 1 "asmtest.S"
   1               	/*
   1               	...
   0               	
   2               	    Copyright (C) 2014 <>< Charles Lohr
   3               	
   4               	
   5               	    Permission is hereby granted, free of charge, to any person obtaining a
   6               		copy of this software and associated documentation files (the "Software"),
   7               		to deal in the Software without restriction, including without limitation
   8               		the rights to use, copy, modify, merge, publish, distribute, sublicense,
   9               		and/or sell copies of the Software, and to permit persons to whom the
  10               		Software is furnished to do so, subject to the following conditions:
  11               	
  12               	    The above copyright notice and this permission notice shall be included
  13               		in all copies or substantial portions of the Software.
  14               	
  15               	    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  16               		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  17               		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  18               		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  19               		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  20               		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  21               		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  22               	*/
  23               	
  24               	
  25               	
  26               	#define _SFR_ASM_COMPAT 1
  27               	#define __SFR_OFFSET 0
  28               	
  29               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
GAS LISTING /tmp/ccouZRfQ.s 			page 2


  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h 2211 2011-02-14 14:04:25Z aboyapati $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
GAS LISTING /tmp/ccouZRfQ.s 			page 3


  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
GAS LISTING /tmp/ccouZRfQ.s 			page 4


 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
GAS LISTING /tmp/ccouZRfQ.s 			page 5


 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__) || defined (__AVR_ATmega325A__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__) || defined (__AVR_ATmega3250A__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__) || defined (__AVR_ATmega329A__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__) || defined (__AVR_ATmega3290A__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega32HVBREVB__)
 234               	#  include <avr/iom32hvbrevb.h>
 235               	#elif defined (__AVR_ATmega406__)
 236               	#  include <avr/iom406.h>
 237               	#elif defined (__AVR_ATmega16__)
 238               	#  include <avr/iom16.h>
 239               	#elif defined (__AVR_ATmega16A__)
 240               	#  include <avr/iom16a.h>
 241               	#elif defined (__AVR_ATmega161__)
 242               	#  include <avr/iom161.h>
 243               	#elif defined (__AVR_ATmega162__)
 244               	#  include <avr/iom162.h>
 245               	#elif defined (__AVR_ATmega163__)
 246               	#  include <avr/iom163.h>
 247               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 248               	#  include <avr/iom164.h>
 249               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 250               	#  include <avr/iom165.h>
 251               	#elif defined (__AVR_ATmega165P__)
 252               	#  include <avr/iom165p.h>
GAS LISTING /tmp/ccouZRfQ.s 			page 6


 253               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 254               	#  include <avr/iom168.h>
 255               	#elif defined (__AVR_ATmega168P__)
 256               	#  include <avr/iom168p.h>
 257               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 258               	#  include <avr/iom169.h>
 259               	#elif defined (__AVR_ATmega169P__)
 260               	#  include <avr/iom169p.h>
 261               	#elif defined (__AVR_ATmega169PA__)
 262               	#  include <avr/iom169pa.h>
 263               	#elif defined (__AVR_ATmega8HVA__)
 264               	#  include <avr/iom8hva.h>
 265               	#elif defined (__AVR_ATmega16HVA__)
 266               	#  include <avr/iom16hva.h>
 267               	#elif defined (__AVR_ATmega16HVA2__)
 268               	#  include <avr/iom16hva2.h>
 269               	#elif defined (__AVR_ATmega16HVB__)
 270               	#  include <avr/iom16hvb.h>
 271               	#elif defined (__AVR_ATmega16HVBREVB__)
 272               	#  include <avr/iom16hvbrevb.h>
 273               	#elif defined (__AVR_ATmega8__)
 274               	#  include <avr/iom8.h>
 275               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 276               	#  include <avr/iom48.h>
 277               	#elif defined (__AVR_ATmega48P__)
 278               	#  include <avr/iom48p.h>
 279               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 280               	#  include <avr/iom88.h>
 281               	#elif defined (__AVR_ATmega88P__)
 282               	#  include <avr/iom88p.h>
 283               	#elif defined (__AVR_ATmega88PA__)
 284               	#  include <avr/iom88pa.h>
 285               	#elif defined (__AVR_ATmega8515__)
 286               	#  include <avr/iom8515.h>
 287               	#elif defined (__AVR_ATmega8535__)
 288               	#  include <avr/iom8535.h>
 289               	#elif defined (__AVR_AT90S8535__)
 290               	#  include <avr/io8535.h>
 291               	#elif defined (__AVR_AT90C8534__)
 292               	#  include <avr/io8534.h>
 293               	#elif defined (__AVR_AT90S8515__)
 294               	#  include <avr/io8515.h>
 295               	#elif defined (__AVR_AT90S4434__)
 296               	#  include <avr/io4434.h>
 297               	#elif defined (__AVR_AT90S4433__)
 298               	#  include <avr/io4433.h>
 299               	#elif defined (__AVR_AT90S4414__)
 300               	#  include <avr/io4414.h>
 301               	#elif defined (__AVR_ATtiny22__)
 302               	#  include <avr/iotn22.h>
 303               	#elif defined (__AVR_ATtiny26__)
 304               	#  include <avr/iotn26.h>
 305               	#elif defined (__AVR_AT90S2343__)
 306               	#  include <avr/io2343.h>
 307               	#elif defined (__AVR_AT90S2333__)
 308               	#  include <avr/io2333.h>
 309               	#elif defined (__AVR_AT90S2323__)
GAS LISTING /tmp/ccouZRfQ.s 			page 7


 310               	#  include <avr/io2323.h>
 311               	#elif defined (__AVR_AT90S2313__)
 312               	#  include <avr/io2313.h>
 313               	#elif defined (__AVR_ATtiny4__)
 314               	#  include <avr/iotn4.h>
 315               	#elif defined (__AVR_ATtiny5__)
 316               	#  include <avr/iotn5.h>
 317               	#elif defined (__AVR_ATtiny9__)
 318               	#  include <avr/iotn9.h>
 319               	#elif defined (__AVR_ATtiny10__)
 320               	#  include <avr/iotn10.h>
 321               	#elif defined (__AVR_ATtiny20__)
 322               	#  include <avr/iotn20.h>
 323               	#elif defined (__AVR_ATtiny40__)
 324               	#  include <avr/iotn40.h>
 325               	#elif defined (__AVR_ATtiny2313__)
 326               	#  include <avr/iotn2313.h>
 327               	#elif defined (__AVR_ATtiny2313A__)
 328               	#  include <avr/iotn2313a.h>
 329               	#elif defined (__AVR_ATtiny13__)
 330               	#  include <avr/iotn13.h>
 331               	#elif defined (__AVR_ATtiny13A__)
 332               	#  include <avr/iotn13a.h>
 333               	#elif defined (__AVR_ATtiny25__)
 334               	#  include <avr/iotn25.h>
 335               	#elif defined (__AVR_ATtiny4313__)
 336               	#  include <avr/iotn4313.h>
 337               	#elif defined (__AVR_ATtiny45__)
 338               	#  include <avr/iotn45.h>
 339               	#elif defined (__AVR_ATtiny85__)
 340               	#  include <avr/iotn85.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
GAS LISTING /tmp/ccouZRfQ.s 			page 8


  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iotn85.h 2115 2010-04-05 23:19:53Z arcanum $ */
  32               	
  33               	/* avr/iotn85.h - definitions for ATtiny85 */
  34               	
  35               	#ifndef _AVR_IOTN85_H_
  36               	#define _AVR_IOTN85_H_ 1
  37               	
  38               	#include <avr/iotnx5.h>
   1               	/* Copyright (c) 2005,2007 Anatoly Sokolov
  39               	
 341               	#elif defined (__AVR_ATtiny24__)
 342               	#  include <avr/iotn24.h>
 343               	#elif defined (__AVR_ATtiny24A__)
 344               	#  include <avr/iotn24a.h>
 345               	#elif defined (__AVR_ATtiny44__)
 346               	#  include <avr/iotn44.h>
 347               	#elif defined (__AVR_ATtiny44A__)
 348               	#  include <avr/iotn44a.h>
 349               	#elif defined (__AVR_ATtiny84__)
 350               	#  include <avr/iotn84.h>
 351               	#elif defined (__AVR_ATtiny84A__)
 352               	#  include <avr/iotn84a.h>  
 353               	#elif defined (__AVR_ATtiny261__)
 354               	#  include <avr/iotn261.h>
 355               	#elif defined (__AVR_ATtiny261A__)
 356               	#  include <avr/iotn261a.h>
 357               	#elif defined (__AVR_ATtiny461__)
 358               	#  include <avr/iotn461.h>
 359               	#elif defined (__AVR_ATtiny461A__)
 360               	#  include <avr/iotn461a.h>
 361               	#elif defined (__AVR_ATtiny861__)
 362               	#  include <avr/iotn861.h>
 363               	#elif defined (__AVR_ATtiny861A__)
 364               	#  include <avr/iotn861a.h>
 365               	#elif defined (__AVR_ATtiny43U__)
 366               	#  include <avr/iotn43u.h>
 367               	#elif defined (__AVR_ATtiny48__)
 368               	#  include <avr/iotn48.h>
 369               	#elif defined (__AVR_ATtiny88__)
 370               	#  include <avr/iotn88.h>
 371               	#elif defined (__AVR_ATtiny87__)
 372               	#  include <avr/iotn87.h>
 373               	#elif defined (__AVR_ATtiny167__)
 374               	#  include <avr/iotn167.h>
 375               	#elif defined (__AVR_AT90SCR100__)
 376               	#  include <avr/io90scr100.h>
 377               	#elif defined (__AVR_ATxmega16A4__)
 378               	#  include <avr/iox16a4.h>
 379               	#elif defined (__AVR_ATxmega16D4__)
 380               	#  include <avr/iox16d4.h>
 381               	#elif defined (__AVR_ATxmega32A4__)
 382               	#  include <avr/iox32a4.h>
 383               	#elif defined (__AVR_ATxmega32D4__)
GAS LISTING /tmp/ccouZRfQ.s 			page 9


 384               	#  include <avr/iox32d4.h>
 385               	#elif defined (__AVR_ATxmega64A1__)
 386               	#  include <avr/iox64a1.h>
 387               	#elif defined (__AVR_ATxmega64A1U__)
 388               	#  include <avr/iox64a1u.h>
 389               	#elif defined (__AVR_ATxmega64A3__)
 390               	#  include <avr/iox64a3.h>
 391               	#elif defined (__AVR_ATxmega64D3__)
 392               	#  include <avr/iox64d3.h>
 393               	#elif defined (__AVR_ATxmega128A1__)
 394               	#  include <avr/iox128a1.h>
 395               	#elif defined (__AVR_ATxmega128A1U__)
 396               	#  include <avr/iox128a1u.h>
 397               	#elif defined (__AVR_ATxmega128A3__)
 398               	#  include <avr/iox128a3.h>
 399               	#elif defined (__AVR_ATxmega128D3__)
 400               	#  include <avr/iox128d3.h>
 401               	#elif defined (__AVR_ATxmega192A3__)
 402               	#  include <avr/iox192a3.h>
 403               	#elif defined (__AVR_ATxmega192D3__)
 404               	#  include <avr/iox192d3.h>
 405               	#elif defined (__AVR_ATxmega256A3__)
 406               	#  include <avr/iox256a3.h>
 407               	#elif defined (__AVR_ATxmega256A3B__)
 408               	#  include <avr/iox256a3b.h>
 409               	#elif defined (__AVR_ATxmega256D3__)
 410               	#  include <avr/iox256d3.h>
 411               	#elif defined (__AVR_ATA6289__)
 412               	#  include <avr/ioa6289.h>
 413               	/* avr1: the following only supported for assembler programs */
 414               	#elif defined (__AVR_ATtiny28__)
 415               	#  include <avr/iotn28.h>
 416               	#elif defined (__AVR_AT90S1200__)
 417               	#  include <avr/io1200.h>
 418               	#elif defined (__AVR_ATtiny15__)
 419               	#  include <avr/iotn15.h>
 420               	#elif defined (__AVR_ATtiny12__)
 421               	#  include <avr/iotn12.h>
 422               	#elif defined (__AVR_ATtiny11__)
 423               	#  include <avr/iotn11.h>
 424               	#elif defined (__AVR_M3000__)
 425               	#  include <avr/iom3000.h>
 426               	#else
 427               	#  if !defined(__COMPILING_AVR_LIBC__)
 428               	#    warning "device type not defined"
 429               	#  endif
 430               	#endif
 431               	
 432               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 433               	
 434               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 435               	
 436               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 437               	
GAS LISTING /tmp/ccouZRfQ.s 			page 10


 438               	/* Include fuse.h after individual IO header files. */
 439               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 440               	
 441               	/* Include lock.h after individual IO header files. */
 442               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 443               	
  30               	
  31               	#define USEBR  USIDR
  32               	.global SendTick
  33               	SendTick:
  34:asmtest.S     **** 	ori r18, 0b00010101
  35:asmtest.S     **** 	ori r19, 0b00001101
  36:asmtest.S     **** 	ori r20, 0b00000101
  37:asmtest.S     **** 	out PORTB, r19
  38:asmtest.S     **** 	out PORTB, r19
  39:asmtest.S     **** 	out PORTB, r18
  40:asmtest.S     **** 	out PORTB, r18
  41:asmtest.S     **** 	out PORTB, r20
  42:asmtest.S     **** 	ret
  43               	
  44               	
  45               	//Handles sending preamble + Packet ovr the USI
  46               	.global SendTestASM  // ( unsigned char * ptr_to_packet, uint8_t packet_length_longs ); (longs = pa
  47               	SendTestASM:
  48:asmtest.S     **** 	push r16
  49:asmtest.S     **** 	push r17
  50:asmtest.S     **** 	push r18
  51:asmtest.S     **** 	push r19
  52:asmtest.S     **** 	push r20
  53:asmtest.S     **** 	ldi r27,0
  54:asmtest.S     **** 	ldi r26,0
  55:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable))
  56:asmtest.S     **** 	sbci r27,hi8(-(ManchesterTable))
  57               	//	mov r17, r26 // For backup
  58               		  //Manchester table now in X.
  59               	
  60               		//Move "Packet to send" into Z (R30, 31)
  61:asmtest.S     **** 	movw r30,r24
  62               	//	add r22,r24
  63               	//	adc r23,r25
  64               	
  65               		//r22 = how big to send.
  66               		
  67:asmtest.S     **** 	mov r16, r22
  68:asmtest.S     **** 	ld r18,Z+
  69:asmtest.S     **** 	mov r26, r18 
  70:asmtest.S     **** 	andi r26, 0x0f
  71:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1  (This sets X up)
  72               	SendLoop:
  73:asmtest.S     **** 	tst r16
  74:asmtest.S     **** 	brne .SkipD
  75:asmtest.S     **** 	rjmp .Done
  76               	.SkipD:
  77               	
  78               	
GAS LISTING /tmp/ccouZRfQ.s 			page 11


  79               	//////////////////////////////////////////////////
  80               	//Special: preamble.
  81:asmtest.S     **** 	ldi r20, 15   //Iterate 15 times. (the 0x55 pattern) then finish out with the 0xD5 pattern.
  82:asmtest.S     **** 	ldi r19, 0b01100110  //Standard 0x55 pattern
  83:asmtest.S     **** 	ldi r17, 0b01100101  //Final pattern marker.
  84               		//Go ahead with the preamble.
  85               		//Enable the USI
  86:asmtest.S     **** 	SBI USICR, USIWM0
  87               	
  88               	.PreambleLoop:
  89:asmtest.S     **** 	out USEBR, r19
  90:asmtest.S     **** 	nop
  91:asmtest.S     **** 	nop
  92:asmtest.S     **** 	nop
  93:asmtest.S     **** 	nop
  94:asmtest.S     **** 	dec r20
  95:asmtest.S     **** 	brne .PreambleLoop
  96:asmtest.S     ****     nop
  97:asmtest.S     **** 	out USEBR, r17
  98:asmtest.S     **** 	nop
  99               	
 100:asmtest.S     **** 	nop
 101:asmtest.S     **** 	nop
 102               	
 103               	KeepGoing:			///subi r26,lo8(-(ManchesterTable))
 104               	
 105               		//Heavily interleved code.  Need a new OUTB every 8 cycles exactly.
 106:asmtest.S     ****     nop           //1 //Look, ma ONE EXTRA CYCLE!
 107               		//nop
 108               	
 109:asmtest.S     **** 	ld r19, X      //2
 110:asmtest.S     **** 	swap r18       //1
 111:asmtest.S     **** 	out USEBR, r19 //1  START HERE
 112:asmtest.S     **** 	mov r26, r18   //1
 113:asmtest.S     **** 	andi r26, 0x0f //1
 114:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 115:asmtest.S     **** 	ld r19, X      //2
 116:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 117:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 118:asmtest.S     **** 	mov r26, r18   //1
 119               	
 120               	
 121:asmtest.S     **** 	andi r26, 0x0f //1
 122:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 123:asmtest.S     **** 	ld r19, X      //2
 124:asmtest.S     **** 	swap r18       //1
 125:asmtest.S     **** 	mov r26, r18   //1
 126:asmtest.S     **** 	out USEBR, r19 //1  ** OK
 127:asmtest.S     **** 	andi r26, 0x0f //1
 128:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 129:asmtest.S     **** 	ld r19, X      //2
 130:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 131:asmtest.S     **** 	mov r26, r18   //1
 132:asmtest.S     **** 	out USEBR, r19 //1  **OK
 133               	
 134               	
 135:asmtest.S     **** 	andi r26, 0x0f //1
GAS LISTING /tmp/ccouZRfQ.s 			page 12


 136:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 137:asmtest.S     **** 	ld r19, X      //2
 138:asmtest.S     **** 	swap r18       //1
 139:asmtest.S     **** 	mov r26, r18   //1
 140:asmtest.S     **** 	andi r26, 0x0f //1
 141:asmtest.S     **** 	out USEBR, r19 //1  ** OK 
 142:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 143:asmtest.S     **** 	ld r19, X      //2
 144:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 145:asmtest.S     **** 	mov r26, r18   //1
 146:asmtest.S     **** 	andi r26, 0x0f //1
 147:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 148:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 149:asmtest.S     **** 	ld r19, X      //2
 150:asmtest.S     **** 	swap r18       //1
 151:asmtest.S     **** 	mov r26, r18   //1
 152:asmtest.S     **** 	andi r26, 0x0f //1
 153:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 154:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 155:asmtest.S     **** 	ld r19, X      //2
 156:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 157:asmtest.S     **** 	mov r26, r18   //1
 158:asmtest.S     **** 	andi r26, 0x0f //1
 159:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 160:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 161               	
 162:asmtest.S     **** 	dec r16         //1
 163:asmtest.S     **** 	brne KeepGoing  //2
 164               	.Done:
 165:asmtest.S     **** 	nop
 166:asmtest.S     **** 	nop
 167:asmtest.S     **** 	nop
 168:asmtest.S     **** 	nop
 169:asmtest.S     **** 	andi r19,0
 170:asmtest.S     **** 	nop
 171:asmtest.S     **** 	out USEBR,r19 
 172:asmtest.S     **** 	CBI USICR, USIWM0
 173               	
 174:asmtest.S     **** 	pop r20
 175:asmtest.S     **** 	pop r19
 176:asmtest.S     **** 	pop r18
 177:asmtest.S     **** 	pop r17
 178:asmtest.S     **** 	mov r24, r16
 179:asmtest.S     **** 	pop r16
 180:asmtest.S     **** 	ret
 181               	
 182               	
 183               	#define USEBRR  USIDR
 184               	//#define USEBRR  ADCL
 185               	
 186               	.global MaybeHaveDataASM
 187               	MaybeHaveDataASM:
 188               	
 189:asmtest.S     **** 	push r16
 190:asmtest.S     **** 	push r22
 191:asmtest.S     **** 	push r18
 192:asmtest.S     **** 	push r19
GAS LISTING /tmp/ccouZRfQ.s 			page 13


 193:asmtest.S     **** 	push r20
 194               	
 195               						//r22 = words in buffer.
 196:asmtest.S     **** 	movw r30,r24    //r24:r25 = pointer to staging ram.
 197               	
 198               		//In here, we're operating at 30 ~MHz (hopefully)
 199               		//We want to peel the data off the SPI bus as fast as possible!
 200               	
 201:asmtest.S     **** 	tst r22
 202:asmtest.S     **** 	breq rlend
 203               	rloop:
 204               	
 205               	///XXX TODO: Scrutenize the "breq" 
 206:asmtest.S     **** 	in r19,USEBRR  //1  ****
 207:asmtest.S     **** 	inc r19			//1
 208:asmtest.S     ****     breq rlend    //2???
 209:asmtest.S     ****     nop           //1????
 210:asmtest.S     **** 	dec r19		//1
 211:asmtest.S     **** 	breq rlend  //2????
 212:asmtest.S     **** 	nop         //1
 213:asmtest.S     **** 	nop         //1
 214               	
 215:asmtest.S     **** 	in r18,USEBRR  //1  ****
 216:asmtest.S     **** 	st Z+, r19    //2
 217:asmtest.S     **** 	st Z+, r18    //2
 218:asmtest.S     **** 	dec r22       //1
 219:asmtest.S     **** 	brne rloop    //2
 220               	
 221               	rlend:
 222:asmtest.S     **** 	mov r24,r22
 223:asmtest.S     **** 	pop r20
 224:asmtest.S     **** 	pop r19
 225:asmtest.S     **** 	pop r18
 226:asmtest.S     **** 	pop r22
 227:asmtest.S     **** 	pop r16
 228:asmtest.S     **** 	ret
GAS LISTING /tmp/ccouZRfQ.s 			page 14


DEFINED SYMBOLS
           asmtest.S:33     .text:0000000000000000 SendTick
           asmtest.S:47     .text:0000000000000012 SendTestASM
           asmtest.S:72     .text:0000000000000030 SendLoop
           asmtest.S:76     .text:0000000000000036 .SkipD
           asmtest.S:164    .text:00000000000000bc .Done
           asmtest.S:88     .text:000000000000003e .PreambleLoop
           asmtest.S:103    .text:0000000000000056 KeepGoing
           asmtest.S:187    .text:00000000000000da MaybeHaveDataASM
           asmtest.S:221    .text:0000000000000104 rlend
           asmtest.S:203    .text:00000000000000ea rloop

UNDEFINED SYMBOLS
ManchesterTable
GAS LISTING /tmp/ccouZRfQ.s 			page 1


   1               		.file	"sendpack.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 107               	.global	PacketA
 108               		.section	.progmem.data,"a",@progbits
 111               	PacketA:
 112 0000 FF        		.byte	-1
 113 0001 FF        		.byte	-1
 114 0002 FF        		.byte	-1
 115 0003 FF        		.byte	-1
 116 0004 FF        		.byte	-1
 117 0005 FF        		.byte	-1
 118 0006 00        		.byte	0
 119 0007 55        		.byte	85
 120 0008 00        		.byte	0
 121 0009 55        		.byte	85
 122 000a 00        		.byte	0
 123 000b 55        		.byte	85
 124 000c 08        		.byte	8
 125 000d 00        		.byte	0
 126 000e 45        		.byte	69
 127 000f 00        		.byte	0
 128 0010 00        		.byte	0
 129 0011 32        		.byte	50
 130 0012 B3        		.byte	-77
 131 0013 1E        		.byte	30
 132 0014 00        		.byte	0
 133 0015 00        		.byte	0
 134 0016 80        		.byte	-128
 135 0017 11        		.byte	17
 136 0018 C6        		.byte	-58
 137 0019 8D        		.byte	-115
 138 001a C0        		.byte	-64
 139 001b A8        		.byte	-88
 140 001c 00        		.byte	0
 141 001d 67        		.byte	103
 142 001e FF        		.byte	-1
 143 001f FF        		.byte	-1
 144 0020 FF        		.byte	-1
 145 0021 FF        		.byte	-1
 146 0022 04        		.byte	4
 147 0023 00        		.byte	0
 148 0024 34        		.byte	52
 149 0025 00        		.byte	0
 150 0026 00        		.byte	0
 151 0027 1E        		.byte	30
 152 0028 18        		.byte	24
 153 0029 EE        		.byte	-18
 154 002a 43        		.byte	67
 155 002b 0A        		.byte	10
 156 002c AA        		.byte	-86
 157 002d AA        		.byte	-86
GAS LISTING /tmp/ccouZRfQ.s 			page 2


 158 002e AA        		.byte	-86
 159 002f AA        		.byte	-86
 160 0030 AA        		.byte	-86
 161 0031 AA        		.byte	-86
 162 0032 AA        		.byte	-86
 163 0033 AA        		.byte	-86
 164 0034 AA        		.byte	-86
 165 0035 AA        		.byte	-86
 166 0036 AA        		.byte	-86
 167 0037 AA        		.byte	-86
 168 0038 AA        		.byte	-86
 169 0039 AA        		.byte	-86
 170 003a AA        		.byte	-86
 171 003b AA        		.byte	-86
 172 003c AA        		.byte	-86
 173 003d AA        		.byte	-86
 174 003e AA        		.byte	-86
 175 003f AA        		.byte	-86
 176 0040 5D        		.byte	93
 177 0041 FA        		.byte	-6
 178 0042 B6        		.byte	-74
 179 0043 1A        		.byte	26
 181               		.text
 183               	.Letext0:
 184               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccouZRfQ.s 			page 3


DEFINED SYMBOLS
                            *ABS*:0000000000000000 sendpack.c
     /tmp/ccouZRfQ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccouZRfQ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccouZRfQ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccouZRfQ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccouZRfQ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccouZRfQ.s:111    .progmem.data:0000000000000000 PacketA

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccouZRfQ.s 			page 1


   1               		.file	"packetmater.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  98               	.global	crc32b
 100               	crc32b:
 101               		.stabd	46,0,0
   1:packetmater.c **** //Packet mater.  A super tiny file that helps with checksums and ethernet CRCs.
   2:packetmater.c **** //CRC Was taken from linked page.
   3:packetmater.c **** 
   4:packetmater.c **** /*
   5:packetmater.c ****     Copyright (C) 2014 <>< Charles Lohr
   6:packetmater.c **** 
   7:packetmater.c **** 
   8:packetmater.c ****     Permission is hereby granted, free of charge, to any person obtaining a
   9:packetmater.c **** 	copy of this software and associated documentation files (the "Software"),
  10:packetmater.c **** 	to deal in the Software without restriction, including without limitation
  11:packetmater.c **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  12:packetmater.c **** 	and/or sell copies of the Software, and to permit persons to whom the
  13:packetmater.c **** 	Software is furnished to do so, subject to the following conditions:
  14:packetmater.c **** 
  15:packetmater.c ****     The above copyright notice and this permission notice shall be included
  16:packetmater.c **** 	in all copies or substantial portions of the Software.
  17:packetmater.c **** 
  18:packetmater.c ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  19:packetmater.c **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  20:packetmater.c **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  21:packetmater.c **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  22:packetmater.c **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  23:packetmater.c **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  24:packetmater.c **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  25:packetmater.c **** */
  26:packetmater.c **** #include "packetmater.h"
  27:packetmater.c **** 
  28:packetmater.c **** //Fix all checksums for UDP packets and add etherlink CRC.
  29:packetmater.c **** uint16_t Ethernetize( unsigned char * packet, int plen, int udplenoverride )
  30:packetmater.c **** {
  31:packetmater.c **** 	plen -= 4;
  32:packetmater.c **** 
  33:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
  34:packetmater.c **** 		plen = (udplenoverride+8) + 34;
  35:packetmater.c **** 
  36:packetmater.c **** 	//Need to buffer to 4-byte boundaries.
  37:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
  38:packetmater.c **** 
  39:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
  40:packetmater.c **** 	{
  41:packetmater.c **** 		uint16_t fullpacklen = plen-14;
  42:packetmater.c **** 		packet[16] = fullpacklen>>8;
  43:packetmater.c **** 		packet[17] = fullpacklen&0xff;
  44:packetmater.c **** 		packet[24] = 0;
  45:packetmater.c **** 		packet[25] = 0;
  46:packetmater.c **** 		uint16_t csumr;
GAS LISTING /tmp/ccouZRfQ.s 			page 2


  47:packetmater.c **** //		fprintf( stderr, "Header checksum: 0x%04x\n", csumr = csrange(14,20) );
  48:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
  49:packetmater.c **** 
  50:packetmater.c **** 		packet[24] = csumr>>8;
  51:packetmater.c **** 		packet[25] = csumr&0xff;
  52:packetmater.c **** 
  53:packetmater.c **** 		if( packet[23] == 0x11  )
  54:packetmater.c **** 		{
  55:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
  56:packetmater.c **** 			packet[32+6] = udppacklen>>8;
  57:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
  58:packetmater.c **** 
  59:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
  60:packetmater.c **** 			packet[40+0] = pseudo>>8;
  61:packetmater.c **** 			packet[40+1] = pseudo&0xff;
  62:packetmater.c **** 
  63:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
  64:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
  65:packetmater.c **** 			packet[40+0] = csumr>>8;
  66:packetmater.c **** 			packet[40+1] = csumr&0xff;
  67:packetmater.c **** 		}
  68:packetmater.c **** 	}
  69:packetmater.c **** 
  70:packetmater.c **** 
  71:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
  72:packetmater.c **** 
  73:packetmater.c **** 	packet[plen+0] = crc & 0xff;
  74:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
  75:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
  76:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
  77:packetmater.c **** 
  78:packetmater.c **** 	return plen;
  79:packetmater.c **** }
  80:packetmater.c **** 
  81:packetmater.c **** 
  82:packetmater.c **** //From: http://www.hackersdelight.org/hdcodetxt/crc.c.txt
  83:packetmater.c **** uint32_t crc32b(uint32_t crc, unsigned char *message, int len) {
 103               	.LM0:
 104               	.LFBB1:
 105 0000 AF92      		push r10
 106 0002 BF92      		push r11
 107 0004 CF92      		push r12
 108 0006 DF92      		push r13
 109 0008 EF92      		push r14
 110 000a FF92      		push r15
 111 000c 0F93      		push r16
 112 000e 1F93      		push r17
 113 0010 CF93      		push r28
 114 0012 DF93      		push r29
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 10 */
 118               	.L__stack_usage = 10
 119 0014 5901      		movw r10,r18
  84:packetmater.c ****    int i, j;
  85:packetmater.c ****    uint32_t mask;
  86:packetmater.c **** 	uint8_t byte;
GAS LISTING /tmp/ccouZRfQ.s 			page 3


  87:packetmater.c **** 
  88:packetmater.c ****    i = 0;
  89:packetmater.c **** //   crc = 0xFFFFFFFF;
  90:packetmater.c **** 	crc = ~crc;
 121               	.LM1:
 122 0016 6095      		com r22
 123 0018 7095      		com r23
 124 001a 8095      		com r24
 125 001c 9095      		com r25
  91:packetmater.c ****    while (i < len) {
 127               	.LM2:
 128 001e FA01      		movw r30,r20
 129               	.L2:
 130 0020 9F01      		movw r18,r30
 131 0022 241B      		sub r18,r20
 132 0024 350B      		sbc r19,r21
 134               	.LM3:
 135 0026 2A15      		cp r18,r10
 136 0028 3B05      		cpc r19,r11
 137 002a 04F4      		brge .L8
  92:packetmater.c ****       byte = message[i];            // Get next byte.
 139               	.LM4:
 140 002c 2191      		ld r18,Z+
  93:packetmater.c ****       crc = crc ^ byte;
 142               	.LM5:
 143 002e 6227      		eor r22,r18
 144 0030 A8E0      		ldi r26,lo8(8)
 145 0032 B0E0      		ldi r27,0
 146               	.L4:
  94:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
  95:packetmater.c ****          mask = -(crc & 1);
  96:packetmater.c ****          crc = (crc >> 1) ^ (0xEDB88320 & mask);
 148               	.LM6:
 149 0034 8B01      		movw r16,r22
 150 0036 9C01      		movw r18,r24
 151 0038 3695      		lsr r19
 152 003a 2795      		ror r18
 153 003c 1795      		ror r17
 154 003e 0795      		ror r16
  95:packetmater.c ****          mask = -(crc & 1);
 156               	.LM7:
 157 0040 6B01      		movw r12,r22
 158 0042 7C01      		movw r14,r24
 159 0044 C1E0      		ldi r28,1
 160 0046 CC22      		and r12,r28
 161 0048 DD24      		clr r13
 162 004a EE24      		clr r14
 163 004c FF24      		clr r15
 164 004e 6627      		clr r22
 165 0050 7727      		clr r23
 166 0052 CB01      		movw r24,r22
 167 0054 6C19      		sub r22,r12
 168 0056 7D09      		sbc r23,r13
 169 0058 8E09      		sbc r24,r14
 170 005a 9F09      		sbc r25,r15
 172               	.LM8:
 173 005c 6072      		andi r22,32
GAS LISTING /tmp/ccouZRfQ.s 			page 4


 174 005e 7378      		andi r23,131
 175 0060 887B      		andi r24,184
 176 0062 9D7E      		andi r25,237
 177 0064 6027      		eor r22,r16
 178 0066 7127      		eor r23,r17
 179 0068 8227      		eor r24,r18
 180 006a 9327      		eor r25,r19
 181 006c 1197      		sbiw r26,1
  94:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
 183               	.LM9:
 184 006e 1097      		sbiw r26,0
 185 0070 01F4      		brne .L4
 186 0072 00C0      		rjmp .L2
 187               	.L8:
  97:packetmater.c ****       }
  98:packetmater.c ****       i = i + 1;
  99:packetmater.c ****    }
 100:packetmater.c ****    return ~crc;
 189               	.LM10:
 190 0074 6095      		com r22
 191 0076 7095      		com r23
 192 0078 8095      		com r24
 193 007a 9095      		com r25
 194               	/* epilogue start */
 101:packetmater.c **** }
 196               	.LM11:
 197 007c DF91      		pop r29
 198 007e CF91      		pop r28
 199 0080 1F91      		pop r17
 200 0082 0F91      		pop r16
 201 0084 FF90      		pop r15
 202 0086 EF90      		pop r14
 203 0088 DF90      		pop r13
 204 008a CF90      		pop r12
 205 008c BF90      		pop r11
 206 008e AF90      		pop r10
 207 0090 0895      		ret
 212               	.Lscope1:
 214               		.stabd	78,0,0
 218               	.global	internet_checksum
 220               	internet_checksum:
 221               		.stabd	46,0,0
 102:packetmater.c **** 
 103:packetmater.c **** uint16_t internet_checksum( const unsigned char * start, uint16_t len )
 104:packetmater.c **** {
 223               	.LM12:
 224               	.LFBB2:
 225 0092 CF93      		push r28
 226 0094 DF93      		push r29
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 2 */
 230               	.L__stack_usage = 2
 231 0096 9B01      		movw r18,r22
 232 0098 DC01      		movw r26,r24
 105:packetmater.c **** 	uint16_t i;
 106:packetmater.c **** 	const uint16_t * wptr = (uint16_t*) start;
GAS LISTING /tmp/ccouZRfQ.s 			page 5


 107:packetmater.c **** 	uint32_t csum = 0;
 234               	.LM13:
 235 009a 40E0      		ldi r20,0
 236 009c 50E0      		ldi r21,0
 237 009e BA01      		movw r22,r20
 108:packetmater.c **** 	for (i=1;i<len;i+=2)
 239               	.LM14:
 240 00a0 E1E0      		ldi r30,lo8(1)
 241 00a2 F0E0      		ldi r31,0
 242               	.L10:
 244               	.LM15:
 245 00a4 E217      		cp r30,r18
 246 00a6 F307      		cpc r31,r19
 247 00a8 00F4      		brsh .L18
 109:packetmater.c **** 	{
 110:packetmater.c **** 		csum = csum + (uint32_t)(*(wptr++));	
 249               	.LM16:
 250 00aa CD91      		ld r28,X+
 251 00ac DD91      		ld r29,X+
 252 00ae 4C0F      		add r20,r28
 253 00b0 5D1F      		adc r21,r29
 254 00b2 611D      		adc r22,__zero_reg__
 255 00b4 711D      		adc r23,__zero_reg__
 108:packetmater.c **** 	for (i=1;i<len;i+=2)
 257               	.LM17:
 258 00b6 3296      		adiw r30,2
 259 00b8 00C0      		rjmp .L10
 260               	.L18:
 261 00ba F901      		movw r30,r18
 262 00bc EE7F      		andi r30,254
 263 00be E80F      		add r30,r24
 264 00c0 F91F      		adc r31,r25
 111:packetmater.c **** 	}
 112:packetmater.c **** 	if( len & 1 )  //See if there's an odd number of bytes?
 266               	.LM18:
 267 00c2 20FF      		sbrs r18,0
 268 00c4 00C0      		rjmp .L13
 269               	.LBB2:
 113:packetmater.c **** 	{
 114:packetmater.c **** 		uint8_t * tt = (uint8_t*)wptr;
 115:packetmater.c **** 		csum += *tt;
 271               	.LM19:
 272 00c6 8081      		ld r24,Z
 273 00c8 480F      		add r20,r24
 274 00ca 511D      		adc r21,__zero_reg__
 275 00cc 611D      		adc r22,__zero_reg__
 276 00ce 711D      		adc r23,__zero_reg__
 277               	.L13:
 278               	.LBE2:
 116:packetmater.c **** 	}
 117:packetmater.c **** 	while (csum>>16)
 280               	.LM20:
 281 00d0 CB01      		movw r24,r22
 282 00d2 AA27      		clr r26
 283 00d4 BB27      		clr r27
 284 00d6 0097      		sbiw r24,0
 285 00d8 A105      		cpc r26,__zero_reg__
GAS LISTING /tmp/ccouZRfQ.s 			page 6


 286 00da B105      		cpc r27,__zero_reg__
 287 00dc 01F0      		breq .L19
 118:packetmater.c **** 		csum = (csum & 0xFFFF)+(csum >> 16);
 289               	.LM21:
 290 00de 6627      		clr r22
 291 00e0 7727      		clr r23
 292 00e2 480F      		add r20,r24
 293 00e4 591F      		adc r21,r25
 294 00e6 6A1F      		adc r22,r26
 295 00e8 7B1F      		adc r23,r27
 296 00ea 00C0      		rjmp .L13
 297               	.L19:
 119:packetmater.c **** 	csum = (csum>>8) | ((csum&0xff)<<8);
 299               	.LM22:
 300 00ec BB27      		clr r27
 301 00ee A72F      		mov r26,r23
 302 00f0 962F      		mov r25,r22
 303 00f2 852F      		mov r24,r21
 304 00f4 762F      		mov r23,r22
 305 00f6 652F      		mov r22,r21
 306 00f8 542F      		mov r21,r20
 307 00fa 4427      		clr r20
 308 00fc 6627      		clr r22
 309 00fe 7727      		clr r23
 310 0100 482B      		or r20,r24
 311 0102 592B      		or r21,r25
 312 0104 6A2B      		or r22,r26
 313 0106 7B2B      		or r23,r27
 120:packetmater.c **** 	return ~csum;
 315               	.LM23:
 316 0108 CA01      		movw r24,r20
 317 010a 8095      		com r24
 318 010c 9095      		com r25
 319               	/* epilogue start */
 121:packetmater.c **** }
 321               	.LM24:
 322 010e DF91      		pop r29
 323 0110 CF91      		pop r28
 324 0112 0895      		ret
 329               	.Lscope2:
 331               		.stabd	78,0,0
 336               	.global	Ethernetize
 338               	Ethernetize:
 339               		.stabd	46,0,0
  30:packetmater.c **** {
 341               	.LM25:
 342               	.LFBB3:
 343 0114 CF92      		push r12
 344 0116 DF92      		push r13
 345 0118 EF92      		push r14
 346 011a FF92      		push r15
 347 011c 0F93      		push r16
 348 011e 1F93      		push r17
 349 0120 CF93      		push r28
 350 0122 DF93      		push r29
 351               	/* prologue: function */
 352               	/* frame size = 0 */
GAS LISTING /tmp/ccouZRfQ.s 			page 7


 353               	/* stack size = 8 */
 354               	.L__stack_usage = 8
 355 0124 EC01      		movw r28,r24
 356 0126 7A01      		movw r14,r20
  33:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
 358               	.LM26:
 359 0128 9A01      		movw r18,r20
 360 012a 295F      		subi r18,-7
 361 012c 3F4F      		sbci r19,-1
 362 012e CB01      		movw r24,r22
 363 0130 8697      		sbiw r24,38
 364 0132 2817      		cp r18,r24
 365 0134 3907      		cpc r19,r25
 366 0136 04F4      		brge .L21
  31:packetmater.c **** 	plen -= 4;
 368               	.LM27:
 369 0138 8B01      		movw r16,r22
 370 013a 0450      		subi r16,4
 371 013c 1109      		sbc r17,__zero_reg__
 372 013e 00C0      		rjmp .L22
 373               	.L21:
  34:packetmater.c **** 		plen = (udplenoverride+8) + 34;
 375               	.LM28:
 376 0140 8A01      		movw r16,r20
 377 0142 065D      		subi r16,-42
 378 0144 1F4F      		sbci r17,-1
 379               	.L22:
  37:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
 381               	.LM29:
 382 0146 0150      		subi r16,1
 383 0148 1109      		sbc r17,__zero_reg__
 384 014a 0C7F      		andi r16,252
 385 014c 6801      		movw r12,r16
 386 014e 84E0      		ldi r24,4
 387 0150 C80E      		add r12,r24
 388 0152 D11C      		adc r13,__zero_reg__
  39:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 390               	.LM30:
 391 0154 8C85      		ldd r24,Y+12
 392 0156 8830      		cpi r24,lo8(8)
 393 0158 01F4      		brne .L24
  39:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 395               	.LM31:
 396 015a 8D85      		ldd r24,Y+13
 397 015c 8111      		cpse r24,__zero_reg__
 398 015e 00C0      		rjmp .L24
 399               	.LBB3:
  41:packetmater.c **** 		uint16_t fullpacklen = plen-14;
 401               	.LM32:
 402 0160 C801      		movw r24,r16
 403 0162 0A97      		sbiw r24,10
  42:packetmater.c **** 		packet[16] = fullpacklen>>8;
 405               	.LM33:
 406 0164 988B      		std Y+16,r25
  43:packetmater.c **** 		packet[17] = fullpacklen&0xff;
 408               	.LM34:
 409 0166 898B      		std Y+17,r24
GAS LISTING /tmp/ccouZRfQ.s 			page 8


  44:packetmater.c **** 		packet[24] = 0;
 411               	.LM35:
 412 0168 188E      		std Y+24,__zero_reg__
  45:packetmater.c **** 		packet[25] = 0;
 414               	.LM36:
 415 016a 198E      		std Y+25,__zero_reg__
  48:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
 417               	.LM37:
 418 016c 64E1      		ldi r22,lo8(20)
 419 016e 70E0      		ldi r23,0
 420 0170 CE01      		movw r24,r28
 421 0172 0E96      		adiw r24,14
 422 0174 00D0      		rcall internet_checksum
  50:packetmater.c **** 		packet[24] = csumr>>8;
 424               	.LM38:
 425 0176 988F      		std Y+24,r25
  51:packetmater.c **** 		packet[25] = csumr&0xff;
 427               	.LM39:
 428 0178 898F      		std Y+25,r24
  53:packetmater.c **** 		if( packet[23] == 0x11  )
 430               	.LM40:
 431 017a 8F89      		ldd r24,Y+23
 432 017c 8131      		cpi r24,lo8(17)
 433 017e 01F4      		brne .L24
 434               	.LBB4:
  55:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
 436               	.LM41:
 437 0180 B701      		movw r22,r14
 438 0182 685F      		subi r22,-8
 439 0184 7F4F      		sbci r23,-1
  56:packetmater.c **** 			packet[32+6] = udppacklen>>8;
 441               	.LM42:
 442 0186 7EA3      		std Y+38,r23
  57:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
 444               	.LM43:
 445 0188 6FA3      		std Y+39,r22
  59:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
 447               	.LM44:
 448 018a 89E1      		ldi r24,25
 449 018c E80E      		add r14,r24
 450 018e F11C      		adc r15,__zero_reg__
  60:packetmater.c **** 			packet[40+0] = pseudo>>8;
 452               	.LM45:
 453 0190 F8A6      		std Y+40,r15
  61:packetmater.c **** 			packet[40+1] = pseudo&0xff;
 455               	.LM46:
 456 0192 E9A6      		std Y+41,r14
  63:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
 458               	.LM47:
 459 0194 685F      		subi r22,-8
 460 0196 7F4F      		sbci r23,-1
 461 0198 CE01      		movw r24,r28
 462 019a 4A96      		adiw r24,26
 463 019c 00D0      		rcall internet_checksum
  64:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
 465               	.LM48:
 466 019e 0097      		sbiw r24,0
GAS LISTING /tmp/ccouZRfQ.s 			page 9


 467 01a0 01F4      		brne .L26
 468 01a2 8FEF      		ldi r24,lo8(-1)
 469 01a4 9FEF      		ldi r25,lo8(-1)
 470               	.L26:
  65:packetmater.c **** 			packet[40+0] = csumr>>8;
 472               	.LM49:
 473 01a6 98A7      		std Y+40,r25
  66:packetmater.c **** 			packet[40+1] = csumr&0xff;
 475               	.LM50:
 476 01a8 89A7      		std Y+41,r24
 477               	.L24:
 478               	.LBE4:
 479               	.LBE3:
  71:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
 481               	.LM51:
 482 01aa 9601      		movw r18,r12
 483 01ac AE01      		movw r20,r28
 484 01ae 60E0      		ldi r22,0
 485 01b0 70E0      		ldi r23,0
 486 01b2 CB01      		movw r24,r22
 487 01b4 00D0      		rcall crc32b
  73:packetmater.c **** 	packet[plen+0] = crc & 0xff;
 489               	.LM52:
 490 01b6 FE01      		movw r30,r28
 491 01b8 EC0D      		add r30,r12
 492 01ba FD1D      		adc r31,r13
 493 01bc 6083      		st Z,r22
  74:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
 495               	.LM53:
 496 01be C00F      		add r28,r16
 497 01c0 D11F      		adc r29,r17
 498 01c2 7D83      		std Y+5,r23
  75:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
 500               	.LM54:
 501 01c4 8E83      		std Y+6,r24
  76:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
 503               	.LM55:
 504 01c6 9F83      		std Y+7,r25
  79:packetmater.c **** }
 506               	.LM56:
 507 01c8 C601      		movw r24,r12
 508               	/* epilogue start */
 509 01ca DF91      		pop r29
 510 01cc CF91      		pop r28
 511 01ce 1F91      		pop r17
 512 01d0 0F91      		pop r16
 513 01d2 FF90      		pop r15
 514 01d4 EF90      		pop r14
 515 01d6 DF90      		pop r13
 516 01d8 CF90      		pop r12
 517 01da 0895      		ret
 522               	.Lscope3:
 524               		.stabd	78,0,0
 526               	.Letext0:
 527               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccouZRfQ.s 			page 10


DEFINED SYMBOLS
                            *ABS*:0000000000000000 packetmater.c
     /tmp/ccouZRfQ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccouZRfQ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccouZRfQ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccouZRfQ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccouZRfQ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccouZRfQ.s:100    .text:0000000000000000 crc32b
     /tmp/ccouZRfQ.s:220    .text:0000000000000092 internet_checksum
     /tmp/ccouZRfQ.s:338    .text:0000000000000114 Ethernetize

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccouZRfQ.s 			page 1


   1               		.file	"hlprocess.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  96               	.global	Demanchestrate
  98               	Demanchestrate:
  99               		.stabd	46,0,0
   1:hlprocess.c   **** #include "hlprocess.h"
   2:hlprocess.c   **** 
   3:hlprocess.c   **** //Note: -1 indicates unmatched short pulse.  I.e. quick transitions must pair up.
   4:hlprocess.c   **** int16_t Demanchestrate( unsigned char * raw_data_packet, uint16_t max_packet_data_len )
   5:hlprocess.c   **** {
 101               	.LM0:
 102               	.LFBB1:
 103 0000 CF92      		push r12
 104 0002 DF92      		push r13
 105 0004 EF92      		push r14
 106 0006 FF92      		push r15
 107 0008 0F93      		push r16
 108 000a 1F93      		push r17
 109 000c CF93      		push r28
 110 000e DF93      		push r29
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 8 */
 114               	.L__stack_usage = 8
 115 0010 FC01      		movw r30,r24
   6:hlprocess.c   **** 	uint8_t in_preamble = 4;
   7:hlprocess.c   **** 	uint8_t t;
   8:hlprocess.c   **** 	uint8_t mask;
   9:hlprocess.c   **** 
  10:hlprocess.c   **** 	uint8_t bit;
  11:hlprocess.c   **** 	uint8_t lastbit = 0;
  12:hlprocess.c   **** 	int8_t count = 0;
  13:hlprocess.c   **** 	uint16_t plen = 0;
  14:hlprocess.c   **** 	uint8_t shortflag = 0;
  15:hlprocess.c   **** 
  16:hlprocess.c   **** 	uint8_t cemitbit = 1; //current emitting bit.
  17:hlprocess.c   **** 	uint8_t cemitbyte = 0;
  18:hlprocess.c   **** 	uint8_t cemitmask = 1;
 117               	.LM1:
 118 0012 B1E0      		ldi r27,lo8(1)
  17:hlprocess.c   **** 	uint8_t cemitbyte = 0;
 120               	.LM2:
 121 0014 D0E0      		ldi r29,0
  16:hlprocess.c   **** 	uint8_t cemitbit = 1; //current emitting bit.
 123               	.LM3:
 124 0016 11E0      		ldi r17,lo8(1)
  14:hlprocess.c   **** 	uint8_t shortflag = 0;
 126               	.LM4:
 127 0018 A0E0      		ldi r26,0
  13:hlprocess.c   **** 	uint16_t plen = 0;
 129               	.LM5:
GAS LISTING /tmp/ccouZRfQ.s 			page 2


 130 001a 20E0      		ldi r18,0
 131 001c 30E0      		ldi r19,0
  12:hlprocess.c   **** 	int8_t count = 0;
 133               	.LM6:
 134 001e 60E0      		ldi r22,0
  11:hlprocess.c   **** 	uint8_t lastbit = 0;
 136               	.LM7:
 137 0020 C0E0      		ldi r28,0
   6:hlprocess.c   **** 	uint8_t in_preamble = 4;
 139               	.LM8:
 140 0022 74E0      		ldi r23,lo8(4)
  19:hlprocess.c   **** 
  20:hlprocess.c   **** 	uint8_t * output = raw_data_packet;
  21:hlprocess.c   **** 
  22:hlprocess.c   **** 	while( 1 )
  23:hlprocess.c   **** 	{
  24:hlprocess.c   **** 		t = *(raw_data_packet++);
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
  26:hlprocess.c   **** 		{
  27:hlprocess.c   **** 			bit = (t&mask)?1:0;
 142               	.LM9:
 143 0024 DD24      		clr r13
 144 0026 D394      		inc r13
 145               	.L11:
  24:hlprocess.c   **** 		t = *(raw_data_packet++);
 147               	.LM10:
 148 0028 E190      		ld r14,Z+
 149 002a FC2E      		mov r15,r28
 150 002c 48E0      		ldi r20,lo8(8)
 151 002e 50E0      		ldi r21,0
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
 153               	.LM11:
 154 0030 00E8      		ldi r16,lo8(-128)
 155               	.L12:
 157               	.LM12:
 158 0032 C1E0      		ldi r28,lo8(1)
 159 0034 C02E      		mov r12,r16
 160 0036 CE20      		and r12,r14
 161 0038 01F4      		brne .L2
 162 003a C0E0      		ldi r28,0
 163               	.L2:
  28:hlprocess.c   **** 			if( bit != lastbit )
 165               	.LM13:
 166 003c CF15      		cp r28,r15
 167 003e 01F0      		breq .L3
  29:hlprocess.c   **** 			{
  30:hlprocess.c   **** 				//Ignore first two changes.
  31:hlprocess.c   **** 				if( in_preamble > 2 && count > 1 )
 169               	.LM14:
 170 0040 7330      		cpi r23,lo8(3)
 171 0042 00F0      		brlo .L4
 173               	.LM15:
 174 0044 6230      		cpi r22,lo8(2)
 175 0046 04F4      		brge .L21
 176 0048 00C0      		rjmp .L20
 177               	.L4:
  32:hlprocess.c   **** 				{
GAS LISTING /tmp/ccouZRfQ.s 			page 3


  33:hlprocess.c   **** 					in_preamble--;
  34:hlprocess.c   **** 				}
  35:hlprocess.c   **** 				else if( in_preamble <= 2 && count < 2 && in_preamble )
 179               	.LM16:
 180 004a 6230      		cpi r22,lo8(2)
 181 004c 04F4      		brge .L6
 182 004e 7723      		tst r23
 183 0050 01F0      		breq .L7
 184               	.L21:
  36:hlprocess.c   **** 				{
  37:hlprocess.c   **** 					in_preamble--;
 186               	.LM17:
 187 0052 7150      		subi r23,lo8(-(-1))
 188 0054 00C0      		rjmp .L20
 189               	.L7:
 190               	.LBB2:
  38:hlprocess.c   **** 				}
  39:hlprocess.c   **** 				else if( !in_preamble )
  40:hlprocess.c   **** 				{
  41:hlprocess.c   **** 					uint8_t mark_emit = 0;
  42:hlprocess.c   **** 
  43:hlprocess.c   **** 					//Something happened.
  44:hlprocess.c   **** 					//If it's immediate, i.e. count = 0, count = 1 -> short (mark for ticking)
  45:hlprocess.c   **** 					//If it's later, i.e. count = 2, count = 3 -> long (invert)
  46:hlprocess.c   **** 					//We cannot get >3 as that's handled when we increase count.
  47:hlprocess.c   **** 					if( count > 1 )
  48:hlprocess.c   **** 					{
  49:hlprocess.c   **** 						if( shortflag )
  50:hlprocess.c   **** 						{
  51:hlprocess.c   **** 							return -1;
  52:hlprocess.c   **** 						}
  53:hlprocess.c   **** 						//invert bit.
  54:hlprocess.c   **** 						cemitbit = !cemitbit;
  55:hlprocess.c   **** 
  56:hlprocess.c   **** 						mark_emit = 1;
  57:hlprocess.c   **** 					}
  58:hlprocess.c   **** 					else
  59:hlprocess.c   **** 					{
  60:hlprocess.c   **** 						if( shortflag )
 192               	.LM18:
 193 0056 A111      		cpse r26,__zero_reg__
 194 0058 00C0      		rjmp .L9
  61:hlprocess.c   **** 						{
  62:hlprocess.c   **** 							mark_emit = 1;
  63:hlprocess.c   **** 							shortflag = 0;
  64:hlprocess.c   **** 						}
  65:hlprocess.c   **** 						else
  66:hlprocess.c   **** 						{
  67:hlprocess.c   **** 							shortflag = 1;
 196               	.LM19:
 197 005a A1E0      		ldi r26,lo8(1)
 198               	.L20:
 199               	.LBE2:
  68:hlprocess.c   **** 						}
  69:hlprocess.c   **** 					}
  70:hlprocess.c   **** 					if( mark_emit )
  71:hlprocess.c   **** 					{
GAS LISTING /tmp/ccouZRfQ.s 			page 4


  72:hlprocess.c   **** 						//Emit cemitbit. 
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
  74:hlprocess.c   **** 						cemitmask <<= 1;
  75:hlprocess.c   **** 
  76:hlprocess.c   **** 						if( (cemitmask&0xff) == 0 )
  77:hlprocess.c   **** 						{
  78:hlprocess.c   **** 							output[plen++] = cemitbyte;
  79:hlprocess.c   **** 							cemitbyte = 0;
  80:hlprocess.c   **** 							cemitmask = 1;
  81:hlprocess.c   **** 						}
  82:hlprocess.c   **** 						mark_emit = 0;
  83:hlprocess.c   **** 					}
  84:hlprocess.c   **** 				}
  85:hlprocess.c   **** 
  86:hlprocess.c   **** 				lastbit = bit;
  87:hlprocess.c   **** 				count = 0;
 201               	.LM20:
 202 005c 60E0      		ldi r22,0
 203 005e 00C0      		rjmp .L5
 204               	.L3:
  88:hlprocess.c   **** 			}
  89:hlprocess.c   **** 			else
  90:hlprocess.c   **** 			{
  91:hlprocess.c   **** 				count++;
 206               	.LM21:
 207 0060 6F5F      		subi r22,lo8(-(1))
  92:hlprocess.c   **** 				if( count > 3 )
 209               	.LM22:
 210 0062 6430      		cpi r22,lo8(4)
 211 0064 04F0      		brlt .L5
  93:hlprocess.c   **** 				{
  94:hlprocess.c   **** 					return plen;
 213               	.LM23:
 214 0066 C901      		movw r24,r18
 215 0068 00C0      		rjmp .L19
 216               	.L6:
  39:hlprocess.c   **** 				else if( !in_preamble )
 218               	.LM24:
 219 006a 7111      		cpse r23,__zero_reg__
 220 006c 00C0      		rjmp .L20
 221               	.LBB3:
  49:hlprocess.c   **** 						if( shortflag )
 223               	.LM25:
 224 006e A111      		cpse r26,__zero_reg__
 225 0070 00C0      		rjmp .L17
  54:hlprocess.c   **** 						cemitbit = !cemitbit;
 227               	.LM26:
 228 0072 1D25      		eor r17,r13
 229               	.L9:
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 231               	.LM27:
 232 0074 1123      		tst r17
 233 0076 01F0      		breq .L23
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 235               	.LM28:
 236 0078 6B2F      		mov r22,r27
 237               	.L14:
GAS LISTING /tmp/ccouZRfQ.s 			page 5


  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 239               	.LM29:
 240 007a D62B      		or r29,r22
  74:hlprocess.c   **** 						cemitmask <<= 1;
 242               	.LM30:
 243 007c BB0F      		lsl r27
  76:hlprocess.c   **** 						if( (cemitmask&0xff) == 0 )
 245               	.LM31:
 246 007e 01F4      		brne .L18
  78:hlprocess.c   **** 							output[plen++] = cemitbyte;
 248               	.LM32:
 249 0080 DC01      		movw r26,r24
 250 0082 A20F      		add r26,r18
 251 0084 B31F      		adc r27,r19
 252 0086 DC93      		st X,r29
 253 0088 2F5F      		subi r18,-1
 254 008a 3F4F      		sbci r19,-1
  80:hlprocess.c   **** 							cemitmask = 1;
 256               	.LM33:
 257 008c B1E0      		ldi r27,lo8(1)
  79:hlprocess.c   **** 							cemitbyte = 0;
 259               	.LM34:
 260 008e D0E0      		ldi r29,0
 261               	.L18:
 262 0090 A0E0      		ldi r26,0
 263               	.LBE3:
  87:hlprocess.c   **** 				count = 0;
 265               	.LM35:
 266 0092 60E0      		ldi r22,0
 267               	.LBB4:
 268 0094 70E0      		ldi r23,0
 269               	.L5:
 270               	.LBE4:
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
 272               	.LM36:
 273 0096 0695      		lsr r16
 274 0098 4150      		subi r20,1
 275 009a 5109      		sbc r21,__zero_reg__
 276 009c 4115      		cp r20,__zero_reg__
 277 009e 5105      		cpc r21,__zero_reg__
 278 00a0 01F0      		breq .L11
  27:hlprocess.c   **** 			bit = (t&mask)?1:0;
 280               	.LM37:
 281 00a2 FC2E      		mov r15,r28
 282 00a4 00C0      		rjmp .L12
 283               	.L23:
 284               	.LBB5:
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 286               	.LM38:
 287 00a6 60E0      		ldi r22,0
 288 00a8 00C0      		rjmp .L14
 289               	.L17:
  51:hlprocess.c   **** 							return -1;
 291               	.LM39:
 292 00aa 8FEF      		ldi r24,lo8(-1)
 293 00ac 9FEF      		ldi r25,lo8(-1)
 294               	.L19:
GAS LISTING /tmp/ccouZRfQ.s 			page 6


 295               	/* epilogue start */
 296               	.LBE5:
  95:hlprocess.c   **** 				}
  96:hlprocess.c   **** 			}
  97:hlprocess.c   **** 		}
  98:hlprocess.c   **** 		//Next byte.
  99:hlprocess.c   **** 	}
 100:hlprocess.c   **** }
 298               	.LM40:
 299 00ae DF91      		pop r29
 300 00b0 CF91      		pop r28
 301 00b2 1F91      		pop r17
 302 00b4 0F91      		pop r16
 303 00b6 FF90      		pop r15
 304 00b8 EF90      		pop r14
 305 00ba DF90      		pop r13
 306 00bc CF90      		pop r12
 307 00be 0895      		ret
 319               	.Lscope1:
 321               		.stabd	78,0,0
 323               	.Letext0:
 324               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccouZRfQ.s 			page 7


DEFINED SYMBOLS
                            *ABS*:0000000000000000 hlprocess.c
     /tmp/ccouZRfQ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccouZRfQ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccouZRfQ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccouZRfQ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccouZRfQ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccouZRfQ.s:98     .text:0000000000000000 Demanchestrate

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccouZRfQ.s 			page 1


   1               		.file	"net_compat.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 110               	et_push8:
 111               		.stabd	46,0,0
 113               	.Ltext1:
   1:net_compat.h  **** #ifndef _ENC424JCOMPAT_H
   2:net_compat.h  **** #define _ENC424JCOMPAT_H
   3:net_compat.h  **** 
   4:net_compat.h  **** //enc424j600 compat lib.
   5:net_compat.h  **** //We're using the IP library from AVRCraft... but we're using our own PHY+MAC
   6:net_compat.h  **** 
   7:net_compat.h  **** //TODO: Should probably use Timer1 (since we can't use Timer0)
   8:net_compat.h  **** //to make sure we send media detect pulses at the right points.
   9:net_compat.h  **** //Also, as a user, you cannot use the USI or Timer0
  10:net_compat.h  **** 
  11:net_compat.h  **** #include <stdint.h>
  12:net_compat.h  **** #include "eth_config.h"
  13:net_compat.h  **** 
  14:net_compat.h  **** //MyMAC is included in this driver.
  15:net_compat.h  **** extern unsigned char MyMAC[6];
  16:net_compat.h  **** extern unsigned char ETbuffer[ETBUFFERSIZE];
  17:net_compat.h  **** extern unsigned short ETsendplace;
  18:net_compat.h  **** //For telling where the current transaction started.
  19:net_compat.h  **** extern uint16_t sendbaseaddress;
  20:net_compat.h  **** extern unsigned short ETchecksum;
  21:net_compat.h  **** 
  22:net_compat.h  **** //Do not split this across byte-addressing boundaries.
  23:net_compat.h  **** //We do some fancy stuff when we send the manchester out.
  24:net_compat.h  **** extern char ManchesterTable[16];
  25:net_compat.h  **** 
  26:net_compat.h  **** //return 0 if OK, otherwise nonzero.
  27:net_compat.h  **** int8_t et_init( const unsigned char * macaddy );
  28:net_compat.h  **** 
  29:net_compat.h  **** int8_t et_xmitpacket( uint16_t start, uint16_t len );
  30:net_compat.h  **** 
  31:net_compat.h  **** //This waits for 8ms, sends an autoneg notice, then waits for 8 more ms.
  32:net_compat.h  **** //Ordinarily this would if packets were processed and still ned processing, but
  33:net_compat.h  **** //that doesn't make sense for this driver.  Do not put this in a loop unto itself.
  34:net_compat.h  **** unsigned short et_recvpack();
  35:net_compat.h  **** 
  36:net_compat.h  **** //You have to write this! (Or the underlying IP core must)
  37:net_compat.h  **** void et_receivecallback( uint16_t packetlen );
  38:net_compat.h  **** 
  39:net_compat.h  **** //Finish up any reading. 							//CLOSURE
  40:net_compat.h  **** static inline void et_finish_callback_now() { }
  41:net_compat.h  **** 
  42:net_compat.h  **** //Raw, on-wire pops. (assuming already in read)
  43:net_compat.h  **** void et_popblob( uint8_t * data, uint8_t len );
  44:net_compat.h  **** static inline void et_dumpbytes( uint8_t len ) { ETsendplace += len; }
  45:net_compat.h  **** static inline uint16_t et_pop16() { return ETbuffer[ETsendplace++]; }
  46:net_compat.h  **** static inline uint8_t et_pop8() { return ETbuffer[ETsendplace++]; }
GAS LISTING /tmp/ccouZRfQ.s 			page 2


  47:net_compat.h  **** 
  48:net_compat.h  **** //Raw, on-wire push. (assuming already in write)
  49:net_compat.h  **** void et_pushpgmstr( const char * msg );
  50:net_compat.h  **** void et_pushstr( const char * msg );
  51:net_compat.h  **** void et_pushblob( const uint8_t * data, uint8_t len );
  52:net_compat.h  **** void et_pushpgmblob( const uint8_t * data, uint8_t len );
  53:net_compat.h  **** static inline void et_push8( uint8_t d ) { ETbuffer[ETsendplace++] = d; }
 115               	.LM0:
 116               	.LFBB1:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 122               	.LM1:
 123 0000 2091 0000 		lds r18,ETsendplace
 124 0004 3091 0000 		lds r19,ETsendplace+1
 125 0008 A901      		movw r20,r18
 126 000a 4F5F      		subi r20,-1
 127 000c 5F4F      		sbci r21,-1
 128 000e 5093 0000 		sts ETsendplace+1,r21
 129 0012 4093 0000 		sts ETsendplace,r20
 130 0016 F901      		movw r30,r18
 131 0018 E050      		subi r30,lo8(-(ETbuffer))
 132 001a F040      		sbci r31,hi8(-(ETbuffer))
 133 001c 8083      		st Z,r24
 134 001e 0895      		ret
 136               	.Lscope1:
 138               		.stabd	78,0,0
 143               	.global	GotPack
 145               	GotPack:
 146               		.stabd	46,0,0
 148               	.Ltext2:
   1:net_compat.c  **** #include "net_compat.h"
   2:net_compat.c  **** #include <avr/pgmspace.h>
   3:net_compat.c  **** #include <string.h>
   4:net_compat.c  **** 
   5:net_compat.c  **** #define NOOP asm volatile("nop" ::)
   6:net_compat.c  **** 
   7:net_compat.c  **** 
   8:net_compat.c  **** unsigned char MyMAC[6];
   9:net_compat.c  **** unsigned char ETbuffer[ETBUFFERSIZE];
  10:net_compat.c  **** unsigned short ETsendplace;
  11:net_compat.c  **** uint16_t sendbaseaddress;
  12:net_compat.c  **** unsigned short ETchecksum;
  13:net_compat.c  **** 
  14:net_compat.c  **** 
  15:net_compat.c  **** //Do not split this across byte-addressing boundaries.
  16:net_compat.c  **** //We do some fancy stuff when we send the manchester out.
  17:net_compat.c  **** char ManchesterTable[16] __attribute__ ((aligned (16))) = {
  18:net_compat.c  **** 	0b10101010, 0b01101010, 0b10011010, 0b01011010,
  19:net_compat.c  **** 	0b10100110, 0b01100110, 0b10010110, 0b01010110,
  20:net_compat.c  **** 	0b10101001, 0b01101001, 0b10011001, 0b01011001,
  21:net_compat.c  **** 	0b10100101, 0b01100101, 0b10010101, 0b01010101,
  22:net_compat.c  **** };
  23:net_compat.c  **** 
  24:net_compat.c  **** 
  25:net_compat.c  **** 
GAS LISTING /tmp/ccouZRfQ.s 			page 3


  26:net_compat.c  **** //Internal functs
  27:net_compat.c  **** 
  28:net_compat.c  **** //From the ASM file.
  29:net_compat.c  **** void SendTestASM( const unsigned char * c, uint8_t len );
  30:net_compat.c  **** int MaybeHaveDataASM( unsigned char * c, uint8_t lenX2 ); //returns the number of pairs.
  31:net_compat.c  **** 
  32:net_compat.c  **** //Attempt to return rough estimate of processing time.
  33:net_compat.c  **** int GotPack( unsigned char * machesterized, int estlen, uint16_t mlen )
  34:net_compat.c  **** {
 150               	.LM2:
 151               	.LFBB2:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  35:net_compat.c  **** 	int byr = 0;
  36:net_compat.c  **** 
  37:net_compat.c  **** //	byr = Demanchestrate( machesterized, mlen );
  38:net_compat.c  **** 
  39:net_compat.c  **** 	//Don't do anything yet...
  40:net_compat.c  **** 	//XXX TODO THIS will be some good stuff in here.
  41:net_compat.c  **** 
  42:net_compat.c  **** 	return byr;
  43:net_compat.c  **** }
 157               	.LM3:
 158 0020 80E0      		ldi r24,0
 159 0022 90E0      		ldi r25,0
 160 0024 0895      		ret
 162               	.Lscope2:
 164               		.stabd	78,0,0
 169               	.global	waitforpacket
 171               	waitforpacket:
 172               		.stabd	46,0,0
  44:net_compat.c  **** 
  45:net_compat.c  **** void waitforpacket( unsigned char * buffer, uint16_t len, int16_t ltime )
  46:net_compat.c  **** {
 174               	.LM4:
 175               	.LFBB3:
 176 0026 0F93      		push r16
 177 0028 1F93      		push r17
 178 002a CF93      		push r28
 179 002c DF93      		push r29
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 4 */
 183               	.L__stack_usage = 4
 184 002e 8B01      		movw r16,r22
 185 0030 EA01      		movw r28,r20
  47:net_compat.c  **** 	OSCCAL = OSCHIGH;
 187               	.LM5:
 188 0032 2FEF      		ldi r18,lo8(-1)
 189 0034 21BF      		out 0x31,r18
 190               	.L4:
  48:net_compat.c  **** 
  49:net_compat.c  **** 	//Make sure we're not walking in on something.
  50:net_compat.c  **** 	while( ltime-- > 0 )
 192               	.LM6:
GAS LISTING /tmp/ccouZRfQ.s 			page 4


 193 0036 2197      		sbiw r28,1
 194 0038 9E01      		movw r18,r28
 195 003a 2F5F      		subi r18,-1
 196 003c 3F4F      		sbci r19,-1
 197 003e 1216      		cp __zero_reg__,r18
 198 0040 1306      		cpc __zero_reg__,r19
 199 0042 04F4      		brge .L9
  51:net_compat.c  **** 	{
  52:net_compat.c  **** 		if( USIBR == 0x00 ) break;
 201               	.LM7:
 202 0044 20B3      		in r18,0x10
 203 0046 2223      		tst r18
 204 0048 01F0      		breq .L9
  53:net_compat.c  **** 		if( USIBR == 0xFF ) break;
 206               	.LM8:
 207 004a 20B3      		in r18,0x10
 208 004c 2F3F      		cpi r18,lo8(-1)
 209 004e 01F0      		breq .L9
  54:net_compat.c  **** 		NOOP;
 211               	.LM9:
 212               	/* #APP */
 213               	 ;  54 "net_compat.c" 1
 214 0050 0000      		nop
 215               	 ;  0 "" 2
 216               	/* #NOAPP */
 217 0052 00C0      		rjmp .L4
 218               	.L10:
  55:net_compat.c  **** 	}
  56:net_compat.c  **** 
  57:net_compat.c  **** 
  58:net_compat.c  **** 	while( ltime-- > 0 )
  59:net_compat.c  **** 	{
  60:net_compat.c  **** 		if( USIBR && (USIBR != 0xFF ) )
 220               	.LM10:
 221 0054 20B3      		in r18,0x10
 222 0056 2111      		cpse r18,__zero_reg__
 223 0058 00C0      		rjmp .L26
 224               	.L9:
  58:net_compat.c  **** 	while( ltime-- > 0 )
 226               	.LM11:
 227 005a 2197      		sbiw r28,1
 228 005c 9E01      		movw r18,r28
 229 005e 2F5F      		subi r18,-1
 230 0060 3F4F      		sbci r19,-1
 231 0062 1216      		cp __zero_reg__,r18
 232 0064 1306      		cpc __zero_reg__,r19
 233 0066 04F0      		brlt .L10
 234 0068 00C0      		rjmp .L8
 235               	.L26:
 237               	.LM12:
 238 006a 20B3      		in r18,0x10
 239 006c 2F3F      		cpi r18,lo8(-1)
 240 006e 01F0      		breq .L9
 241               	.LBB5:
  61:net_compat.c  **** 		{
  62:net_compat.c  **** 			int r = MaybeHaveDataASM( buffer, len );
 243               	.LM13:
GAS LISTING /tmp/ccouZRfQ.s 			page 5


 244 0070 602F      		mov r22,r16
 245 0072 00D0      		rcall MaybeHaveDataASM
  63:net_compat.c  **** 			if( r > 1 )
  64:net_compat.c  **** 			{
  65:net_compat.c  **** 				r += GotPack( buffer, r, len );
  66:net_compat.c  **** 			}
  67:net_compat.c  **** 			ltime-=(len-r)*4+3; //About how long the function takes to execute.
 247               	.LM14:
 248 0074 2397      		sbiw r28,3
 249 0076 B801      		movw r22,r16
 250 0078 681B      		sub r22,r24
 251 007a 790B      		sbc r23,r25
 252 007c 660F      		lsl r22
 253 007e 771F      		rol r23
 254 0080 660F      		lsl r22
 255 0082 771F      		rol r23
 256 0084 C61B      		sub r28,r22
 257 0086 D70B      		sbc r29,r23
 258               	.L8:
 259               	.LBE5:
  68:net_compat.c  **** 			break;
  69:net_compat.c  **** 		}
  70:net_compat.c  **** 	}
  71:net_compat.c  **** 
  72:net_compat.c  **** 
  73:net_compat.c  **** 	while( ltime-- > 0 )
 261               	.LM15:
 262 0088 1C16      		cp __zero_reg__,r28
 263 008a 1D06      		cpc __zero_reg__,r29
 264 008c 04F4      		brge .L27
  74:net_compat.c  **** 	{
  75:net_compat.c  **** 		NOOP;
 266               	.LM16:
 267               	/* #APP */
 268               	 ;  75 "net_compat.c" 1
 269 008e 0000      		nop
 270               	 ;  0 "" 2
  76:net_compat.c  **** 		NOOP;
 272               	.LM17:
 273               	 ;  76 "net_compat.c" 1
 274 0090 0000      		nop
 275               	 ;  0 "" 2
  77:net_compat.c  **** 		NOOP;
 277               	.LM18:
 278               	 ;  77 "net_compat.c" 1
 279 0092 0000      		nop
 280               	 ;  0 "" 2
  78:net_compat.c  **** 		NOOP;
 282               	.LM19:
 283               	 ;  78 "net_compat.c" 1
 284 0094 0000      		nop
 285               	 ;  0 "" 2
  79:net_compat.c  **** 		NOOP;
 287               	.LM20:
 288               	 ;  79 "net_compat.c" 1
 289 0096 0000      		nop
 290               	 ;  0 "" 2
GAS LISTING /tmp/ccouZRfQ.s 			page 6


 291               	/* #NOAPP */
 292 0098 2197      		sbiw r28,1
 293 009a 00C0      		rjmp .L8
 294               	.L27:
  80:net_compat.c  **** 	}
  81:net_compat.c  **** 
  82:net_compat.c  **** 	OSCCAL = OSC20;
 296               	.LM21:
 297 009c 8BEB      		ldi r24,lo8(-69)
 298 009e 81BF      		out 0x31,r24
 299               	/* epilogue start */
  83:net_compat.c  **** }
 301               	.LM22:
 302 00a0 DF91      		pop r29
 303 00a2 CF91      		pop r28
 304 00a4 1F91      		pop r17
 305 00a6 0F91      		pop r16
 306 00a8 0895      		ret
 308               	.Lscope3:
 310               		.stabd	78,0,0
 314               	.global	et_popblob
 316               	et_popblob:
 317               		.stabd	46,0,0
  84:net_compat.c  **** 
  85:net_compat.c  **** 
  86:net_compat.c  **** 
  87:net_compat.c  **** 
  88:net_compat.c  **** 
  89:net_compat.c  **** 
  90:net_compat.c  **** 
  91:net_compat.c  **** 
  92:net_compat.c  **** 
  93:net_compat.c  **** //
  94:net_compat.c  **** 
  95:net_compat.c  **** void et_popblob( uint8_t * data, uint8_t len )
  96:net_compat.c  **** {
 319               	.LM23:
 320               	.LFBB4:
 321               	/* prologue: function */
 322               	/* frame size = 0 */
 323               	/* stack size = 0 */
 324               	.L__stack_usage = 0
 325               	.L29:
  97:net_compat.c  **** 	while( len-- )
 327               	.LM24:
 328 00aa 6150      		subi r22,1
 329 00ac 00F0      		brcs .L31
 330               	.LBB8:
 331               	.LBB9:
 333               	.Ltext3:
  46:net_compat.h  **** static inline uint8_t et_pop8() { return ETbuffer[ETsendplace++]; }
 335               	.LM25:
 336 00ae 2091 0000 		lds r18,ETsendplace
 337 00b2 3091 0000 		lds r19,ETsendplace+1
 338 00b6 A901      		movw r20,r18
 339 00b8 4F5F      		subi r20,-1
 340 00ba 5F4F      		sbci r21,-1
GAS LISTING /tmp/ccouZRfQ.s 			page 7


 341 00bc 5093 0000 		sts ETsendplace+1,r21
 342 00c0 4093 0000 		sts ETsendplace,r20
 343 00c4 F901      		movw r30,r18
 344 00c6 E050      		subi r30,lo8(-(ETbuffer))
 345 00c8 F040      		sbci r31,hi8(-(ETbuffer))
 346 00ca 2081      		ld r18,Z
 347               	.LBE9:
 348               	.LBE8:
 350               	.Ltext4:
  98:net_compat.c  **** 	{
  99:net_compat.c  **** 		*(data++) = et_pop8();
 352               	.LM26:
 353 00cc FC01      		movw r30,r24
 354 00ce 2193      		st Z+,r18
 355 00d0 CF01      		movw r24,r30
 356 00d2 00C0      		rjmp .L29
 357               	.L31:
 358               	/* epilogue start */
 100:net_compat.c  **** 	}
 101:net_compat.c  **** }
 360               	.LM27:
 361 00d4 0895      		ret
 363               	.Lscope4:
 365               		.stabd	78,0,0
 368               	.global	et_pushpgmstr
 370               	et_pushpgmstr:
 371               		.stabd	46,0,0
 102:net_compat.c  **** 
 103:net_compat.c  **** void et_pushpgmstr( const char * msg )
 104:net_compat.c  **** {
 373               	.LM28:
 374               	.LFBB5:
 375 00d6 CF93      		push r28
 376 00d8 DF93      		push r29
 377               	/* prologue: function */
 378               	/* frame size = 0 */
 379               	/* stack size = 2 */
 380               	.L__stack_usage = 2
 381 00da FC01      		movw r30,r24
 382               	.L34:
 383               	.LBB10:
 105:net_compat.c  **** 	uint8_t r;
 106:net_compat.c  **** 	do
 107:net_compat.c  **** 	{
 108:net_compat.c  **** 		r = pgm_read_byte(msg++);
 385               	.LM29:
 386               	/* #APP */
 387               	 ;  108 "net_compat.c" 1
 388 00dc 8491      		lpm r24, Z
 389               		
 390               	 ;  0 "" 2
 391               	/* #NOAPP */
 392 00de EF01      		movw r28,r30
 393 00e0 2196      		adiw r28,1
 394               	.LBE10:
 109:net_compat.c  **** 		if( !r ) break;
 396               	.LM30:
GAS LISTING /tmp/ccouZRfQ.s 			page 8


 397 00e2 8823      		tst r24
 398 00e4 01F0      		breq .L32
 110:net_compat.c  **** 		et_push8( r );
 400               	.LM31:
 401 00e6 00D0      		rcall et_push8
 402 00e8 FE01      		movw r30,r28
 111:net_compat.c  **** 	} while( 1 );
 404               	.LM32:
 405 00ea 00C0      		rjmp .L34
 406               	.L32:
 407               	/* epilogue start */
 112:net_compat.c  **** }
 409               	.LM33:
 410 00ec DF91      		pop r29
 411 00ee CF91      		pop r28
 412 00f0 0895      		ret
 417               	.Lscope5:
 419               		.stabd	78,0,0
 422               	.global	et_pushpgmblob
 424               	et_pushpgmblob:
 425               		.stabd	46,0,0
 113:net_compat.c  **** 
 114:net_compat.c  **** void et_pushpgmblob( const uint8_t * data, uint8_t len )
 115:net_compat.c  **** {
 427               	.LM34:
 428               	.LFBB6:
 429 00f2 0F93      		push r16
 430 00f4 1F93      		push r17
 431 00f6 CF93      		push r28
 432 00f8 DF93      		push r29
 433 00fa 1F92      		push __zero_reg__
 434 00fc CDB7      		in r28,__SP_L__
 435 00fe DEB7      		in r29,__SP_H__
 436               	/* prologue: function */
 437               	/* frame size = 1 */
 438               	/* stack size = 5 */
 439               	.L__stack_usage = 5
 116:net_compat.c  **** 	while( len-- )
 441               	.LM35:
 442 0100 8C01      		movw r16,r24
 443 0102 680F      		add r22,r24
 444               	.L36:
 446               	.LM36:
 447 0104 6017      		cp r22,r16
 448 0106 01F0      		breq .L38
 449               	.LBB11:
 117:net_compat.c  **** 	{
 118:net_compat.c  **** 		et_push8( pgm_read_byte(data++) );
 451               	.LM37:
 452 0108 F801      		movw r30,r16
 453               	/* #APP */
 454               	 ;  118 "net_compat.c" 1
 455 010a 8491      		lpm r24, Z
 456               		
 457               	 ;  0 "" 2
 458               	/* #NOAPP */
 459               	.LBE11:
GAS LISTING /tmp/ccouZRfQ.s 			page 9


 460 010c 6983      		std Y+1,r22
 461 010e 00D0      		rcall et_push8
 462 0110 0F5F      		subi r16,-1
 463 0112 1F4F      		sbci r17,-1
 464 0114 6981      		ldd r22,Y+1
 465 0116 00C0      		rjmp .L36
 466               	.L38:
 467               	/* epilogue start */
 119:net_compat.c  **** 	}
 120:net_compat.c  **** }
 469               	.LM38:
 470 0118 0F90      		pop __tmp_reg__
 471 011a DF91      		pop r29
 472 011c CF91      		pop r28
 473 011e 1F91      		pop r17
 474 0120 0F91      		pop r16
 475 0122 0895      		ret
 480               	.Lscope6:
 482               		.stabd	78,0,0
 485               	.global	et_pushstr
 487               	et_pushstr:
 488               		.stabd	46,0,0
 121:net_compat.c  **** 
 122:net_compat.c  **** 
 123:net_compat.c  **** void et_pushstr( const char * msg )
 124:net_compat.c  **** {
 490               	.LM39:
 491               	.LFBB7:
 492 0124 CF93      		push r28
 493 0126 DF93      		push r29
 494               	/* prologue: function */
 495               	/* frame size = 0 */
 496               	/* stack size = 2 */
 497               	.L__stack_usage = 2
 498 0128 EC01      		movw r28,r24
 499               	.L40:
 125:net_compat.c  **** 	for( ; *msg; msg++ ) 
 501               	.LM40:
 502 012a 8991      		ld r24,Y+
 503 012c 8823      		tst r24
 504 012e 01F0      		breq .L42
 126:net_compat.c  **** 		et_push8( *msg );
 506               	.LM41:
 507 0130 00D0      		rcall et_push8
 508 0132 00C0      		rjmp .L40
 509               	.L42:
 510               	/* epilogue start */
 127:net_compat.c  **** }
 512               	.LM42:
 513 0134 DF91      		pop r29
 514 0136 CF91      		pop r28
 515 0138 0895      		ret
 517               	.Lscope7:
 519               		.stabd	78,0,0
 522               	.global	et_pushblob
 524               	et_pushblob:
 525               		.stabd	46,0,0
GAS LISTING /tmp/ccouZRfQ.s 			page 10


 128:net_compat.c  **** 
 129:net_compat.c  **** void et_pushblob( const uint8_t * data, uint8_t len )
 130:net_compat.c  **** {
 527               	.LM43:
 528               	.LFBB8:
 529 013a 0F93      		push r16
 530 013c 1F93      		push r17
 531 013e CF93      		push r28
 532 0140 DF93      		push r29
 533 0142 1F92      		push __zero_reg__
 534 0144 CDB7      		in r28,__SP_L__
 535 0146 DEB7      		in r29,__SP_H__
 536               	/* prologue: function */
 537               	/* frame size = 1 */
 538               	/* stack size = 5 */
 539               	.L__stack_usage = 5
 131:net_compat.c  **** 	while( len-- )
 541               	.LM44:
 542 0148 8C01      		movw r16,r24
 543 014a 680F      		add r22,r24
 544               	.L44:
 546               	.LM45:
 547 014c 6017      		cp r22,r16
 548 014e 01F0      		breq .L46
 132:net_compat.c  **** 	{
 133:net_compat.c  **** 		et_push8( *(data++) );
 550               	.LM46:
 551 0150 F801      		movw r30,r16
 552 0152 8191      		ld r24,Z+
 553 0154 8F01      		movw r16,r30
 554 0156 6983      		std Y+1,r22
 555 0158 00D0      		rcall et_push8
 556 015a 6981      		ldd r22,Y+1
 557 015c 00C0      		rjmp .L44
 558               	.L46:
 559               	/* epilogue start */
 134:net_compat.c  **** 	}
 135:net_compat.c  **** }
 561               	.LM47:
 562 015e 0F90      		pop __tmp_reg__
 563 0160 DF91      		pop r29
 564 0162 CF91      		pop r28
 565 0164 1F91      		pop r17
 566 0166 0F91      		pop r16
 567 0168 0895      		ret
 569               	.Lscope8:
 571               		.stabd	78,0,0
 574               	.global	et_init
 576               	et_init:
 577               		.stabd	46,0,0
 136:net_compat.c  **** 
 137:net_compat.c  **** 
 138:net_compat.c  **** //return 0 if OK, otherwise nonzero.
 139:net_compat.c  **** int8_t et_init( const unsigned char * macaddy )
 140:net_compat.c  **** {
 579               	.LM48:
 580               	.LFBB9:
GAS LISTING /tmp/ccouZRfQ.s 			page 11


 581               	/* prologue: function */
 582               	/* frame size = 0 */
 583               	/* stack size = 0 */
 584               	.L__stack_usage = 0
 585 016a FC01      		movw r30,r24
 141:net_compat.c  **** 	MyMAC[0] = macaddy[0];
 587               	.LM49:
 588 016c 8081      		ld r24,Z
 589 016e 8093 0000 		sts MyMAC,r24
 142:net_compat.c  **** 	MyMAC[1] = macaddy[1];
 591               	.LM50:
 592 0172 8181      		ldd r24,Z+1
 593 0174 8093 0000 		sts MyMAC+1,r24
 143:net_compat.c  **** 	MyMAC[2] = macaddy[2];
 595               	.LM51:
 596 0178 8281      		ldd r24,Z+2
 597 017a 8093 0000 		sts MyMAC+2,r24
 144:net_compat.c  **** 	MyMAC[3] = macaddy[3];
 599               	.LM52:
 600 017e 8381      		ldd r24,Z+3
 601 0180 8093 0000 		sts MyMAC+3,r24
 145:net_compat.c  **** 	MyMAC[4] = macaddy[4];
 603               	.LM53:
 604 0184 8481      		ldd r24,Z+4
 605 0186 8093 0000 		sts MyMAC+4,r24
 146:net_compat.c  **** 	MyMAC[5] = macaddy[5];
 607               	.LM54:
 608 018a 8581      		ldd r24,Z+5
 609 018c 8093 0000 		sts MyMAC+5,r24
 147:net_compat.c  **** 
 148:net_compat.c  **** 	PLLCSR = _BV(PLLE) | _BV( PCKE );
 611               	.LM55:
 612 0190 86E0      		ldi r24,lo8(6)
 613 0192 87BD      		out 0x27,r24
 149:net_compat.c  **** 	PLLCSR |= _BV(LSM);
 615               	.LM56:
 616 0194 87B5      		in r24,0x27
 617 0196 8068      		ori r24,lo8(-128)
 618 0198 87BD      		out 0x27,r24
 150:net_compat.c  **** 	OSCCAL = OSC20;
 620               	.LM57:
 621 019a 8BEB      		ldi r24,lo8(-69)
 622 019c 81BF      		out 0x31,r24
 151:net_compat.c  **** 
 152:net_compat.c  **** 
 153:net_compat.c  **** 	//Setup timer 0 to speed along.
 154:net_compat.c  **** 	//Yes, this means you can't use it.
 155:net_compat.c  **** 	TCCR0A = _BV(WGM01);
 624               	.LM58:
 625 019e 82E0      		ldi r24,lo8(2)
 626 01a0 8ABD      		out 0x2a,r24
 156:net_compat.c  **** 	TCCR0B = _BV(CS00);
 628               	.LM59:
 629 01a2 81E0      		ldi r24,lo8(1)
 630 01a4 83BF      		out 0x33,r24
 157:net_compat.c  **** 	OCR0A = 0;
 632               	.LM60:
GAS LISTING /tmp/ccouZRfQ.s 			page 12


 633 01a6 19BC      		out 0x29,__zero_reg__
 158:net_compat.c  **** 
 159:net_compat.c  **** 	USICR = _BV(USIWM0) | _BV(USICS0) | _BV(USITC);
 635               	.LM61:
 636 01a8 85E1      		ldi r24,lo8(21)
 637 01aa 8DB9      		out 0xd,r24
 160:net_compat.c  **** 
 161:net_compat.c  **** 	//setup port B
 162:net_compat.c  **** 
 163:net_compat.c  **** 	PORTB &= ~_BV(0); 
 639               	.LM62:
 640 01ac C098      		cbi 0x18,0
 164:net_compat.c  **** 	DDRB &= ~_BV(0);
 642               	.LM63:
 643 01ae B898      		cbi 0x17,0
 165:net_compat.c  **** 	PORTB &= ~_BV(1);
 645               	.LM64:
 646 01b0 C198      		cbi 0x18,1
 166:net_compat.c  **** 	USICR &= ~_BV(USIWM0);  //Disable USICR
 648               	.LM65:
 649 01b2 6C98      		cbi 0xd,4
 167:net_compat.c  **** 
 168:net_compat.c  **** 	return 0;
 169:net_compat.c  **** }
 651               	.LM66:
 652 01b4 80E0      		ldi r24,0
 653 01b6 0895      		ret
 655               	.Lscope9:
 657               		.stabd	78,0,0
 661               	.global	et_xmitpacket
 663               	et_xmitpacket:
 664               		.stabd	46,0,0
 170:net_compat.c  **** 
 171:net_compat.c  **** int8_t et_xmitpacket( uint16_t start, uint16_t len )
 172:net_compat.c  **** {
 666               	.LM67:
 667               	.LFBB10:
 668               	/* prologue: function */
 669               	/* frame size = 0 */
 670               	/* stack size = 0 */
 671               	.L__stack_usage = 0
 173:net_compat.c  **** 	//XXX !!! TODO
 174:net_compat.c  **** }
 673               	.LM68:
 674 01b8 0895      		ret
 676               	.Lscope10:
 678               		.stabd	78,0,0
 680               	.global	et_recvpack
 682               	et_recvpack:
 683               		.stabd	46,0,0
 175:net_compat.c  **** 
 176:net_compat.c  **** //This waits for 8ms, sends an autoneg notice, then waits for 8 more ms.
 177:net_compat.c  **** unsigned short et_recvpack()
 178:net_compat.c  **** {
 685               	.LM69:
 686               	.LFBB11:
 687               	/* prologue: function */
GAS LISTING /tmp/ccouZRfQ.s 			page 13


 688               	/* frame size = 0 */
 689               	/* stack size = 0 */
 690               	.L__stack_usage = 0
 179:net_compat.c  **** 
 180:net_compat.c  **** #define LIMITSIZE  sizeof( ETbuffer )/2-30
 181:net_compat.c  **** //#define LIMITSIZE 10
 182:net_compat.c  **** 
 183:net_compat.c  **** 		waitforpacket(&ETbuffer[40], LIMITSIZE, 20000); //wait for 2048 cycles (30MHz/8 = 3.75MHz / 30000
 692               	.LM70:
 693 01ba 40E2      		ldi r20,lo8(32)
 694 01bc 5EE4      		ldi r21,lo8(78)
 695 01be 62E8      		ldi r22,lo8(-126)
 696 01c0 70E0      		ldi r23,0
 697 01c2 80E0      		ldi r24,lo8(ETbuffer+40)
 698 01c4 90E0      		ldi r25,hi8(ETbuffer+40)
 699 01c6 00D0      		rcall waitforpacket
 184:net_compat.c  **** //		_delay_ms(8);
 185:net_compat.c  **** #ifdef SMARTPWR
 186:net_compat.c  **** 		DDRB |= _BV(1);
 187:net_compat.c  **** #endif
 188:net_compat.c  **** 		PORTB|=_BV(1);
 701               	.LM71:
 702 01c8 C19A      		sbi 0x18,1
 189:net_compat.c  **** 		NOOP;
 704               	.LM72:
 705               	/* #APP */
 706               	 ;  189 "net_compat.c" 1
 707 01ca 0000      		nop
 708               	 ;  0 "" 2
 190:net_compat.c  **** 		PORTB &=~_BV(1);
 710               	.LM73:
 711               	/* #NOAPP */
 712 01cc C198      		cbi 0x18,1
 191:net_compat.c  **** #ifdef SMARTPWR
 192:net_compat.c  **** 		DDRB &= ~_BV(1);
 193:net_compat.c  **** #endif
 194:net_compat.c  **** 		waitforpacket(&ETbuffer[40], LIMITSIZE, 20000); //wait for 2048  (30MHz/8 = 3.75MHz / 30000 = 8ms
 714               	.LM74:
 715 01ce 40E2      		ldi r20,lo8(32)
 716 01d0 5EE4      		ldi r21,lo8(78)
 717 01d2 62E8      		ldi r22,lo8(-126)
 718 01d4 70E0      		ldi r23,0
 719 01d6 80E0      		ldi r24,lo8(ETbuffer+40)
 720 01d8 90E0      		ldi r25,hi8(ETbuffer+40)
 721 01da 00D0      		rcall waitforpacket
 195:net_compat.c  **** // 		_delay_ms(8);
 196:net_compat.c  **** 
 197:net_compat.c  **** }
 723               	.LM75:
 724 01dc 0895      		ret
 726               	.Lscope11:
 728               		.stabd	78,0,0
 732               	.global	et_start_checksum
 734               	et_start_checksum:
 735               		.stabd	46,0,0
 198:net_compat.c  **** 
 199:net_compat.c  **** void et_start_checksum( uint16_t start, uint16_t len )
GAS LISTING /tmp/ccouZRfQ.s 			page 14


 200:net_compat.c  **** {
 737               	.LM76:
 738               	.LFBB12:
 739               	/* prologue: function */
 740               	/* frame size = 0 */
 741               	/* stack size = 0 */
 742               	.L__stack_usage = 0
 743 01de 0895      		ret
 745               	.Lscope12:
 747               		.stabd	78,0,0
 754               	.global	et_copy_memory
 756               	et_copy_memory:
 757               		.stabd	46,0,0
 201:net_compat.c  **** //	ETchecksum = uint16_t internet_checksum( &ETbuffer[start], uint16_t len );
 202:net_compat.c  **** 	//XXX !!! TODO
 203:net_compat.c  **** }
 204:net_compat.c  **** 
 205:net_compat.c  **** void et_copy_memory( uint16_t to, uint16_t from, uint16_t length, uint16_t range_start, uint16_t ra
 206:net_compat.c  **** {
 759               	.LM77:
 760               	.LFBB13:
 761               	/* prologue: function */
 762               	/* frame size = 0 */
 763               	/* stack size = 0 */
 764               	.L__stack_usage = 0
 765 01e0 0895      		ret
 767               	.Lscope13:
 769               		.stabd	78,0,0
 770               	.global	ManchesterTable
 771               		.data
 772               		.p2align	4
 775               	ManchesterTable:
 776 0000 AA        		.byte	-86
 777 0001 6A        		.byte	106
 778 0002 9A        		.byte	-102
 779 0003 5A        		.byte	90
 780 0004 A6        		.byte	-90
 781 0005 66        		.byte	102
 782 0006 96        		.byte	-106
 783 0007 56        		.byte	86
 784 0008 A9        		.byte	-87
 785 0009 69        		.byte	105
 786 000a 99        		.byte	-103
 787 000b 59        		.byte	89
 788 000c A5        		.byte	-91
 789 000d 65        		.byte	101
 790 000e 95        		.byte	-107
 791 000f 55        		.byte	85
 792               		.comm	ETchecksum,2,1
 793               		.comm	sendbaseaddress,2,1
 794               		.comm	ETsendplace,2,1
 795               		.comm	ETbuffer,320,1
 796               		.comm	MyMAC,6,1
 803               		.text
 805               	.Letext0:
 806               		.ident	"GCC: (GNU) 4.8.2"
 807               	.global __do_copy_data
GAS LISTING /tmp/ccouZRfQ.s 			page 15


 808               	.global __do_clear_bss
GAS LISTING /tmp/ccouZRfQ.s 			page 16


DEFINED SYMBOLS
                            *ABS*:0000000000000000 net_compat.c
     /tmp/ccouZRfQ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccouZRfQ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccouZRfQ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccouZRfQ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccouZRfQ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccouZRfQ.s:110    .text:0000000000000000 et_push8
                            *COM*:0000000000000002 ETsendplace
                            *COM*:0000000000000140 ETbuffer
     /tmp/ccouZRfQ.s:145    .text:0000000000000020 GotPack
     /tmp/ccouZRfQ.s:171    .text:0000000000000026 waitforpacket
     /tmp/ccouZRfQ.s:316    .text:00000000000000aa et_popblob
     /tmp/ccouZRfQ.s:370    .text:00000000000000d6 et_pushpgmstr
     /tmp/ccouZRfQ.s:424    .text:00000000000000f2 et_pushpgmblob
     /tmp/ccouZRfQ.s:487    .text:0000000000000124 et_pushstr
     /tmp/ccouZRfQ.s:524    .text:000000000000013a et_pushblob
     /tmp/ccouZRfQ.s:576    .text:000000000000016a et_init
                            *COM*:0000000000000006 MyMAC
     /tmp/ccouZRfQ.s:663    .text:00000000000001b8 et_xmitpacket
     /tmp/ccouZRfQ.s:682    .text:00000000000001ba et_recvpack
     /tmp/ccouZRfQ.s:734    .text:00000000000001de et_start_checksum
     /tmp/ccouZRfQ.s:756    .text:00000000000001e0 et_copy_memory
     /tmp/ccouZRfQ.s:775    .data:0000000000000000 ManchesterTable
                            *COM*:0000000000000002 ETchecksum
                            *COM*:0000000000000002 sendbaseaddress

UNDEFINED SYMBOLS
MaybeHaveDataASM
__do_copy_data
__do_clear_bss
