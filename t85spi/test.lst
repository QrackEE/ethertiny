GAS LISTING /tmp/ccCeDQZH.s 			page 1


   1               		.file	"test.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 114               	.global	delay_ms
 116               	delay_ms:
 117               		.stabd	46,0,0
   1:test.c        **** /*
   2:test.c        **** 
   3:test.c        **** 	WARNING: Connecting an AVR to ethernet without magnetics is VERY DANGEROUS.
   4:test.c        **** 	It may cause high voltages to go through the AVR and destroy it in DANGEROUS
   5:test.c        **** 	that may harm personal safety.  Do only at your own risk.
   6:test.c        **** 
   7:test.c        **** */
   8:test.c        **** 
   9:test.c        **** /*
  10:test.c        ****     Copyright (C) 2014 <>< Charles Lohr
  11:test.c        **** 
  12:test.c        **** 
  13:test.c        ****     Permission is hereby granted, free of charge, to any person obtaining a
  14:test.c        **** 	copy of this software and associated documentation files (the "Software"),
  15:test.c        **** 	to deal in the Software without restriction, including without limitation
  16:test.c        **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  17:test.c        **** 	and/or sell copies of the Software, and to permit persons to whom the
  18:test.c        **** 	Software is furnished to do so, subject to the following conditions:
  19:test.c        **** 
  20:test.c        ****     The above copyright notice and this permission notice shall be included
  21:test.c        **** 	in all copies or substantial portions of the Software.
  22:test.c        **** 
  23:test.c        ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  24:test.c        **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  25:test.c        **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  26:test.c        **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  27:test.c        **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  28:test.c        **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  29:test.c        **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  30:test.c        **** */
  31:test.c        **** 
  32:test.c        **** 
  33:test.c        **** #include <avr/io.h>
  34:test.c        **** #include <avr/interrupt.h>
  35:test.c        **** #include <avr/sleep.h>
  36:test.c        **** #include <util/delay.h>
  37:test.c        **** 
  38:test.c        **** #include "net_compat.h"
  39:test.c        **** #include "sendpack.h"
  40:test.c        **** #include "packetmater.h"
  41:test.c        **** #include "hlprocess.h"
  42:test.c        **** 
  43:test.c        **** void delay_ms(uint32_t time) {
 119               	.LM0:
 120               	.LFBB1:
 121 0000 0F93      		push r16
GAS LISTING /tmp/ccCeDQZH.s 			page 2


 122 0002 1F93      		push r17
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 2 */
 126               	.L__stack_usage = 2
  44:test.c        ****   uint32_t i;
  45:test.c        ****   for (i = 0; i < time; i++) {
 128               	.LM1:
 129 0004 00E0      		ldi r16,0
 130 0006 10E0      		ldi r17,0
 131 0008 9801      		movw r18,r16
 132               	.L2:
 134               	.LM2:
 135 000a 0617      		cp r16,r22
 136 000c 1707      		cpc r17,r23
 137 000e 2807      		cpc r18,r24
 138 0010 3907      		cpc r19,r25
 139 0012 01F0      		breq .L5
 140               	.LBB4:
 141               	.LBB5:
 143               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
GAS LISTING /tmp/ccCeDQZH.s 			page 3


  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/ccCeDQZH.s 			page 4


  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
GAS LISTING /tmp/ccCeDQZH.s 			page 5


 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 145               	.LM3:
 146 0014 E7E8      		ldi r30,lo8(4999)
 147 0016 F3E1      		ldi r31,hi8(4999)
 148 0018 3197      		1: sbiw r30,1
 149 001a 01F4      		brne 1b
 150 001c 00C0      		rjmp .
 151 001e 0000      		nop
 152               	.LBE5:
 153               	.LBE4:
 155               	.Ltext2:
 157               	.LM4:
 158 0020 0F5F      		subi r16,-1
 159 0022 1F4F      		sbci r17,-1
 160 0024 2F4F      		sbci r18,-1
 161 0026 3F4F      		sbci r19,-1
 162 0028 00C0      		rjmp .L2
 163               	.L5:
 164               	/* epilogue start */
  46:test.c        ****     _delay_ms(1);
  47:test.c        ****   }
  48:test.c        **** }
 166               	.LM5:
 167 002a 1F91      		pop r17
 168 002c 0F91      		pop r16
 169 002e 0895      		ret
 174               	.Lscope1:
 176               		.stabd	78,0,0
 177               		.section	.text.startup,"ax",@progbits
 179               	.global	main
 181               	main:
 182               		.stabd	46,0,0
  49:test.c        **** 
  50:test.c        **** #define NOOP asm volatile("nop" ::)
  51:test.c        **** 
  52:test.c        **** static void setup_clock( void )
  53:test.c        **** {
  54:test.c        **** 	/*Examine Page 33*/
  55:test.c        **** 
  56:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
  57:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
  58:test.c        **** 
  59:test.c        **** 
  60:test.c        **** }
GAS LISTING /tmp/ccCeDQZH.s 			page 6


  61:test.c        **** 
  62:test.c        **** //#define SMARTPWR
  63:test.c        **** 
  64:test.c        **** 
  65:test.c        **** //unsigned char ETbuffer[390];
  66:test.c        **** 
  67:test.c        **** void SendTestASM( const unsigned char * c, uint8_t len );
  68:test.c        **** int MaybeHaveDataASM( unsigned char * c, uint8_t lenX2 ); //returns the number of pairs.
  69:test.c        **** 
  70:test.c        **** 
  71:test.c        **** 
  72:test.c        **** int main( )
  73:test.c        **** {
 184               	.LM6:
 185               	.LFBB2:
 186               	/* prologue: function */
 187               	/* frame size = 0 */
 188               	/* stack size = 0 */
 189               	.L__stack_usage = 0
  74:test.c        **** 	int i;
  75:test.c        **** 	cli();
 191               	.LM7:
 192               	/* #APP */
 193               	 ;  75 "test.c" 1
 194 0000 F894      		cli
 195               	 ;  0 "" 2
 196               	/* #NOAPP */
 197               	.LBB10:
 198               	.LBB11:
  56:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
 200               	.LM8:
 201 0002 80E8      		ldi r24,lo8(-128)
 202 0004 86BD      		out 0x26,r24
  57:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
 204               	.LM9:
 205 0006 16BC      		out 0x26,__zero_reg__
 206               	.LBE11:
 207               	.LBE10:
  76:test.c        **** 
  77:test.c        **** 	setup_clock();
  78:test.c        **** 
  79:test.c        **** 	DDRB = _BV(1);
 209               	.LM10:
 210 0008 82E0      		ldi r24,lo8(2)
 211 000a 87BB      		out 0x17,r24
  80:test.c        **** 
  81:test.c        **** 	//1st let's see how fast we can clock the pin.
  82:test.c        **** 	et_init( MyMAC );
 213               	.LM11:
 214 000c 80E0      		ldi r24,lo8(MyMAC)
 215 000e 90E0      		ldi r25,hi8(MyMAC)
 216 0010 00D0      		rcall et_init
 217 0012 80E0      		ldi r24,lo8(PacketA)
 218 0014 90E0      		ldi r25,hi8(PacketA)
 219 0016 A0E0      		ldi r26,lo8(ETbuffer)
 220 0018 B0E0      		ldi r27,hi8(ETbuffer)
 221               	.L8:
GAS LISTING /tmp/ccCeDQZH.s 			page 7


 222               	.LBB12:
  83:test.c        **** 
  84:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
  85:test.c        **** 	{
  86:test.c        **** 		ETbuffer[i] = pgm_read_word( &PacketA[i] );
 224               	.LM12:
 225 001a FC01      		movw r30,r24
 226               	/* #APP */
 227               	 ;  86 "test.c" 1
 228 001c 2591      		lpm r18, Z+
 229 001e 3491      		lpm r19, Z
 230               		
 231               	 ;  0 "" 2
 232               	/* #NOAPP */
 233               	.LBE12:
 234 0020 2D93      		st X+,r18
 235 0022 0196      		adiw r24,1
  84:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
 237               	.LM13:
 238 0024 20E0      		ldi r18,hi8(PacketA+76)
 239 0026 8030      		cpi r24,lo8(PacketA+76)
 240 0028 9207      		cpc r25,r18
 241 002a 01F4      		brne .L8
 242               	.LBB13:
  87:test.c        **** 	}
  88:test.c        **** 
  89:test.c        **** 	i = 0;
  90:test.c        **** 
  91:test.c        **** 	int frame = 0;
  92:test.c        **** 
  93:test.c        **** 	struct EthernetPacket * sbe = (struct EthernetPacket*)ETbuffer;
  94:test.c        **** 
  95:test.c        **** 	while(1)
  96:test.c        **** 	{
  97:test.c        **** 	//	SendTestASM( ETbuffer, PacketABytes/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
  98:test.c        **** 	//	continue;
  99:test.c        **** 		et_recvpack();
 100:test.c        **** 
 101:test.c        **** 		i++;
 102:test.c        **** 
 103:test.c        **** 		if( i == 20 )
 104:test.c        **** 		{
 105:test.c        **** #ifdef SMARTPWR
 106:test.c        **** 			DDRB |= _BV(1);
 107:test.c        **** #endif
 108:test.c        **** 
 109:test.c        **** 			//UDP Data starts at byte #50
 110:test.c        **** 			struct EthernetPacket * sbe = (struct EthernetPacket*)ETbuffer;
 111:test.c        **** //			sbe->payload[0] = 0xBB;
 112:test.c        **** //			sbe->payload[1] = frame++;
 113:test.c        **** 			sbe->addyfrom = 0x450a000a;
 244               	.LM14:
 245 002c 9AE0      		ldi r25,lo8(10)
 246 002e C92E      		mov r12,r25
 247 0030 D12C      		mov r13,__zero_reg__
 248 0032 EC2C      		mov r14,r12
 249 0034 95E4      		ldi r25,lo8(69)
GAS LISTING /tmp/ccCeDQZH.s 			page 8


 250 0036 F92E      		mov r15,r25
 251               	.L12:
 252               	.LBE13:
  73:test.c        **** {
 254               	.LM15:
 255 0038 C4E1      		ldi r28,lo8(20)
 256 003a D0E0      		ldi r29,0
 257               	.L10:
  99:test.c        **** 		et_recvpack();
 259               	.LM16:
 260 003c 00D0      		rcall et_recvpack
 261 003e 2197      		sbiw r28,1
 103:test.c        **** 		if( i == 20 )
 263               	.LM17:
 264 0040 2097      		sbiw r28,0
 265 0042 01F4      		brne .L10
 266               	.LBB14:
 268               	.LM18:
 269 0044 C092 0000 		sts ETbuffer+34,r12
 270 0048 D092 0000 		sts ETbuffer+34+1,r13
 271 004c E092 0000 		sts ETbuffer+34+2,r14
 272 0050 F092 0000 		sts ETbuffer+34+3,r15
 114:test.c        **** 			int rr = Ethernetize( ETbuffer, PacketABytes, 320);
 274               	.LM19:
 275 0054 40E4      		ldi r20,lo8(64)
 276 0056 51E0      		ldi r21,lo8(1)
 277 0058 6CE4      		ldi r22,lo8(76)
 278 005a 70E0      		ldi r23,0
 279 005c 80E0      		ldi r24,lo8(ETbuffer)
 280 005e 90E0      		ldi r25,hi8(ETbuffer)
 281 0060 00D0      		rcall Ethernetize
 115:test.c        **** 
 116:test.c        **** 			SendTestASM( ETbuffer, rr/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
 283               	.LM20:
 284 0062 97FD      		sbrc r25,7
 285 0064 0396      		adiw r24,3
 286               	.L11:
 287 0066 BC01      		movw r22,r24
 288 0068 7595      		asr r23
 289 006a 6795      		ror r22
 290 006c 7595      		asr r23
 291 006e 6795      		ror r22
 292 0070 6D5F      		subi r22,lo8(-(3))
 293 0072 80E0      		ldi r24,lo8(ETbuffer)
 294 0074 90E0      		ldi r25,hi8(ETbuffer)
 295 0076 00D0      		rcall SendTestASM
 296 0078 00C0      		rjmp .L12
 297               	.LBE14:
 299               	.Lscope2:
 301               		.stabd	78,0,0
 302               		.text
 304               	.Letext0:
 305               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccCeDQZH.s 			page 9


DEFINED SYMBOLS
                            *ABS*:0000000000000000 test.c
     /tmp/ccCeDQZH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccCeDQZH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccCeDQZH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccCeDQZH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccCeDQZH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccCeDQZH.s:116    .text:0000000000000000 delay_ms
     /tmp/ccCeDQZH.s:181    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
MyMAC
et_init
PacketA
ETbuffer
et_recvpack
Ethernetize
SendTestASM
GAS LISTING /tmp/ccCeDQZH.s 			page 1


   1               	# 1 "asmtest.S"
   1               	/*
   1               	...
   0               	
   2               	    Copyright (C) 2014 <>< Charles Lohr
   3               	
   4               	
   5               	    Permission is hereby granted, free of charge, to any person obtaining a
   6               		copy of this software and associated documentation files (the "Software"),
   7               		to deal in the Software without restriction, including without limitation
   8               		the rights to use, copy, modify, merge, publish, distribute, sublicense,
   9               		and/or sell copies of the Software, and to permit persons to whom the
  10               		Software is furnished to do so, subject to the following conditions:
  11               	
  12               	    The above copyright notice and this permission notice shall be included
  13               		in all copies or substantial portions of the Software.
  14               	
  15               	    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  16               		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  17               		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  18               		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  19               		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  20               		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  21               		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  22               	*/
  23               	
  24               	
  25               	
  26               	#define _SFR_ASM_COMPAT 1
  27               	#define __SFR_OFFSET 0
  28               	
  29               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
GAS LISTING /tmp/ccCeDQZH.s 			page 2


  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h 2211 2011-02-14 14:04:25Z aboyapati $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
GAS LISTING /tmp/ccCeDQZH.s 			page 3


  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
GAS LISTING /tmp/ccCeDQZH.s 			page 4


 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
GAS LISTING /tmp/ccCeDQZH.s 			page 5


 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__) || defined (__AVR_ATmega325A__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__) || defined (__AVR_ATmega3250A__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__) || defined (__AVR_ATmega329A__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__) || defined (__AVR_ATmega3290A__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega32HVBREVB__)
 234               	#  include <avr/iom32hvbrevb.h>
 235               	#elif defined (__AVR_ATmega406__)
 236               	#  include <avr/iom406.h>
 237               	#elif defined (__AVR_ATmega16__)
 238               	#  include <avr/iom16.h>
 239               	#elif defined (__AVR_ATmega16A__)
 240               	#  include <avr/iom16a.h>
 241               	#elif defined (__AVR_ATmega161__)
 242               	#  include <avr/iom161.h>
 243               	#elif defined (__AVR_ATmega162__)
 244               	#  include <avr/iom162.h>
 245               	#elif defined (__AVR_ATmega163__)
 246               	#  include <avr/iom163.h>
 247               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 248               	#  include <avr/iom164.h>
 249               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 250               	#  include <avr/iom165.h>
 251               	#elif defined (__AVR_ATmega165P__)
 252               	#  include <avr/iom165p.h>
GAS LISTING /tmp/ccCeDQZH.s 			page 6


 253               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 254               	#  include <avr/iom168.h>
 255               	#elif defined (__AVR_ATmega168P__)
 256               	#  include <avr/iom168p.h>
 257               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 258               	#  include <avr/iom169.h>
 259               	#elif defined (__AVR_ATmega169P__)
 260               	#  include <avr/iom169p.h>
 261               	#elif defined (__AVR_ATmega169PA__)
 262               	#  include <avr/iom169pa.h>
 263               	#elif defined (__AVR_ATmega8HVA__)
 264               	#  include <avr/iom8hva.h>
 265               	#elif defined (__AVR_ATmega16HVA__)
 266               	#  include <avr/iom16hva.h>
 267               	#elif defined (__AVR_ATmega16HVA2__)
 268               	#  include <avr/iom16hva2.h>
 269               	#elif defined (__AVR_ATmega16HVB__)
 270               	#  include <avr/iom16hvb.h>
 271               	#elif defined (__AVR_ATmega16HVBREVB__)
 272               	#  include <avr/iom16hvbrevb.h>
 273               	#elif defined (__AVR_ATmega8__)
 274               	#  include <avr/iom8.h>
 275               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 276               	#  include <avr/iom48.h>
 277               	#elif defined (__AVR_ATmega48P__)
 278               	#  include <avr/iom48p.h>
 279               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 280               	#  include <avr/iom88.h>
 281               	#elif defined (__AVR_ATmega88P__)
 282               	#  include <avr/iom88p.h>
 283               	#elif defined (__AVR_ATmega88PA__)
 284               	#  include <avr/iom88pa.h>
 285               	#elif defined (__AVR_ATmega8515__)
 286               	#  include <avr/iom8515.h>
 287               	#elif defined (__AVR_ATmega8535__)
 288               	#  include <avr/iom8535.h>
 289               	#elif defined (__AVR_AT90S8535__)
 290               	#  include <avr/io8535.h>
 291               	#elif defined (__AVR_AT90C8534__)
 292               	#  include <avr/io8534.h>
 293               	#elif defined (__AVR_AT90S8515__)
 294               	#  include <avr/io8515.h>
 295               	#elif defined (__AVR_AT90S4434__)
 296               	#  include <avr/io4434.h>
 297               	#elif defined (__AVR_AT90S4433__)
 298               	#  include <avr/io4433.h>
 299               	#elif defined (__AVR_AT90S4414__)
 300               	#  include <avr/io4414.h>
 301               	#elif defined (__AVR_ATtiny22__)
 302               	#  include <avr/iotn22.h>
 303               	#elif defined (__AVR_ATtiny26__)
 304               	#  include <avr/iotn26.h>
 305               	#elif defined (__AVR_AT90S2343__)
 306               	#  include <avr/io2343.h>
 307               	#elif defined (__AVR_AT90S2333__)
 308               	#  include <avr/io2333.h>
 309               	#elif defined (__AVR_AT90S2323__)
GAS LISTING /tmp/ccCeDQZH.s 			page 7


 310               	#  include <avr/io2323.h>
 311               	#elif defined (__AVR_AT90S2313__)
 312               	#  include <avr/io2313.h>
 313               	#elif defined (__AVR_ATtiny4__)
 314               	#  include <avr/iotn4.h>
 315               	#elif defined (__AVR_ATtiny5__)
 316               	#  include <avr/iotn5.h>
 317               	#elif defined (__AVR_ATtiny9__)
 318               	#  include <avr/iotn9.h>
 319               	#elif defined (__AVR_ATtiny10__)
 320               	#  include <avr/iotn10.h>
 321               	#elif defined (__AVR_ATtiny20__)
 322               	#  include <avr/iotn20.h>
 323               	#elif defined (__AVR_ATtiny40__)
 324               	#  include <avr/iotn40.h>
 325               	#elif defined (__AVR_ATtiny2313__)
 326               	#  include <avr/iotn2313.h>
 327               	#elif defined (__AVR_ATtiny2313A__)
 328               	#  include <avr/iotn2313a.h>
 329               	#elif defined (__AVR_ATtiny13__)
 330               	#  include <avr/iotn13.h>
 331               	#elif defined (__AVR_ATtiny13A__)
 332               	#  include <avr/iotn13a.h>
 333               	#elif defined (__AVR_ATtiny25__)
 334               	#  include <avr/iotn25.h>
 335               	#elif defined (__AVR_ATtiny4313__)
 336               	#  include <avr/iotn4313.h>
 337               	#elif defined (__AVR_ATtiny45__)
 338               	#  include <avr/iotn45.h>
 339               	#elif defined (__AVR_ATtiny85__)
 340               	#  include <avr/iotn85.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
GAS LISTING /tmp/ccCeDQZH.s 			page 8


  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iotn85.h 2115 2010-04-05 23:19:53Z arcanum $ */
  32               	
  33               	/* avr/iotn85.h - definitions for ATtiny85 */
  34               	
  35               	#ifndef _AVR_IOTN85_H_
  36               	#define _AVR_IOTN85_H_ 1
  37               	
  38               	#include <avr/iotnx5.h>
   1               	/* Copyright (c) 2005,2007 Anatoly Sokolov
  39               	
 341               	#elif defined (__AVR_ATtiny24__)
 342               	#  include <avr/iotn24.h>
 343               	#elif defined (__AVR_ATtiny24A__)
 344               	#  include <avr/iotn24a.h>
 345               	#elif defined (__AVR_ATtiny44__)
 346               	#  include <avr/iotn44.h>
 347               	#elif defined (__AVR_ATtiny44A__)
 348               	#  include <avr/iotn44a.h>
 349               	#elif defined (__AVR_ATtiny84__)
 350               	#  include <avr/iotn84.h>
 351               	#elif defined (__AVR_ATtiny84A__)
 352               	#  include <avr/iotn84a.h>  
 353               	#elif defined (__AVR_ATtiny261__)
 354               	#  include <avr/iotn261.h>
 355               	#elif defined (__AVR_ATtiny261A__)
 356               	#  include <avr/iotn261a.h>
 357               	#elif defined (__AVR_ATtiny461__)
 358               	#  include <avr/iotn461.h>
 359               	#elif defined (__AVR_ATtiny461A__)
 360               	#  include <avr/iotn461a.h>
 361               	#elif defined (__AVR_ATtiny861__)
 362               	#  include <avr/iotn861.h>
 363               	#elif defined (__AVR_ATtiny861A__)
 364               	#  include <avr/iotn861a.h>
 365               	#elif defined (__AVR_ATtiny43U__)
 366               	#  include <avr/iotn43u.h>
 367               	#elif defined (__AVR_ATtiny48__)
 368               	#  include <avr/iotn48.h>
 369               	#elif defined (__AVR_ATtiny88__)
 370               	#  include <avr/iotn88.h>
 371               	#elif defined (__AVR_ATtiny87__)
 372               	#  include <avr/iotn87.h>
 373               	#elif defined (__AVR_ATtiny167__)
 374               	#  include <avr/iotn167.h>
 375               	#elif defined (__AVR_AT90SCR100__)
 376               	#  include <avr/io90scr100.h>
 377               	#elif defined (__AVR_ATxmega16A4__)
 378               	#  include <avr/iox16a4.h>
 379               	#elif defined (__AVR_ATxmega16D4__)
 380               	#  include <avr/iox16d4.h>
 381               	#elif defined (__AVR_ATxmega32A4__)
 382               	#  include <avr/iox32a4.h>
 383               	#elif defined (__AVR_ATxmega32D4__)
GAS LISTING /tmp/ccCeDQZH.s 			page 9


 384               	#  include <avr/iox32d4.h>
 385               	#elif defined (__AVR_ATxmega64A1__)
 386               	#  include <avr/iox64a1.h>
 387               	#elif defined (__AVR_ATxmega64A1U__)
 388               	#  include <avr/iox64a1u.h>
 389               	#elif defined (__AVR_ATxmega64A3__)
 390               	#  include <avr/iox64a3.h>
 391               	#elif defined (__AVR_ATxmega64D3__)
 392               	#  include <avr/iox64d3.h>
 393               	#elif defined (__AVR_ATxmega128A1__)
 394               	#  include <avr/iox128a1.h>
 395               	#elif defined (__AVR_ATxmega128A1U__)
 396               	#  include <avr/iox128a1u.h>
 397               	#elif defined (__AVR_ATxmega128A3__)
 398               	#  include <avr/iox128a3.h>
 399               	#elif defined (__AVR_ATxmega128D3__)
 400               	#  include <avr/iox128d3.h>
 401               	#elif defined (__AVR_ATxmega192A3__)
 402               	#  include <avr/iox192a3.h>
 403               	#elif defined (__AVR_ATxmega192D3__)
 404               	#  include <avr/iox192d3.h>
 405               	#elif defined (__AVR_ATxmega256A3__)
 406               	#  include <avr/iox256a3.h>
 407               	#elif defined (__AVR_ATxmega256A3B__)
 408               	#  include <avr/iox256a3b.h>
 409               	#elif defined (__AVR_ATxmega256D3__)
 410               	#  include <avr/iox256d3.h>
 411               	#elif defined (__AVR_ATA6289__)
 412               	#  include <avr/ioa6289.h>
 413               	/* avr1: the following only supported for assembler programs */
 414               	#elif defined (__AVR_ATtiny28__)
 415               	#  include <avr/iotn28.h>
 416               	#elif defined (__AVR_AT90S1200__)
 417               	#  include <avr/io1200.h>
 418               	#elif defined (__AVR_ATtiny15__)
 419               	#  include <avr/iotn15.h>
 420               	#elif defined (__AVR_ATtiny12__)
 421               	#  include <avr/iotn12.h>
 422               	#elif defined (__AVR_ATtiny11__)
 423               	#  include <avr/iotn11.h>
 424               	#elif defined (__AVR_M3000__)
 425               	#  include <avr/iom3000.h>
 426               	#else
 427               	#  if !defined(__COMPILING_AVR_LIBC__)
 428               	#    warning "device type not defined"
 429               	#  endif
 430               	#endif
 431               	
 432               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 433               	
 434               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 435               	
 436               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 437               	
GAS LISTING /tmp/ccCeDQZH.s 			page 10


 438               	/* Include fuse.h after individual IO header files. */
 439               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 440               	
 441               	/* Include lock.h after individual IO header files. */
 442               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 443               	
  30               	
  31               	#define USEBR  USIDR
  32               	.global SendTick
  33               	SendTick:
  34:asmtest.S     **** 	ori r18, 0b00010101
  35:asmtest.S     **** 	ori r19, 0b00001101
  36:asmtest.S     **** 	ori r20, 0b00000101
  37:asmtest.S     **** 	out PORTB, r19
  38:asmtest.S     **** 	out PORTB, r19
  39:asmtest.S     **** 	out PORTB, r18
  40:asmtest.S     **** 	out PORTB, r18
  41:asmtest.S     **** 	out PORTB, r20
  42:asmtest.S     **** 	ret
  43               	
  44               	.global SendTestASM  // ( unsigned char * ptr_to_packet, uint8_t packet_length_longs ); (longs = pa
  45               	SendTestASM:
  46:asmtest.S     **** 	push r16
  47:asmtest.S     **** 	push r18
  48:asmtest.S     **** 	push r19
  49:asmtest.S     **** 	push r20
  50:asmtest.S     **** 	ldi r27,0
  51:asmtest.S     **** 	ldi r26,0
  52:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable))
  53:asmtest.S     **** 	sbci r27,hi8(-(ManchesterTable))
  54               	//	mov r17, r26 // For backup
  55               		  //Manchester table now in X.
  56               	
  57               		//Move "Packet to send" into Z (R30, 31)
  58:asmtest.S     **** 	movw r30,r24
  59               	//	add r22,r24
  60               	//	adc r23,r25
  61               	
  62               		//r22 = how big to send.
  63               		
  64:asmtest.S     **** 	mov r16, r22
  65:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
  66:asmtest.S     **** 	mov r26, r18   //1  R26 = To be read Manchester lookup
  67:asmtest.S     **** 	andi r26, 0x0f //1
  68:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  69               	SendLoop:
  70:asmtest.S     **** 	tst r16
  71:asmtest.S     **** 	breq Done
  72               	
  73               		//Enable the USI
  74:asmtest.S     **** 	SBI USICR, USIWM0
  75               	
  76               	KeepGoing:			///subi r26,lo8(-(ManchesterTable))
  77               	
  78               		//Heavily interleved code.  Need a new OUTB every 8 cycles exactly.
GAS LISTING /tmp/ccCeDQZH.s 			page 11


  79:asmtest.S     ****     nop           //1 //Look, ma ONE EXTRA CYCLE!
  80               		//nop
  81               	
  82:asmtest.S     **** 	ld r19, X      //2
  83:asmtest.S     **** 	swap r18       //1
  84:asmtest.S     **** 	out USEBR, r19 //1  START HERE
  85:asmtest.S     **** 	mov r26, r18   //1
  86:asmtest.S     **** 	andi r26, 0x0f //1
  87:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  88:asmtest.S     **** 	ld r19, X      //2
  89:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
  90:asmtest.S     **** 	out USEBR, r19 //1 ** OK
  91:asmtest.S     **** 	mov r26, r18   //1
  92               	
  93               	
  94:asmtest.S     **** 	andi r26, 0x0f //1
  95:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  96:asmtest.S     **** 	ld r19, X      //2
  97:asmtest.S     **** 	swap r18       //1
  98:asmtest.S     **** 	mov r26, r18   //1
  99:asmtest.S     **** 	out USEBR, r19 //1  ** OK
 100:asmtest.S     **** 	andi r26, 0x0f //1
 101:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 102:asmtest.S     **** 	ld r19, X      //2
 103:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 104:asmtest.S     **** 	mov r26, r18   //1
 105:asmtest.S     **** 	out USEBR, r19 //1  **OK
 106               	
 107               	
 108:asmtest.S     **** 	andi r26, 0x0f //1
 109:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 110:asmtest.S     **** 	ld r19, X      //2
 111:asmtest.S     **** 	swap r18       //1
 112:asmtest.S     **** 	mov r26, r18   //1
 113:asmtest.S     **** 	andi r26, 0x0f //1
 114:asmtest.S     **** 	out USEBR, r19 //1  ** OK 
 115:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 116:asmtest.S     **** 	ld r19, X      //2
 117:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 118:asmtest.S     **** 	mov r26, r18   //1
 119:asmtest.S     **** 	andi r26, 0x0f //1
 120:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 121:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 122:asmtest.S     **** 	ld r19, X      //2
 123:asmtest.S     **** 	swap r18       //1
 124:asmtest.S     **** 	mov r26, r18   //1
 125:asmtest.S     **** 	andi r26, 0x0f //1
 126:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 127:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 128:asmtest.S     **** 	ld r19, X      //2
 129:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 130:asmtest.S     **** 	mov r26, r18   //1
 131:asmtest.S     **** 	andi r26, 0x0f //1
 132:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 133:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 134               	
 135:asmtest.S     **** 	dec r16         //1
GAS LISTING /tmp/ccCeDQZH.s 			page 12


 136:asmtest.S     **** 	brne KeepGoing  //2
 137               	Done:
 138:asmtest.S     **** 	nop
 139:asmtest.S     **** 	nop
 140:asmtest.S     **** 	nop
 141:asmtest.S     **** 	nop
 142:asmtest.S     **** 	andi r19,0
 143:asmtest.S     **** 	nop
 144:asmtest.S     **** 	out USEBR,r19 
 145:asmtest.S     **** 	CBI USICR, USIWM0
 146               	
 147:asmtest.S     **** 	pop r20
 148:asmtest.S     **** 	pop r19
 149:asmtest.S     **** 	pop r18
 150:asmtest.S     **** 	mov r24, r16
 151:asmtest.S     **** 	pop r16
 152:asmtest.S     **** 	ret
 153               	
 154               	
 155               	#define USEBRR  USIDR
 156               	//#define USEBRR  ADCL
 157               	
 158               	.global MaybeHaveDataASM
 159               	MaybeHaveDataASM:
 160               	
 161:asmtest.S     **** 	push r16
 162:asmtest.S     **** 	push r22
 163:asmtest.S     **** 	push r18
 164:asmtest.S     **** 	push r19
 165:asmtest.S     **** 	push r20
 166               	
 167               						//r22 = words in buffer.
 168:asmtest.S     **** 	movw r30,r24    //r24:r25 = pointer to staging ram.
 169               	
 170               		//In here, we're operating at 30 ~MHz (hopefully)
 171               		//We want to peel the data off the SPI bus as fast as possible!
 172               	
 173:asmtest.S     **** 	tst r22
 174:asmtest.S     **** 	breq rlend
 175               	rloop:
 176               	
 177               	///XXX TODO: Scrutenize the "breq" 
 178:asmtest.S     **** 	in r19,USEBRR  //1  ****
 179:asmtest.S     **** 	inc r19			//1
 180:asmtest.S     ****     breq rlend    //2???
 181:asmtest.S     ****     nop           //1????
 182:asmtest.S     **** 	dec r19		//1
 183:asmtest.S     **** 	breq rlend  //2????
 184:asmtest.S     **** 	nop         //1
 185:asmtest.S     **** 	nop         //1
 186               	
 187:asmtest.S     **** 	in r18,USEBRR  //1  ****
 188:asmtest.S     **** 	st Z+, r19    //2
 189:asmtest.S     **** 	st Z+, r18    //2
 190:asmtest.S     **** 	dec r22       //1
 191:asmtest.S     **** 	brne rloop    //2
 192               	
GAS LISTING /tmp/ccCeDQZH.s 			page 13


 193               	rlend:
 194:asmtest.S     **** 	mov r24,r22
 195:asmtest.S     **** 	pop r20
 196:asmtest.S     **** 	pop r19
 197:asmtest.S     **** 	pop r18
 198:asmtest.S     **** 	pop r22
 199:asmtest.S     **** 	pop r16
 200:asmtest.S     **** 	ret
GAS LISTING /tmp/ccCeDQZH.s 			page 14


DEFINED SYMBOLS
           asmtest.S:33     .text:0000000000000000 SendTick
           asmtest.S:45     .text:0000000000000012 SendTestASM
           asmtest.S:69     .text:000000000000002e SendLoop
           asmtest.S:137    .text:000000000000009a Done
           asmtest.S:76     .text:0000000000000034 KeepGoing
           asmtest.S:159    .text:00000000000000b6 MaybeHaveDataASM
           asmtest.S:193    .text:00000000000000e0 rlend
           asmtest.S:175    .text:00000000000000c6 rloop

UNDEFINED SYMBOLS
ManchesterTable
GAS LISTING /tmp/ccCeDQZH.s 			page 1


   1               		.file	"sendpack.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 107               	.global	PacketA
 108               		.section	.progmem.data,"a",@progbits
 111               	PacketA:
 112 0000 55        		.byte	85
 113 0001 55        		.byte	85
 114 0002 55        		.byte	85
 115 0003 55        		.byte	85
 116 0004 55        		.byte	85
 117 0005 55        		.byte	85
 118 0006 55        		.byte	85
 119 0007 D5        		.byte	-43
 120 0008 FF        		.byte	-1
 121 0009 FF        		.byte	-1
 122 000a FF        		.byte	-1
 123 000b FF        		.byte	-1
 124 000c FF        		.byte	-1
 125 000d FF        		.byte	-1
 126 000e 00        		.byte	0
 127 000f 55        		.byte	85
 128 0010 00        		.byte	0
 129 0011 55        		.byte	85
 130 0012 00        		.byte	0
 131 0013 55        		.byte	85
 132 0014 08        		.byte	8
 133 0015 00        		.byte	0
 134 0016 45        		.byte	69
 135 0017 00        		.byte	0
 136 0018 00        		.byte	0
 137 0019 32        		.byte	50
 138 001a B3        		.byte	-77
 139 001b 1E        		.byte	30
 140 001c 00        		.byte	0
 141 001d 00        		.byte	0
 142 001e 80        		.byte	-128
 143 001f 11        		.byte	17
 144 0020 C6        		.byte	-58
 145 0021 8D        		.byte	-115
 146 0022 C0        		.byte	-64
 147 0023 A8        		.byte	-88
 148 0024 00        		.byte	0
 149 0025 67        		.byte	103
 150 0026 FF        		.byte	-1
 151 0027 FF        		.byte	-1
 152 0028 FF        		.byte	-1
 153 0029 FF        		.byte	-1
 154 002a 04        		.byte	4
 155 002b 00        		.byte	0
 156 002c 34        		.byte	52
 157 002d 00        		.byte	0
GAS LISTING /tmp/ccCeDQZH.s 			page 2


 158 002e 00        		.byte	0
 159 002f 1E        		.byte	30
 160 0030 18        		.byte	24
 161 0031 EE        		.byte	-18
 162 0032 43        		.byte	67
 163 0033 0A        		.byte	10
 164 0034 AA        		.byte	-86
 165 0035 AA        		.byte	-86
 166 0036 AA        		.byte	-86
 167 0037 AA        		.byte	-86
 168 0038 AA        		.byte	-86
 169 0039 AA        		.byte	-86
 170 003a AA        		.byte	-86
 171 003b AA        		.byte	-86
 172 003c AA        		.byte	-86
 173 003d AA        		.byte	-86
 174 003e AA        		.byte	-86
 175 003f AA        		.byte	-86
 176 0040 AA        		.byte	-86
 177 0041 AA        		.byte	-86
 178 0042 AA        		.byte	-86
 179 0043 AA        		.byte	-86
 180 0044 AA        		.byte	-86
 181 0045 AA        		.byte	-86
 182 0046 AA        		.byte	-86
 183 0047 AA        		.byte	-86
 184 0048 5D        		.byte	93
 185 0049 FA        		.byte	-6
 186 004a B6        		.byte	-74
 187 004b 1A        		.byte	26
 189               		.text
 191               	.Letext0:
 192               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccCeDQZH.s 			page 3


DEFINED SYMBOLS
                            *ABS*:0000000000000000 sendpack.c
     /tmp/ccCeDQZH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccCeDQZH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccCeDQZH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccCeDQZH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccCeDQZH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccCeDQZH.s:111    .progmem.data:0000000000000000 PacketA

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccCeDQZH.s 			page 1


   1               		.file	"packetmater.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  98               	.global	crc32b
 100               	crc32b:
 101               		.stabd	46,0,0
   1:packetmater.c **** //Packet mater.  A super tiny file that helps with checksums and ethernet CRCs.
   2:packetmater.c **** //CRC Was taken from linked page.
   3:packetmater.c **** 
   4:packetmater.c **** /*
   5:packetmater.c ****     Copyright (C) 2014 <>< Charles Lohr
   6:packetmater.c **** 
   7:packetmater.c **** 
   8:packetmater.c ****     Permission is hereby granted, free of charge, to any person obtaining a
   9:packetmater.c **** 	copy of this software and associated documentation files (the "Software"),
  10:packetmater.c **** 	to deal in the Software without restriction, including without limitation
  11:packetmater.c **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  12:packetmater.c **** 	and/or sell copies of the Software, and to permit persons to whom the
  13:packetmater.c **** 	Software is furnished to do so, subject to the following conditions:
  14:packetmater.c **** 
  15:packetmater.c ****     The above copyright notice and this permission notice shall be included
  16:packetmater.c **** 	in all copies or substantial portions of the Software.
  17:packetmater.c **** 
  18:packetmater.c ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  19:packetmater.c **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  20:packetmater.c **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  21:packetmater.c **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  22:packetmater.c **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  23:packetmater.c **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  24:packetmater.c **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  25:packetmater.c **** */
  26:packetmater.c **** #include "packetmater.h"
  27:packetmater.c **** 
  28:packetmater.c **** //Fix all checksums for UDP packets and add etherlink CRC.
  29:packetmater.c **** uint16_t Ethernetize( unsigned char * packet, int plen, int udplenoverride )
  30:packetmater.c **** {
  31:packetmater.c **** 	plen -= 12;
  32:packetmater.c **** 	packet += 8; //User must provide preamble.
  33:packetmater.c **** 
  34:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
  35:packetmater.c **** 		plen = (udplenoverride+8) + 34;
  36:packetmater.c **** 
  37:packetmater.c **** 	//Need to buffer to 4-byte boundaries.
  38:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
  39:packetmater.c **** 
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
  41:packetmater.c **** 	{
  42:packetmater.c **** 		uint16_t fullpacklen = plen-14;
  43:packetmater.c **** 		packet[16] = fullpacklen>>8;
  44:packetmater.c **** 		packet[17] = fullpacklen&0xff;
  45:packetmater.c **** 		packet[24] = 0;
  46:packetmater.c **** 		packet[25] = 0;
GAS LISTING /tmp/ccCeDQZH.s 			page 2


  47:packetmater.c **** 		uint16_t csumr;
  48:packetmater.c **** //		fprintf( stderr, "Header checksum: 0x%04x\n", csumr = csrange(14,20) );
  49:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
  50:packetmater.c **** 
  51:packetmater.c **** 		packet[24] = csumr>>8;
  52:packetmater.c **** 		packet[25] = csumr&0xff;
  53:packetmater.c **** 
  54:packetmater.c **** 		if( packet[23] == 0x11  )
  55:packetmater.c **** 		{
  56:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
  57:packetmater.c **** 			packet[32+6] = udppacklen>>8;
  58:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
  59:packetmater.c **** 
  60:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
  61:packetmater.c **** 			packet[40+0] = pseudo>>8;
  62:packetmater.c **** 			packet[40+1] = pseudo&0xff;
  63:packetmater.c **** 
  64:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
  65:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
  66:packetmater.c **** 			packet[40+0] = csumr>>8;
  67:packetmater.c **** 			packet[40+1] = csumr&0xff;
  68:packetmater.c **** 		}
  69:packetmater.c **** 	}
  70:packetmater.c **** 
  71:packetmater.c **** 
  72:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
  73:packetmater.c **** 
  74:packetmater.c **** 	packet[plen+0] = crc & 0xff;
  75:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
  76:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
  77:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
  78:packetmater.c **** 
  79:packetmater.c **** 	return plen;
  80:packetmater.c **** }
  81:packetmater.c **** 
  82:packetmater.c **** 
  83:packetmater.c **** //From: http://www.hackersdelight.org/hdcodetxt/crc.c.txt
  84:packetmater.c **** uint32_t crc32b(uint32_t crc, unsigned char *message, int len) {
 103               	.LM0:
 104               	.LFBB1:
 105 0000 AF92      		push r10
 106 0002 BF92      		push r11
 107 0004 CF92      		push r12
 108 0006 DF92      		push r13
 109 0008 EF92      		push r14
 110 000a FF92      		push r15
 111 000c 0F93      		push r16
 112 000e 1F93      		push r17
 113 0010 CF93      		push r28
 114 0012 DF93      		push r29
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 10 */
 118               	.L__stack_usage = 10
 119 0014 5901      		movw r10,r18
  85:packetmater.c ****    int i, j;
  86:packetmater.c ****    uint32_t mask;
GAS LISTING /tmp/ccCeDQZH.s 			page 3


  87:packetmater.c **** 	uint8_t byte;
  88:packetmater.c **** 
  89:packetmater.c ****    i = 0;
  90:packetmater.c **** //   crc = 0xFFFFFFFF;
  91:packetmater.c **** 	crc = ~crc;
 121               	.LM1:
 122 0016 6095      		com r22
 123 0018 7095      		com r23
 124 001a 8095      		com r24
 125 001c 9095      		com r25
  92:packetmater.c ****    while (i < len) {
 127               	.LM2:
 128 001e FA01      		movw r30,r20
 129               	.L2:
 130 0020 9F01      		movw r18,r30
 131 0022 241B      		sub r18,r20
 132 0024 350B      		sbc r19,r21
 134               	.LM3:
 135 0026 2A15      		cp r18,r10
 136 0028 3B05      		cpc r19,r11
 137 002a 04F4      		brge .L8
  93:packetmater.c ****       byte = message[i];            // Get next byte.
 139               	.LM4:
 140 002c 2191      		ld r18,Z+
  94:packetmater.c ****       crc = crc ^ byte;
 142               	.LM5:
 143 002e 6227      		eor r22,r18
 144 0030 A8E0      		ldi r26,lo8(8)
 145 0032 B0E0      		ldi r27,0
 146               	.L4:
  95:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
  96:packetmater.c ****          mask = -(crc & 1);
  97:packetmater.c ****          crc = (crc >> 1) ^ (0xEDB88320 & mask);
 148               	.LM6:
 149 0034 8B01      		movw r16,r22
 150 0036 9C01      		movw r18,r24
 151 0038 3695      		lsr r19
 152 003a 2795      		ror r18
 153 003c 1795      		ror r17
 154 003e 0795      		ror r16
  96:packetmater.c ****          mask = -(crc & 1);
 156               	.LM7:
 157 0040 6B01      		movw r12,r22
 158 0042 7C01      		movw r14,r24
 159 0044 C1E0      		ldi r28,1
 160 0046 CC22      		and r12,r28
 161 0048 DD24      		clr r13
 162 004a EE24      		clr r14
 163 004c FF24      		clr r15
 164 004e 6627      		clr r22
 165 0050 7727      		clr r23
 166 0052 CB01      		movw r24,r22
 167 0054 6C19      		sub r22,r12
 168 0056 7D09      		sbc r23,r13
 169 0058 8E09      		sbc r24,r14
 170 005a 9F09      		sbc r25,r15
 172               	.LM8:
GAS LISTING /tmp/ccCeDQZH.s 			page 4


 173 005c 6072      		andi r22,32
 174 005e 7378      		andi r23,131
 175 0060 887B      		andi r24,184
 176 0062 9D7E      		andi r25,237
 177 0064 6027      		eor r22,r16
 178 0066 7127      		eor r23,r17
 179 0068 8227      		eor r24,r18
 180 006a 9327      		eor r25,r19
 181 006c 1197      		sbiw r26,1
  95:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
 183               	.LM9:
 184 006e 1097      		sbiw r26,0
 185 0070 01F4      		brne .L4
 186 0072 00C0      		rjmp .L2
 187               	.L8:
  98:packetmater.c ****       }
  99:packetmater.c ****       i = i + 1;
 100:packetmater.c ****    }
 101:packetmater.c ****    return ~crc;
 189               	.LM10:
 190 0074 6095      		com r22
 191 0076 7095      		com r23
 192 0078 8095      		com r24
 193 007a 9095      		com r25
 194               	/* epilogue start */
 102:packetmater.c **** }
 196               	.LM11:
 197 007c DF91      		pop r29
 198 007e CF91      		pop r28
 199 0080 1F91      		pop r17
 200 0082 0F91      		pop r16
 201 0084 FF90      		pop r15
 202 0086 EF90      		pop r14
 203 0088 DF90      		pop r13
 204 008a CF90      		pop r12
 205 008c BF90      		pop r11
 206 008e AF90      		pop r10
 207 0090 0895      		ret
 212               	.Lscope1:
 214               		.stabd	78,0,0
 218               	.global	internet_checksum
 220               	internet_checksum:
 221               		.stabd	46,0,0
 103:packetmater.c **** 
 104:packetmater.c **** uint16_t internet_checksum( const unsigned char * start, uint16_t len )
 105:packetmater.c **** {
 223               	.LM12:
 224               	.LFBB2:
 225 0092 CF93      		push r28
 226 0094 DF93      		push r29
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 2 */
 230               	.L__stack_usage = 2
 231 0096 9B01      		movw r18,r22
 232 0098 DC01      		movw r26,r24
 106:packetmater.c **** 	uint16_t i;
GAS LISTING /tmp/ccCeDQZH.s 			page 5


 107:packetmater.c **** 	const uint16_t * wptr = (uint16_t*) start;
 108:packetmater.c **** 	uint32_t csum = 0;
 234               	.LM13:
 235 009a 40E0      		ldi r20,0
 236 009c 50E0      		ldi r21,0
 237 009e BA01      		movw r22,r20
 109:packetmater.c **** 	for (i=1;i<len;i+=2)
 239               	.LM14:
 240 00a0 E1E0      		ldi r30,lo8(1)
 241 00a2 F0E0      		ldi r31,0
 242               	.L10:
 244               	.LM15:
 245 00a4 E217      		cp r30,r18
 246 00a6 F307      		cpc r31,r19
 247 00a8 00F4      		brsh .L18
 110:packetmater.c **** 	{
 111:packetmater.c **** 		csum = csum + (uint32_t)(*(wptr++));	
 249               	.LM16:
 250 00aa CD91      		ld r28,X+
 251 00ac DD91      		ld r29,X+
 252 00ae 4C0F      		add r20,r28
 253 00b0 5D1F      		adc r21,r29
 254 00b2 611D      		adc r22,__zero_reg__
 255 00b4 711D      		adc r23,__zero_reg__
 109:packetmater.c **** 	for (i=1;i<len;i+=2)
 257               	.LM17:
 258 00b6 3296      		adiw r30,2
 259 00b8 00C0      		rjmp .L10
 260               	.L18:
 261 00ba F901      		movw r30,r18
 262 00bc EE7F      		andi r30,254
 263 00be E80F      		add r30,r24
 264 00c0 F91F      		adc r31,r25
 112:packetmater.c **** 	}
 113:packetmater.c **** 	if( len & 1 )  //See if there's an odd number of bytes?
 266               	.LM18:
 267 00c2 20FF      		sbrs r18,0
 268 00c4 00C0      		rjmp .L13
 269               	.LBB2:
 114:packetmater.c **** 	{
 115:packetmater.c **** 		uint8_t * tt = (uint8_t*)wptr;
 116:packetmater.c **** 		csum += *tt;
 271               	.LM19:
 272 00c6 8081      		ld r24,Z
 273 00c8 480F      		add r20,r24
 274 00ca 511D      		adc r21,__zero_reg__
 275 00cc 611D      		adc r22,__zero_reg__
 276 00ce 711D      		adc r23,__zero_reg__
 277               	.L13:
 278               	.LBE2:
 117:packetmater.c **** 	}
 118:packetmater.c **** 	while (csum>>16)
 280               	.LM20:
 281 00d0 CB01      		movw r24,r22
 282 00d2 AA27      		clr r26
 283 00d4 BB27      		clr r27
 284 00d6 0097      		sbiw r24,0
GAS LISTING /tmp/ccCeDQZH.s 			page 6


 285 00d8 A105      		cpc r26,__zero_reg__
 286 00da B105      		cpc r27,__zero_reg__
 287 00dc 01F0      		breq .L19
 119:packetmater.c **** 		csum = (csum & 0xFFFF)+(csum >> 16);
 289               	.LM21:
 290 00de 6627      		clr r22
 291 00e0 7727      		clr r23
 292 00e2 480F      		add r20,r24
 293 00e4 591F      		adc r21,r25
 294 00e6 6A1F      		adc r22,r26
 295 00e8 7B1F      		adc r23,r27
 296 00ea 00C0      		rjmp .L13
 297               	.L19:
 120:packetmater.c **** 	csum = (csum>>8) | ((csum&0xff)<<8);
 299               	.LM22:
 300 00ec BB27      		clr r27
 301 00ee A72F      		mov r26,r23
 302 00f0 962F      		mov r25,r22
 303 00f2 852F      		mov r24,r21
 304 00f4 762F      		mov r23,r22
 305 00f6 652F      		mov r22,r21
 306 00f8 542F      		mov r21,r20
 307 00fa 4427      		clr r20
 308 00fc 6627      		clr r22
 309 00fe 7727      		clr r23
 310 0100 482B      		or r20,r24
 311 0102 592B      		or r21,r25
 312 0104 6A2B      		or r22,r26
 313 0106 7B2B      		or r23,r27
 121:packetmater.c **** 	return ~csum;
 315               	.LM23:
 316 0108 CA01      		movw r24,r20
 317 010a 8095      		com r24
 318 010c 9095      		com r25
 319               	/* epilogue start */
 122:packetmater.c **** }
 321               	.LM24:
 322 010e DF91      		pop r29
 323 0110 CF91      		pop r28
 324 0112 0895      		ret
 329               	.Lscope2:
 331               		.stabd	78,0,0
 336               	.global	Ethernetize
 338               	Ethernetize:
 339               		.stabd	46,0,0
  30:packetmater.c **** {
 341               	.LM25:
 342               	.LFBB3:
 343 0114 AF92      		push r10
 344 0116 BF92      		push r11
 345 0118 CF92      		push r12
 346 011a DF92      		push r13
 347 011c EF92      		push r14
 348 011e FF92      		push r15
 349 0120 0F93      		push r16
 350 0122 1F93      		push r17
 351 0124 CF93      		push r28
GAS LISTING /tmp/ccCeDQZH.s 			page 7


 352 0126 DF93      		push r29
 353               	/* prologue: function */
 354               	/* frame size = 0 */
 355               	/* stack size = 10 */
 356               	.L__stack_usage = 10
 357 0128 EC01      		movw r28,r24
 358 012a 7A01      		movw r14,r20
  32:packetmater.c **** 	packet += 8; //User must provide preamble.
 360               	.LM26:
 361 012c 5C01      		movw r10,r24
 362 012e 88E0      		ldi r24,8
 363 0130 A80E      		add r10,r24
 364 0132 B11C      		adc r11,__zero_reg__
  34:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
 366               	.LM27:
 367 0134 9A01      		movw r18,r20
 368 0136 295F      		subi r18,-7
 369 0138 3F4F      		sbci r19,-1
 370 013a CB01      		movw r24,r22
 371 013c 8E97      		sbiw r24,46
 372 013e 2817      		cp r18,r24
 373 0140 3907      		cpc r19,r25
 374 0142 04F4      		brge .L21
  31:packetmater.c **** 	plen -= 12;
 376               	.LM28:
 377 0144 8B01      		movw r16,r22
 378 0146 0C50      		subi r16,12
 379 0148 1109      		sbc r17,__zero_reg__
 380 014a 00C0      		rjmp .L22
 381               	.L21:
  35:packetmater.c **** 		plen = (udplenoverride+8) + 34;
 383               	.LM29:
 384 014c 8A01      		movw r16,r20
 385 014e 065D      		subi r16,-42
 386 0150 1F4F      		sbci r17,-1
 387               	.L22:
  38:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
 389               	.LM30:
 390 0152 0150      		subi r16,1
 391 0154 1109      		sbc r17,__zero_reg__
 392 0156 0C7F      		andi r16,252
 393 0158 6801      		movw r12,r16
 394 015a 84E0      		ldi r24,4
 395 015c C80E      		add r12,r24
 396 015e D11C      		adc r13,__zero_reg__
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 398               	.LM31:
 399 0160 8C89      		ldd r24,Y+20
 400 0162 8830      		cpi r24,lo8(8)
 401 0164 01F4      		brne .L24
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 403               	.LM32:
 404 0166 8D89      		ldd r24,Y+21
 405 0168 8111      		cpse r24,__zero_reg__
 406 016a 00C0      		rjmp .L24
 407               	.LBB3:
  42:packetmater.c **** 		uint16_t fullpacklen = plen-14;
GAS LISTING /tmp/ccCeDQZH.s 			page 8


 409               	.LM33:
 410 016c C801      		movw r24,r16
 411 016e 0A97      		sbiw r24,10
  43:packetmater.c **** 		packet[16] = fullpacklen>>8;
 413               	.LM34:
 414 0170 988F      		std Y+24,r25
  44:packetmater.c **** 		packet[17] = fullpacklen&0xff;
 416               	.LM35:
 417 0172 898F      		std Y+25,r24
  45:packetmater.c **** 		packet[24] = 0;
 419               	.LM36:
 420 0174 18A2      		std Y+32,__zero_reg__
  46:packetmater.c **** 		packet[25] = 0;
 422               	.LM37:
 423 0176 19A2      		std Y+33,__zero_reg__
  49:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
 425               	.LM38:
 426 0178 64E1      		ldi r22,lo8(20)
 427 017a 70E0      		ldi r23,0
 428 017c CE01      		movw r24,r28
 429 017e 4696      		adiw r24,22
 430 0180 00D0      		rcall internet_checksum
  51:packetmater.c **** 		packet[24] = csumr>>8;
 432               	.LM39:
 433 0182 98A3      		std Y+32,r25
  52:packetmater.c **** 		packet[25] = csumr&0xff;
 435               	.LM40:
 436 0184 89A3      		std Y+33,r24
  54:packetmater.c **** 		if( packet[23] == 0x11  )
 438               	.LM41:
 439 0186 8F8D      		ldd r24,Y+31
 440 0188 8131      		cpi r24,lo8(17)
 441 018a 01F4      		brne .L24
 442               	.LBB4:
  56:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
 444               	.LM42:
 445 018c B701      		movw r22,r14
 446 018e 685F      		subi r22,-8
 447 0190 7F4F      		sbci r23,-1
  57:packetmater.c **** 			packet[32+6] = udppacklen>>8;
 449               	.LM43:
 450 0192 7EA7      		std Y+46,r23
  58:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
 452               	.LM44:
 453 0194 6FA7      		std Y+47,r22
  60:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
 455               	.LM45:
 456 0196 89E1      		ldi r24,25
 457 0198 E80E      		add r14,r24
 458 019a F11C      		adc r15,__zero_reg__
  61:packetmater.c **** 			packet[40+0] = pseudo>>8;
 460               	.LM46:
 461 019c F8AA      		std Y+48,r15
  62:packetmater.c **** 			packet[40+1] = pseudo&0xff;
 463               	.LM47:
 464 019e E9AA      		std Y+49,r14
  64:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
GAS LISTING /tmp/ccCeDQZH.s 			page 9


 466               	.LM48:
 467 01a0 685F      		subi r22,-8
 468 01a2 7F4F      		sbci r23,-1
 469 01a4 CE01      		movw r24,r28
 470 01a6 8296      		adiw r24,34
 471 01a8 00D0      		rcall internet_checksum
  65:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
 473               	.LM49:
 474 01aa 0097      		sbiw r24,0
 475 01ac 01F4      		brne .L26
 476 01ae 8FEF      		ldi r24,lo8(-1)
 477 01b0 9FEF      		ldi r25,lo8(-1)
 478               	.L26:
  66:packetmater.c **** 			packet[40+0] = csumr>>8;
 480               	.LM50:
 481 01b2 98AB      		std Y+48,r25
  67:packetmater.c **** 			packet[40+1] = csumr&0xff;
 483               	.LM51:
 484 01b4 89AB      		std Y+49,r24
 485               	.L24:
 486               	.LBE4:
 487               	.LBE3:
  72:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
 489               	.LM52:
 490 01b6 9601      		movw r18,r12
 491 01b8 A501      		movw r20,r10
 492 01ba 60E0      		ldi r22,0
 493 01bc 70E0      		ldi r23,0
 494 01be CB01      		movw r24,r22
 495 01c0 00D0      		rcall crc32b
  74:packetmater.c **** 	packet[plen+0] = crc & 0xff;
 497               	.LM53:
 498 01c2 F501      		movw r30,r10
 499 01c4 EC0D      		add r30,r12
 500 01c6 FD1D      		adc r31,r13
 501 01c8 6083      		st Z,r22
  75:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
 503               	.LM54:
 504 01ca F501      		movw r30,r10
 505 01cc E00F      		add r30,r16
 506 01ce F11F      		adc r31,r17
 507 01d0 7583      		std Z+5,r23
  76:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
 509               	.LM55:
 510 01d2 8683      		std Z+6,r24
  77:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
 512               	.LM56:
 513 01d4 9783      		std Z+7,r25
  80:packetmater.c **** }
 515               	.LM57:
 516 01d6 C601      		movw r24,r12
 517               	/* epilogue start */
 518 01d8 DF91      		pop r29
 519 01da CF91      		pop r28
 520 01dc 1F91      		pop r17
 521 01de 0F91      		pop r16
 522 01e0 FF90      		pop r15
GAS LISTING /tmp/ccCeDQZH.s 			page 10


 523 01e2 EF90      		pop r14
 524 01e4 DF90      		pop r13
 525 01e6 CF90      		pop r12
 526 01e8 BF90      		pop r11
 527 01ea AF90      		pop r10
 528 01ec 0895      		ret
 533               	.Lscope3:
 535               		.stabd	78,0,0
 537               	.Letext0:
 538               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccCeDQZH.s 			page 11


DEFINED SYMBOLS
                            *ABS*:0000000000000000 packetmater.c
     /tmp/ccCeDQZH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccCeDQZH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccCeDQZH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccCeDQZH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccCeDQZH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccCeDQZH.s:100    .text:0000000000000000 crc32b
     /tmp/ccCeDQZH.s:220    .text:0000000000000092 internet_checksum
     /tmp/ccCeDQZH.s:338    .text:0000000000000114 Ethernetize

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccCeDQZH.s 			page 1


   1               		.file	"hlprocess.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  96               	.global	Demanchestrate
  98               	Demanchestrate:
  99               		.stabd	46,0,0
   1:hlprocess.c   **** #include "hlprocess.h"
   2:hlprocess.c   **** 
   3:hlprocess.c   **** //Note: -1 indicates unmatched short pulse.  I.e. quick transitions must pair up.
   4:hlprocess.c   **** int16_t Demanchestrate( unsigned char * raw_data_packet, uint16_t max_packet_data_len )
   5:hlprocess.c   **** {
 101               	.LM0:
 102               	.LFBB1:
 103 0000 CF92      		push r12
 104 0002 DF92      		push r13
 105 0004 EF92      		push r14
 106 0006 FF92      		push r15
 107 0008 0F93      		push r16
 108 000a 1F93      		push r17
 109 000c CF93      		push r28
 110 000e DF93      		push r29
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 8 */
 114               	.L__stack_usage = 8
 115 0010 FC01      		movw r30,r24
   6:hlprocess.c   **** 	uint8_t in_preamble = 4;
   7:hlprocess.c   **** 	uint8_t t;
   8:hlprocess.c   **** 	uint8_t mask;
   9:hlprocess.c   **** 
  10:hlprocess.c   **** 	uint8_t bit;
  11:hlprocess.c   **** 	uint8_t lastbit = 0;
  12:hlprocess.c   **** 	int8_t count = 0;
  13:hlprocess.c   **** 	uint16_t plen = 0;
  14:hlprocess.c   **** 	uint8_t shortflag = 0;
  15:hlprocess.c   **** 
  16:hlprocess.c   **** 	uint8_t cemitbit = 1; //current emitting bit.
  17:hlprocess.c   **** 	uint8_t cemitbyte = 0;
  18:hlprocess.c   **** 	uint8_t cemitmask = 1;
 117               	.LM1:
 118 0012 B1E0      		ldi r27,lo8(1)
  17:hlprocess.c   **** 	uint8_t cemitbyte = 0;
 120               	.LM2:
 121 0014 D0E0      		ldi r29,0
  16:hlprocess.c   **** 	uint8_t cemitbit = 1; //current emitting bit.
 123               	.LM3:
 124 0016 11E0      		ldi r17,lo8(1)
  14:hlprocess.c   **** 	uint8_t shortflag = 0;
 126               	.LM4:
 127 0018 A0E0      		ldi r26,0
  13:hlprocess.c   **** 	uint16_t plen = 0;
 129               	.LM5:
GAS LISTING /tmp/ccCeDQZH.s 			page 2


 130 001a 20E0      		ldi r18,0
 131 001c 30E0      		ldi r19,0
  12:hlprocess.c   **** 	int8_t count = 0;
 133               	.LM6:
 134 001e 60E0      		ldi r22,0
  11:hlprocess.c   **** 	uint8_t lastbit = 0;
 136               	.LM7:
 137 0020 C0E0      		ldi r28,0
   6:hlprocess.c   **** 	uint8_t in_preamble = 4;
 139               	.LM8:
 140 0022 74E0      		ldi r23,lo8(4)
  19:hlprocess.c   **** 
  20:hlprocess.c   **** 	uint8_t * output = raw_data_packet;
  21:hlprocess.c   **** 
  22:hlprocess.c   **** 	while( 1 )
  23:hlprocess.c   **** 	{
  24:hlprocess.c   **** 		t = *(raw_data_packet++);
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
  26:hlprocess.c   **** 		{
  27:hlprocess.c   **** 			bit = (t&mask)?1:0;
 142               	.LM9:
 143 0024 DD24      		clr r13
 144 0026 D394      		inc r13
 145               	.L11:
  24:hlprocess.c   **** 		t = *(raw_data_packet++);
 147               	.LM10:
 148 0028 E190      		ld r14,Z+
 149 002a FC2E      		mov r15,r28
 150 002c 48E0      		ldi r20,lo8(8)
 151 002e 50E0      		ldi r21,0
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
 153               	.LM11:
 154 0030 00E8      		ldi r16,lo8(-128)
 155               	.L12:
 157               	.LM12:
 158 0032 C1E0      		ldi r28,lo8(1)
 159 0034 C02E      		mov r12,r16
 160 0036 CE20      		and r12,r14
 161 0038 01F4      		brne .L2
 162 003a C0E0      		ldi r28,0
 163               	.L2:
  28:hlprocess.c   **** 			if( bit != lastbit )
 165               	.LM13:
 166 003c CF15      		cp r28,r15
 167 003e 01F0      		breq .L3
  29:hlprocess.c   **** 			{
  30:hlprocess.c   **** 				//Ignore first two changes.
  31:hlprocess.c   **** 				if( in_preamble > 2 && count > 1 )
 169               	.LM14:
 170 0040 7330      		cpi r23,lo8(3)
 171 0042 00F0      		brlo .L4
 173               	.LM15:
 174 0044 6230      		cpi r22,lo8(2)
 175 0046 04F4      		brge .L21
 176 0048 00C0      		rjmp .L20
 177               	.L4:
  32:hlprocess.c   **** 				{
GAS LISTING /tmp/ccCeDQZH.s 			page 3


  33:hlprocess.c   **** 					in_preamble--;
  34:hlprocess.c   **** 				}
  35:hlprocess.c   **** 				else if( in_preamble <= 2 && count < 2 && in_preamble )
 179               	.LM16:
 180 004a 6230      		cpi r22,lo8(2)
 181 004c 04F4      		brge .L6
 182 004e 7723      		tst r23
 183 0050 01F0      		breq .L7
 184               	.L21:
  36:hlprocess.c   **** 				{
  37:hlprocess.c   **** 					in_preamble--;
 186               	.LM17:
 187 0052 7150      		subi r23,lo8(-(-1))
 188 0054 00C0      		rjmp .L20
 189               	.L7:
 190               	.LBB2:
  38:hlprocess.c   **** 				}
  39:hlprocess.c   **** 				else if( !in_preamble )
  40:hlprocess.c   **** 				{
  41:hlprocess.c   **** 					uint8_t mark_emit = 0;
  42:hlprocess.c   **** 
  43:hlprocess.c   **** 					//Something happened.
  44:hlprocess.c   **** 					//If it's immediate, i.e. count = 0, count = 1 -> short (mark for ticking)
  45:hlprocess.c   **** 					//If it's later, i.e. count = 2, count = 3 -> long (invert)
  46:hlprocess.c   **** 					//We cannot get >3 as that's handled when we increase count.
  47:hlprocess.c   **** 					if( count > 1 )
  48:hlprocess.c   **** 					{
  49:hlprocess.c   **** 						if( shortflag )
  50:hlprocess.c   **** 						{
  51:hlprocess.c   **** 							return -1;
  52:hlprocess.c   **** 						}
  53:hlprocess.c   **** 						//invert bit.
  54:hlprocess.c   **** 						cemitbit = !cemitbit;
  55:hlprocess.c   **** 
  56:hlprocess.c   **** 						mark_emit = 1;
  57:hlprocess.c   **** 					}
  58:hlprocess.c   **** 					else
  59:hlprocess.c   **** 					{
  60:hlprocess.c   **** 						if( shortflag )
 192               	.LM18:
 193 0056 A111      		cpse r26,__zero_reg__
 194 0058 00C0      		rjmp .L9
  61:hlprocess.c   **** 						{
  62:hlprocess.c   **** 							mark_emit = 1;
  63:hlprocess.c   **** 							shortflag = 0;
  64:hlprocess.c   **** 						}
  65:hlprocess.c   **** 						else
  66:hlprocess.c   **** 						{
  67:hlprocess.c   **** 							shortflag = 1;
 196               	.LM19:
 197 005a A1E0      		ldi r26,lo8(1)
 198               	.L20:
 199               	.LBE2:
  68:hlprocess.c   **** 						}
  69:hlprocess.c   **** 					}
  70:hlprocess.c   **** 					if( mark_emit )
  71:hlprocess.c   **** 					{
GAS LISTING /tmp/ccCeDQZH.s 			page 4


  72:hlprocess.c   **** 						//Emit cemitbit. 
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
  74:hlprocess.c   **** 						cemitmask <<= 1;
  75:hlprocess.c   **** 
  76:hlprocess.c   **** 						if( (cemitmask&0xff) == 0 )
  77:hlprocess.c   **** 						{
  78:hlprocess.c   **** 							output[plen++] = cemitbyte;
  79:hlprocess.c   **** 							cemitbyte = 0;
  80:hlprocess.c   **** 							cemitmask = 1;
  81:hlprocess.c   **** 						}
  82:hlprocess.c   **** 						mark_emit = 0;
  83:hlprocess.c   **** 					}
  84:hlprocess.c   **** 				}
  85:hlprocess.c   **** 
  86:hlprocess.c   **** 				lastbit = bit;
  87:hlprocess.c   **** 				count = 0;
 201               	.LM20:
 202 005c 60E0      		ldi r22,0
 203 005e 00C0      		rjmp .L5
 204               	.L3:
  88:hlprocess.c   **** 			}
  89:hlprocess.c   **** 			else
  90:hlprocess.c   **** 			{
  91:hlprocess.c   **** 				count++;
 206               	.LM21:
 207 0060 6F5F      		subi r22,lo8(-(1))
  92:hlprocess.c   **** 				if( count > 3 )
 209               	.LM22:
 210 0062 6430      		cpi r22,lo8(4)
 211 0064 04F0      		brlt .L5
  93:hlprocess.c   **** 				{
  94:hlprocess.c   **** 					return plen;
 213               	.LM23:
 214 0066 C901      		movw r24,r18
 215 0068 00C0      		rjmp .L19
 216               	.L6:
  39:hlprocess.c   **** 				else if( !in_preamble )
 218               	.LM24:
 219 006a 7111      		cpse r23,__zero_reg__
 220 006c 00C0      		rjmp .L20
 221               	.LBB3:
  49:hlprocess.c   **** 						if( shortflag )
 223               	.LM25:
 224 006e A111      		cpse r26,__zero_reg__
 225 0070 00C0      		rjmp .L17
  54:hlprocess.c   **** 						cemitbit = !cemitbit;
 227               	.LM26:
 228 0072 1D25      		eor r17,r13
 229               	.L9:
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 231               	.LM27:
 232 0074 1123      		tst r17
 233 0076 01F0      		breq .L23
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 235               	.LM28:
 236 0078 6B2F      		mov r22,r27
 237               	.L14:
GAS LISTING /tmp/ccCeDQZH.s 			page 5


  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 239               	.LM29:
 240 007a D62B      		or r29,r22
  74:hlprocess.c   **** 						cemitmask <<= 1;
 242               	.LM30:
 243 007c BB0F      		lsl r27
  76:hlprocess.c   **** 						if( (cemitmask&0xff) == 0 )
 245               	.LM31:
 246 007e 01F4      		brne .L18
  78:hlprocess.c   **** 							output[plen++] = cemitbyte;
 248               	.LM32:
 249 0080 DC01      		movw r26,r24
 250 0082 A20F      		add r26,r18
 251 0084 B31F      		adc r27,r19
 252 0086 DC93      		st X,r29
 253 0088 2F5F      		subi r18,-1
 254 008a 3F4F      		sbci r19,-1
  80:hlprocess.c   **** 							cemitmask = 1;
 256               	.LM33:
 257 008c B1E0      		ldi r27,lo8(1)
  79:hlprocess.c   **** 							cemitbyte = 0;
 259               	.LM34:
 260 008e D0E0      		ldi r29,0
 261               	.L18:
 262 0090 A0E0      		ldi r26,0
 263               	.LBE3:
  87:hlprocess.c   **** 				count = 0;
 265               	.LM35:
 266 0092 60E0      		ldi r22,0
 267               	.LBB4:
 268 0094 70E0      		ldi r23,0
 269               	.L5:
 270               	.LBE4:
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
 272               	.LM36:
 273 0096 0695      		lsr r16
 274 0098 4150      		subi r20,1
 275 009a 5109      		sbc r21,__zero_reg__
 276 009c 4115      		cp r20,__zero_reg__
 277 009e 5105      		cpc r21,__zero_reg__
 278 00a0 01F0      		breq .L11
  27:hlprocess.c   **** 			bit = (t&mask)?1:0;
 280               	.LM37:
 281 00a2 FC2E      		mov r15,r28
 282 00a4 00C0      		rjmp .L12
 283               	.L23:
 284               	.LBB5:
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 286               	.LM38:
 287 00a6 60E0      		ldi r22,0
 288 00a8 00C0      		rjmp .L14
 289               	.L17:
  51:hlprocess.c   **** 							return -1;
 291               	.LM39:
 292 00aa 8FEF      		ldi r24,lo8(-1)
 293 00ac 9FEF      		ldi r25,lo8(-1)
 294               	.L19:
GAS LISTING /tmp/ccCeDQZH.s 			page 6


 295               	/* epilogue start */
 296               	.LBE5:
  95:hlprocess.c   **** 				}
  96:hlprocess.c   **** 			}
  97:hlprocess.c   **** 		}
  98:hlprocess.c   **** 		//Next byte.
  99:hlprocess.c   **** 	}
 100:hlprocess.c   **** }
 298               	.LM40:
 299 00ae DF91      		pop r29
 300 00b0 CF91      		pop r28
 301 00b2 1F91      		pop r17
 302 00b4 0F91      		pop r16
 303 00b6 FF90      		pop r15
 304 00b8 EF90      		pop r14
 305 00ba DF90      		pop r13
 306 00bc CF90      		pop r12
 307 00be 0895      		ret
 319               	.Lscope1:
 321               		.stabd	78,0,0
 323               	.Letext0:
 324               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccCeDQZH.s 			page 7


DEFINED SYMBOLS
                            *ABS*:0000000000000000 hlprocess.c
     /tmp/ccCeDQZH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccCeDQZH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccCeDQZH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccCeDQZH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccCeDQZH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccCeDQZH.s:98     .text:0000000000000000 Demanchestrate

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccCeDQZH.s 			page 1


   1               		.file	"net_compat.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 110               	et_push8:
 111               		.stabd	46,0,0
 113               	.Ltext1:
   1:net_compat.h  **** #ifndef _ENC424JCOMPAT_H
   2:net_compat.h  **** #define _ENC424JCOMPAT_H
   3:net_compat.h  **** 
   4:net_compat.h  **** //et compat lib.
   5:net_compat.h  **** //We're using the IP library from AVRCraft
   6:net_compat.h  **** 
   7:net_compat.h  **** //TODO: Should probably use Timer1 (since we can't use Timer0)
   8:net_compat.h  **** //to make sure we send media detect pulses at the right points.
   9:net_compat.h  **** //Also, as a user, you cannot use the USI or Timer0
  10:net_compat.h  **** 
  11:net_compat.h  **** #include <stdint.h>
  12:net_compat.h  **** #include "eth_config.h"
  13:net_compat.h  **** 
  14:net_compat.h  **** //MyMAC is included in this driver.
  15:net_compat.h  **** extern unsigned char MyMAC[6];
  16:net_compat.h  **** extern unsigned char ETbuffer[ETBUFFERSIZE+PREAMBLE];
  17:net_compat.h  **** extern unsigned short ETsendplace;
  18:net_compat.h  **** //For telling where the current transaction started.
  19:net_compat.h  **** extern uint16_t sendbaseaddress;
  20:net_compat.h  **** extern unsigned short ETchecksum;
  21:net_compat.h  **** 
  22:net_compat.h  **** //Do not split this across byte-addressing boundaries.
  23:net_compat.h  **** //We do some fancy stuff when we send the manchester out.
  24:net_compat.h  **** extern char ManchesterTable[16];
  25:net_compat.h  **** 
  26:net_compat.h  **** //return 0 if OK, otherwise nonzero.
  27:net_compat.h  **** int8_t et_init( const unsigned char * macaddy );
  28:net_compat.h  **** 
  29:net_compat.h  **** int8_t et_xmitpacket( uint16_t start, uint16_t len );
  30:net_compat.h  **** 
  31:net_compat.h  **** //This waits for 8ms, sends an autoneg notice, then waits for 8 more ms.
  32:net_compat.h  **** //Ordinarily this would if packets were processed and still ned processing, but
  33:net_compat.h  **** //that doesn't make sense for this driver.  Do not put this in a loop unto itself.
  34:net_compat.h  **** unsigned short et_recvpack();
  35:net_compat.h  **** 
  36:net_compat.h  **** //You have to write this! (Or the underlying IP core must)
  37:net_compat.h  **** void et_receivecallback( uint16_t packetlen );
  38:net_compat.h  **** 
  39:net_compat.h  **** //Finish up any reading. 							//CLOSURE
  40:net_compat.h  **** static inline void et_finish_callback_now() { }
  41:net_compat.h  **** 
  42:net_compat.h  **** //Raw, on-wire pops. (assuming already in read)
  43:net_compat.h  **** void et_popblob( uint8_t * data, uint8_t len );
  44:net_compat.h  **** static inline void et_dumpbytes( uint8_t len ) { ETsendplace += len; }
  45:net_compat.h  **** static inline uint16_t et_pop16() { return ETbuffer[ETsendplace++]; }
  46:net_compat.h  **** static inline uint8_t et_pop8() { return ETbuffer[ETsendplace++]; }
GAS LISTING /tmp/ccCeDQZH.s 			page 2


  47:net_compat.h  **** 
  48:net_compat.h  **** //Raw, on-wire push. (assuming already in write)
  49:net_compat.h  **** void et_pushpgmstr( const char * msg );
  50:net_compat.h  **** void et_pushstr( const char * msg );
  51:net_compat.h  **** void et_pushblob( const uint8_t * data, uint8_t len );
  52:net_compat.h  **** void et_pushpgmblob( const uint8_t * data, uint8_t len );
  53:net_compat.h  **** static inline void et_push8( uint8_t d ) { ETbuffer[ETsendplace++] = d; }
 115               	.LM0:
 116               	.LFBB1:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 122               	.LM1:
 123 0000 2091 0000 		lds r18,ETsendplace
 124 0004 3091 0000 		lds r19,ETsendplace+1
 125 0008 A901      		movw r20,r18
 126 000a 4F5F      		subi r20,-1
 127 000c 5F4F      		sbci r21,-1
 128 000e 5093 0000 		sts ETsendplace+1,r21
 129 0012 4093 0000 		sts ETsendplace,r20
 130 0016 F901      		movw r30,r18
 131 0018 E050      		subi r30,lo8(-(ETbuffer))
 132 001a F040      		sbci r31,hi8(-(ETbuffer))
 133 001c 8083      		st Z,r24
 134 001e 0895      		ret
 136               	.Lscope1:
 138               		.stabd	78,0,0
 143               	.global	GotPack
 145               	GotPack:
 146               		.stabd	46,0,0
 148               	.Ltext2:
   1:net_compat.c  **** #include "net_compat.h"
   2:net_compat.c  **** #include <avr/pgmspace.h>
   3:net_compat.c  **** #include <string.h>
   4:net_compat.c  **** 
   5:net_compat.c  **** #define NOOP asm volatile("nop" ::)
   6:net_compat.c  **** 
   7:net_compat.c  **** 
   8:net_compat.c  **** unsigned char MyMAC[6];
   9:net_compat.c  **** unsigned char ETbuffer[ETBUFFERSIZE+PREAMBLE];
  10:net_compat.c  **** unsigned short ETsendplace;
  11:net_compat.c  **** uint16_t sendbaseaddress;
  12:net_compat.c  **** unsigned short ETchecksum;
  13:net_compat.c  **** 
  14:net_compat.c  **** 
  15:net_compat.c  **** //Do not split this across byte-addressing boundaries.
  16:net_compat.c  **** //We do some fancy stuff when we send the manchester out.
  17:net_compat.c  **** char ManchesterTable[16] __attribute__ ((aligned (16))) = {
  18:net_compat.c  **** 	0b10101010, 0b01101010, 0b10011010, 0b01011010,
  19:net_compat.c  **** 	0b10100110, 0b01100110, 0b10010110, 0b01010110,
  20:net_compat.c  **** 	0b10101001, 0b01101001, 0b10011001, 0b01011001,
  21:net_compat.c  **** 	0b10100101, 0b01100101, 0b10010101, 0b01010101,
  22:net_compat.c  **** };
  23:net_compat.c  **** 
  24:net_compat.c  **** 
  25:net_compat.c  **** //Internal functs
GAS LISTING /tmp/ccCeDQZH.s 			page 3


  26:net_compat.c  **** 
  27:net_compat.c  **** //From the ASM file.
  28:net_compat.c  **** void SendTestASM( const unsigned char * c, uint8_t len );
  29:net_compat.c  **** int MaybeHaveDataASM( unsigned char * c, uint8_t lenX2 ); //returns the number of pairs.
  30:net_compat.c  **** 
  31:net_compat.c  **** //Attempt to return rough estimate of processing time.
  32:net_compat.c  **** int GotPack( unsigned char * machesterized, int estlen, uint16_t mlen )
  33:net_compat.c  **** {
 150               	.LM2:
 151               	.LFBB2:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  34:net_compat.c  **** 	int byr = 0;
  35:net_compat.c  **** 
  36:net_compat.c  **** 	byr = Demanchestrate( machesterized, mlen );
 157               	.LM3:
 158 0020 BA01      		movw r22,r20
 159 0022 00C0      		rjmp Demanchestrate
 161               	.Lscope2:
 163               		.stabd	78,0,0
 168               	.global	waitforpacket
 170               	waitforpacket:
 171               		.stabd	46,0,0
  37:net_compat.c  **** 
  38:net_compat.c  **** 	//Don't do anything yet...
  39:net_compat.c  **** 
  40:net_compat.c  **** 	return byr;
  41:net_compat.c  **** }
  42:net_compat.c  **** 
  43:net_compat.c  **** void waitforpacket( unsigned char * buffer, uint16_t len, int16_t ltime )
  44:net_compat.c  **** {
 173               	.LM4:
 174               	.LFBB3:
 175 0024 CF92      		push r12
 176 0026 DF92      		push r13
 177 0028 EF92      		push r14
 178 002a FF92      		push r15
 179 002c 0F93      		push r16
 180 002e 1F93      		push r17
 181 0030 CF93      		push r28
 182 0032 DF93      		push r29
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 8 */
 186               	.L__stack_usage = 8
 187 0034 6C01      		movw r12,r24
 188 0036 7B01      		movw r14,r22
 189 0038 EA01      		movw r28,r20
  45:net_compat.c  **** 	OSCCAL = OSCHIGH;
 191               	.LM5:
 192 003a 8FEF      		ldi r24,lo8(-1)
 193 003c 81BF      		out 0x31,r24
 194               	.L4:
  46:net_compat.c  **** 
  47:net_compat.c  **** 	//Make sure we're not walking in on something.
GAS LISTING /tmp/ccCeDQZH.s 			page 4


  48:net_compat.c  **** 	while( ltime-- > 0 )
 196               	.LM6:
 197 003e 2197      		sbiw r28,1
 198 0040 CE01      		movw r24,r28
 199 0042 0196      		adiw r24,1
 200 0044 1816      		cp __zero_reg__,r24
 201 0046 1906      		cpc __zero_reg__,r25
 202 0048 04F4      		brge .L10
  49:net_compat.c  **** 	{
  50:net_compat.c  **** 		if( USIBR == 0x00 ) break;
 204               	.LM7:
 205 004a 80B3      		in r24,0x10
 206 004c 8823      		tst r24
 207 004e 01F0      		breq .L10
  51:net_compat.c  **** 		if( USIBR == 0xFF ) break;
 209               	.LM8:
 210 0050 80B3      		in r24,0x10
 211 0052 8F3F      		cpi r24,lo8(-1)
 212 0054 01F0      		breq .L10
  52:net_compat.c  **** 		NOOP;
 214               	.LM9:
 215               	/* #APP */
 216               	 ;  52 "net_compat.c" 1
 217 0056 0000      		nop
 218               	 ;  0 "" 2
 219               	/* #NOAPP */
 220 0058 00C0      		rjmp .L4
 221               	.L11:
  53:net_compat.c  **** 	}
  54:net_compat.c  **** 
  55:net_compat.c  **** 
  56:net_compat.c  **** 	while( ltime-- > 0 )
  57:net_compat.c  **** 	{
  58:net_compat.c  **** 		if( USIBR && (USIBR != 0xFF ) )
 223               	.LM10:
 224 005a 80B3      		in r24,0x10
 225 005c 8111      		cpse r24,__zero_reg__
 226 005e 00C0      		rjmp .L27
 227               	.L10:
  56:net_compat.c  **** 	while( ltime-- > 0 )
 229               	.LM11:
 230 0060 2197      		sbiw r28,1
 231 0062 CE01      		movw r24,r28
 232 0064 0196      		adiw r24,1
 233 0066 1816      		cp __zero_reg__,r24
 234 0068 1906      		cpc __zero_reg__,r25
 235 006a 04F0      		brlt .L11
 236 006c 00C0      		rjmp .L9
 237               	.L27:
 239               	.LM12:
 240 006e 80B3      		in r24,0x10
 241 0070 8F3F      		cpi r24,lo8(-1)
 242 0072 01F0      		breq .L10
 243               	.LBB5:
  59:net_compat.c  **** 		{
  60:net_compat.c  **** 			int r = MaybeHaveDataASM( buffer, len );
 245               	.LM13:
GAS LISTING /tmp/ccCeDQZH.s 			page 5


 246 0074 6E2D      		mov r22,r14
 247 0076 C601      		movw r24,r12
 248 0078 00D0      		rcall MaybeHaveDataASM
 249 007a 8C01      		movw r16,r24
  61:net_compat.c  **** 			if( r > 1 )
 251               	.LM14:
 252 007c 8230      		cpi r24,2
 253 007e 9105      		cpc r25,__zero_reg__
 254 0080 04F0      		brlt .L8
 255               	.LBB6:
 256               	.LBB7:
  36:net_compat.c  **** 	byr = Demanchestrate( machesterized, mlen );
 258               	.LM15:
 259 0082 B701      		movw r22,r14
 260 0084 C601      		movw r24,r12
 261 0086 00D0      		rcall Demanchestrate
 262               	.LBE7:
 263               	.LBE6:
  62:net_compat.c  **** 			{
  63:net_compat.c  **** 				r += GotPack( buffer, r, len );
 265               	.LM16:
 266 0088 080F      		add r16,r24
 267 008a 191F      		adc r17,r25
 268               	.L8:
  64:net_compat.c  **** 			}
  65:net_compat.c  **** 			ltime-=(len-r)*4+3; //About how long the function takes to execute.
 270               	.LM17:
 271 008c 2397      		sbiw r28,3
 272 008e E01A      		sub r14,r16
 273 0090 F10A      		sbc r15,r17
 274 0092 EE0C      		lsl r14
 275 0094 FF1C      		rol r15
 276 0096 EE0C      		lsl r14
 277 0098 FF1C      		rol r15
 278 009a CE19      		sub r28,r14
 279 009c DF09      		sbc r29,r15
 280               	.L9:
 281               	.LBE5:
  66:net_compat.c  **** 			break;
  67:net_compat.c  **** 		}
  68:net_compat.c  **** 	}
  69:net_compat.c  **** 
  70:net_compat.c  **** 
  71:net_compat.c  **** 	while( ltime-- > 0 )
 283               	.LM18:
 284 009e 1C16      		cp __zero_reg__,r28
 285 00a0 1D06      		cpc __zero_reg__,r29
 286 00a2 04F4      		brge .L28
  72:net_compat.c  **** 	{
  73:net_compat.c  **** 		NOOP;
 288               	.LM19:
 289               	/* #APP */
 290               	 ;  73 "net_compat.c" 1
 291 00a4 0000      		nop
 292               	 ;  0 "" 2
  74:net_compat.c  **** 		NOOP;
 294               	.LM20:
GAS LISTING /tmp/ccCeDQZH.s 			page 6


 295               	 ;  74 "net_compat.c" 1
 296 00a6 0000      		nop
 297               	 ;  0 "" 2
  75:net_compat.c  **** 		NOOP;
 299               	.LM21:
 300               	 ;  75 "net_compat.c" 1
 301 00a8 0000      		nop
 302               	 ;  0 "" 2
  76:net_compat.c  **** 		NOOP;
 304               	.LM22:
 305               	 ;  76 "net_compat.c" 1
 306 00aa 0000      		nop
 307               	 ;  0 "" 2
  77:net_compat.c  **** 		NOOP;
 309               	.LM23:
 310               	 ;  77 "net_compat.c" 1
 311 00ac 0000      		nop
 312               	 ;  0 "" 2
 313               	/* #NOAPP */
 314 00ae 2197      		sbiw r28,1
 315 00b0 00C0      		rjmp .L9
 316               	.L28:
  78:net_compat.c  **** 	}
  79:net_compat.c  **** 
  80:net_compat.c  **** 	OSCCAL = OSC20;
 318               	.LM24:
 319 00b2 86EB      		ldi r24,lo8(-74)
 320 00b4 81BF      		out 0x31,r24
 321               	/* epilogue start */
  81:net_compat.c  **** }
 323               	.LM25:
 324 00b6 DF91      		pop r29
 325 00b8 CF91      		pop r28
 326 00ba 1F91      		pop r17
 327 00bc 0F91      		pop r16
 328 00be FF90      		pop r15
 329 00c0 EF90      		pop r14
 330 00c2 DF90      		pop r13
 331 00c4 CF90      		pop r12
 332 00c6 0895      		ret
 337               	.Lscope3:
 339               		.stabd	78,0,0
 343               	.global	et_popblob
 345               	et_popblob:
 346               		.stabd	46,0,0
  82:net_compat.c  **** 
  83:net_compat.c  **** 
  84:net_compat.c  **** 
  85:net_compat.c  **** 
  86:net_compat.c  **** 
  87:net_compat.c  **** 
  88:net_compat.c  **** 
  89:net_compat.c  **** 
  90:net_compat.c  **** 
  91:net_compat.c  **** //
  92:net_compat.c  **** 
  93:net_compat.c  **** void et_popblob( uint8_t * data, uint8_t len )
GAS LISTING /tmp/ccCeDQZH.s 			page 7


  94:net_compat.c  **** {
 348               	.LM26:
 349               	.LFBB4:
 350               	/* prologue: function */
 351               	/* frame size = 0 */
 352               	/* stack size = 0 */
 353               	.L__stack_usage = 0
 354               	.L30:
  95:net_compat.c  **** 	while( len-- )
 356               	.LM27:
 357 00c8 6150      		subi r22,1
 358 00ca 00F0      		brcs .L32
 359               	.LBB10:
 360               	.LBB11:
 362               	.Ltext3:
  46:net_compat.h  **** static inline uint8_t et_pop8() { return ETbuffer[ETsendplace++]; }
 364               	.LM28:
 365 00cc 2091 0000 		lds r18,ETsendplace
 366 00d0 3091 0000 		lds r19,ETsendplace+1
 367 00d4 A901      		movw r20,r18
 368 00d6 4F5F      		subi r20,-1
 369 00d8 5F4F      		sbci r21,-1
 370 00da 5093 0000 		sts ETsendplace+1,r21
 371 00de 4093 0000 		sts ETsendplace,r20
 372 00e2 F901      		movw r30,r18
 373 00e4 E050      		subi r30,lo8(-(ETbuffer))
 374 00e6 F040      		sbci r31,hi8(-(ETbuffer))
 375 00e8 2081      		ld r18,Z
 376               	.LBE11:
 377               	.LBE10:
 379               	.Ltext4:
  96:net_compat.c  **** 	{
  97:net_compat.c  **** 		*(data++) = et_pop8();
 381               	.LM29:
 382 00ea FC01      		movw r30,r24
 383 00ec 2193      		st Z+,r18
 384 00ee CF01      		movw r24,r30
 385 00f0 00C0      		rjmp .L30
 386               	.L32:
 387               	/* epilogue start */
  98:net_compat.c  **** 	}
  99:net_compat.c  **** }
 389               	.LM30:
 390 00f2 0895      		ret
 392               	.Lscope4:
 394               		.stabd	78,0,0
 397               	.global	et_pushpgmstr
 399               	et_pushpgmstr:
 400               		.stabd	46,0,0
 100:net_compat.c  **** 
 101:net_compat.c  **** void et_pushpgmstr( const char * msg )
 102:net_compat.c  **** {
 402               	.LM31:
 403               	.LFBB5:
 404 00f4 CF93      		push r28
 405 00f6 DF93      		push r29
 406               	/* prologue: function */
GAS LISTING /tmp/ccCeDQZH.s 			page 8


 407               	/* frame size = 0 */
 408               	/* stack size = 2 */
 409               	.L__stack_usage = 2
 410 00f8 FC01      		movw r30,r24
 411               	.L35:
 412               	.LBB12:
 103:net_compat.c  **** 	uint8_t r;
 104:net_compat.c  **** 	do
 105:net_compat.c  **** 	{
 106:net_compat.c  **** 		r = pgm_read_byte(msg++);
 414               	.LM32:
 415               	/* #APP */
 416               	 ;  106 "net_compat.c" 1
 417 00fa 8491      		lpm r24, Z
 418               		
 419               	 ;  0 "" 2
 420               	/* #NOAPP */
 421 00fc EF01      		movw r28,r30
 422 00fe 2196      		adiw r28,1
 423               	.LBE12:
 107:net_compat.c  **** 		if( !r ) break;
 425               	.LM33:
 426 0100 8823      		tst r24
 427 0102 01F0      		breq .L33
 108:net_compat.c  **** 		et_push8( r );
 429               	.LM34:
 430 0104 00D0      		rcall et_push8
 431 0106 FE01      		movw r30,r28
 109:net_compat.c  **** 	} while( 1 );
 433               	.LM35:
 434 0108 00C0      		rjmp .L35
 435               	.L33:
 436               	/* epilogue start */
 110:net_compat.c  **** }
 438               	.LM36:
 439 010a DF91      		pop r29
 440 010c CF91      		pop r28
 441 010e 0895      		ret
 446               	.Lscope5:
 448               		.stabd	78,0,0
 451               	.global	et_pushpgmblob
 453               	et_pushpgmblob:
 454               		.stabd	46,0,0
 111:net_compat.c  **** 
 112:net_compat.c  **** void et_pushpgmblob( const uint8_t * data, uint8_t len )
 113:net_compat.c  **** {
 456               	.LM37:
 457               	.LFBB6:
 458 0110 0F93      		push r16
 459 0112 1F93      		push r17
 460 0114 CF93      		push r28
 461 0116 DF93      		push r29
 462 0118 1F92      		push __zero_reg__
 463 011a CDB7      		in r28,__SP_L__
 464 011c DEB7      		in r29,__SP_H__
 465               	/* prologue: function */
 466               	/* frame size = 1 */
GAS LISTING /tmp/ccCeDQZH.s 			page 9


 467               	/* stack size = 5 */
 468               	.L__stack_usage = 5
 114:net_compat.c  **** 	while( len-- )
 470               	.LM38:
 471 011e 8C01      		movw r16,r24
 472 0120 680F      		add r22,r24
 473               	.L37:
 475               	.LM39:
 476 0122 6017      		cp r22,r16
 477 0124 01F0      		breq .L39
 478               	.LBB13:
 115:net_compat.c  **** 	{
 116:net_compat.c  **** 		et_push8( pgm_read_byte(data++) );
 480               	.LM40:
 481 0126 F801      		movw r30,r16
 482               	/* #APP */
 483               	 ;  116 "net_compat.c" 1
 484 0128 8491      		lpm r24, Z
 485               		
 486               	 ;  0 "" 2
 487               	/* #NOAPP */
 488               	.LBE13:
 489 012a 6983      		std Y+1,r22
 490 012c 00D0      		rcall et_push8
 491 012e 0F5F      		subi r16,-1
 492 0130 1F4F      		sbci r17,-1
 493 0132 6981      		ldd r22,Y+1
 494 0134 00C0      		rjmp .L37
 495               	.L39:
 496               	/* epilogue start */
 117:net_compat.c  **** 	}
 118:net_compat.c  **** }
 498               	.LM41:
 499 0136 0F90      		pop __tmp_reg__
 500 0138 DF91      		pop r29
 501 013a CF91      		pop r28
 502 013c 1F91      		pop r17
 503 013e 0F91      		pop r16
 504 0140 0895      		ret
 509               	.Lscope6:
 511               		.stabd	78,0,0
 514               	.global	et_pushstr
 516               	et_pushstr:
 517               		.stabd	46,0,0
 119:net_compat.c  **** 
 120:net_compat.c  **** 
 121:net_compat.c  **** void et_pushstr( const char * msg )
 122:net_compat.c  **** {
 519               	.LM42:
 520               	.LFBB7:
 521 0142 CF93      		push r28
 522 0144 DF93      		push r29
 523               	/* prologue: function */
 524               	/* frame size = 0 */
 525               	/* stack size = 2 */
 526               	.L__stack_usage = 2
 527 0146 EC01      		movw r28,r24
GAS LISTING /tmp/ccCeDQZH.s 			page 10


 528               	.L41:
 123:net_compat.c  **** 	for( ; *msg; msg++ ) 
 530               	.LM43:
 531 0148 8991      		ld r24,Y+
 532 014a 8823      		tst r24
 533 014c 01F0      		breq .L43
 124:net_compat.c  **** 		et_push8( *msg );
 535               	.LM44:
 536 014e 00D0      		rcall et_push8
 537 0150 00C0      		rjmp .L41
 538               	.L43:
 539               	/* epilogue start */
 125:net_compat.c  **** }
 541               	.LM45:
 542 0152 DF91      		pop r29
 543 0154 CF91      		pop r28
 544 0156 0895      		ret
 546               	.Lscope7:
 548               		.stabd	78,0,0
 551               	.global	et_pushblob
 553               	et_pushblob:
 554               		.stabd	46,0,0
 126:net_compat.c  **** 
 127:net_compat.c  **** void et_pushblob( const uint8_t * data, uint8_t len )
 128:net_compat.c  **** {
 556               	.LM46:
 557               	.LFBB8:
 558 0158 0F93      		push r16
 559 015a 1F93      		push r17
 560 015c CF93      		push r28
 561 015e DF93      		push r29
 562 0160 1F92      		push __zero_reg__
 563 0162 CDB7      		in r28,__SP_L__
 564 0164 DEB7      		in r29,__SP_H__
 565               	/* prologue: function */
 566               	/* frame size = 1 */
 567               	/* stack size = 5 */
 568               	.L__stack_usage = 5
 129:net_compat.c  **** 	while( len-- )
 570               	.LM47:
 571 0166 8C01      		movw r16,r24
 572 0168 680F      		add r22,r24
 573               	.L45:
 575               	.LM48:
 576 016a 6017      		cp r22,r16
 577 016c 01F0      		breq .L47
 130:net_compat.c  **** 	{
 131:net_compat.c  **** 		et_push8( *(data++) );
 579               	.LM49:
 580 016e F801      		movw r30,r16
 581 0170 8191      		ld r24,Z+
 582 0172 8F01      		movw r16,r30
 583 0174 6983      		std Y+1,r22
 584 0176 00D0      		rcall et_push8
 585 0178 6981      		ldd r22,Y+1
 586 017a 00C0      		rjmp .L45
 587               	.L47:
GAS LISTING /tmp/ccCeDQZH.s 			page 11


 588               	/* epilogue start */
 132:net_compat.c  **** 	}
 133:net_compat.c  **** }
 590               	.LM50:
 591 017c 0F90      		pop __tmp_reg__
 592 017e DF91      		pop r29
 593 0180 CF91      		pop r28
 594 0182 1F91      		pop r17
 595 0184 0F91      		pop r16
 596 0186 0895      		ret
 598               	.Lscope8:
 600               		.stabd	78,0,0
 603               	.global	et_init
 605               	et_init:
 606               		.stabd	46,0,0
 134:net_compat.c  **** 
 135:net_compat.c  **** 
 136:net_compat.c  **** //return 0 if OK, otherwise nonzero.
 137:net_compat.c  **** int8_t et_init( const unsigned char * macaddy )
 138:net_compat.c  **** {
 608               	.LM51:
 609               	.LFBB9:
 610               	/* prologue: function */
 611               	/* frame size = 0 */
 612               	/* stack size = 0 */
 613               	.L__stack_usage = 0
 614 0188 FC01      		movw r30,r24
 139:net_compat.c  **** 	MyMAC[0] = macaddy[0];
 616               	.LM52:
 617 018a 8081      		ld r24,Z
 618 018c 8093 0000 		sts MyMAC,r24
 140:net_compat.c  **** 	MyMAC[1] = macaddy[1];
 620               	.LM53:
 621 0190 8181      		ldd r24,Z+1
 622 0192 8093 0000 		sts MyMAC+1,r24
 141:net_compat.c  **** 	MyMAC[2] = macaddy[2];
 624               	.LM54:
 625 0196 8281      		ldd r24,Z+2
 626 0198 8093 0000 		sts MyMAC+2,r24
 142:net_compat.c  **** 	MyMAC[3] = macaddy[3];
 628               	.LM55:
 629 019c 8381      		ldd r24,Z+3
 630 019e 8093 0000 		sts MyMAC+3,r24
 143:net_compat.c  **** 	MyMAC[4] = macaddy[4];
 632               	.LM56:
 633 01a2 8481      		ldd r24,Z+4
 634 01a4 8093 0000 		sts MyMAC+4,r24
 144:net_compat.c  **** 	MyMAC[5] = macaddy[5];
 636               	.LM57:
 637 01a8 8581      		ldd r24,Z+5
 638 01aa 8093 0000 		sts MyMAC+5,r24
 145:net_compat.c  **** 
 146:net_compat.c  **** 	PLLCSR = _BV(PLLE) | _BV( PCKE );
 640               	.LM58:
 641 01ae 86E0      		ldi r24,lo8(6)
 642 01b0 87BD      		out 0x27,r24
 147:net_compat.c  **** 	PLLCSR |= _BV(LSM);
GAS LISTING /tmp/ccCeDQZH.s 			page 12


 644               	.LM59:
 645 01b2 87B5      		in r24,0x27
 646 01b4 8068      		ori r24,lo8(-128)
 647 01b6 87BD      		out 0x27,r24
 148:net_compat.c  **** 	OSCCAL = OSC20;
 649               	.LM60:
 650 01b8 86EB      		ldi r24,lo8(-74)
 651 01ba 81BF      		out 0x31,r24
 149:net_compat.c  **** 
 150:net_compat.c  **** 
 151:net_compat.c  **** 	//Setup timer 0 to speed along.
 152:net_compat.c  **** 	//Yes, this means you can't use it.
 153:net_compat.c  **** 	TCCR0A = _BV(WGM01);
 653               	.LM61:
 654 01bc 82E0      		ldi r24,lo8(2)
 655 01be 8ABD      		out 0x2a,r24
 154:net_compat.c  **** 	TCCR0B = _BV(CS00);
 657               	.LM62:
 658 01c0 81E0      		ldi r24,lo8(1)
 659 01c2 83BF      		out 0x33,r24
 155:net_compat.c  **** 	OCR0A = 0;
 661               	.LM63:
 662 01c4 19BC      		out 0x29,__zero_reg__
 156:net_compat.c  **** 
 157:net_compat.c  **** 	USICR = _BV(USIWM0) | _BV(USICS0) | _BV(USITC);
 664               	.LM64:
 665 01c6 85E1      		ldi r24,lo8(21)
 666 01c8 8DB9      		out 0xd,r24
 158:net_compat.c  **** 
 159:net_compat.c  **** 	//setup port B
 160:net_compat.c  **** 
 161:net_compat.c  **** 	PORTB &= ~_BV(0); 
 668               	.LM65:
 669 01ca C098      		cbi 0x18,0
 162:net_compat.c  **** 	DDRB &= ~_BV(0);
 671               	.LM66:
 672 01cc B898      		cbi 0x17,0
 163:net_compat.c  **** 	PORTB &= ~_BV(1);
 674               	.LM67:
 675 01ce C198      		cbi 0x18,1
 164:net_compat.c  **** 	USICR &= ~_BV(USIWM0);  //Disable USICR
 677               	.LM68:
 678 01d0 6C98      		cbi 0xd,4
 165:net_compat.c  **** 
 166:net_compat.c  **** }
 680               	.LM69:
 681 01d2 0895      		ret
 683               	.Lscope9:
 685               		.stabd	78,0,0
 689               	.global	et_xmitpacket
 691               	et_xmitpacket:
 692               		.stabd	46,0,0
 167:net_compat.c  **** 
 168:net_compat.c  **** int8_t et_xmitpacket( uint16_t start, uint16_t len )
 169:net_compat.c  **** {
 694               	.LM70:
 695               	.LFBB10:
GAS LISTING /tmp/ccCeDQZH.s 			page 13


 696               	/* prologue: function */
 697               	/* frame size = 0 */
 698               	/* stack size = 0 */
 699               	.L__stack_usage = 0
 170:net_compat.c  **** 	//XXX !!! TODO
 171:net_compat.c  **** }
 701               	.LM71:
 702 01d4 0895      		ret
 704               	.Lscope10:
 706               		.stabd	78,0,0
 708               	.global	et_recvpack
 710               	et_recvpack:
 711               		.stabd	46,0,0
 172:net_compat.c  **** 
 173:net_compat.c  **** //This waits for 8ms, sends an autoneg notice, then waits for 8 more ms.
 174:net_compat.c  **** unsigned short et_recvpack()
 175:net_compat.c  **** {
 713               	.LM72:
 714               	.LFBB11:
 715               	/* prologue: function */
 716               	/* frame size = 0 */
 717               	/* stack size = 0 */
 718               	.L__stack_usage = 0
 176:net_compat.c  **** 
 177:net_compat.c  **** #define LIMITSIZE  sizeof( ETbuffer )/2-30
 178:net_compat.c  **** //#define LIMITSIZE 10
 179:net_compat.c  **** 
 180:net_compat.c  **** 		waitforpacket(&ETbuffer[PREAMBLE+40], LIMITSIZE, 20000); //wait for 2048 cycles (30MHz/8 = 3.75MH
 720               	.LM73:
 721 01d6 40E2      		ldi r20,lo8(32)
 722 01d8 5EE4      		ldi r21,lo8(78)
 723 01da 64E8      		ldi r22,lo8(-124)
 724 01dc 70E0      		ldi r23,0
 725 01de 80E0      		ldi r24,lo8(ETbuffer+48)
 726 01e0 90E0      		ldi r25,hi8(ETbuffer+48)
 727 01e2 00D0      		rcall waitforpacket
 181:net_compat.c  **** //		_delay_ms(8);
 182:net_compat.c  **** #ifdef SMARTPWR
 183:net_compat.c  **** 		DDRB |= _BV(1);
 184:net_compat.c  **** #endif
 185:net_compat.c  **** 		PORTB|=_BV(1);
 729               	.LM74:
 730 01e4 C19A      		sbi 0x18,1
 186:net_compat.c  **** 		NOOP;
 732               	.LM75:
 733               	/* #APP */
 734               	 ;  186 "net_compat.c" 1
 735 01e6 0000      		nop
 736               	 ;  0 "" 2
 187:net_compat.c  **** 		PORTB &=~_BV(1);
 738               	.LM76:
 739               	/* #NOAPP */
 740 01e8 C198      		cbi 0x18,1
 188:net_compat.c  **** #ifdef SMARTPWR
 189:net_compat.c  **** 		DDRB &= ~_BV(1);
 190:net_compat.c  **** #endif
 191:net_compat.c  **** 		waitforpacket(&ETbuffer[PREAMBLE+40], LIMITSIZE, 20000); //wait for 2048  (30MHz/8 = 3.75MHz / 30
GAS LISTING /tmp/ccCeDQZH.s 			page 14


 742               	.LM77:
 743 01ea 40E2      		ldi r20,lo8(32)
 744 01ec 5EE4      		ldi r21,lo8(78)
 745 01ee 64E8      		ldi r22,lo8(-124)
 746 01f0 70E0      		ldi r23,0
 747 01f2 80E0      		ldi r24,lo8(ETbuffer+48)
 748 01f4 90E0      		ldi r25,hi8(ETbuffer+48)
 749 01f6 00D0      		rcall waitforpacket
 192:net_compat.c  **** // 		_delay_ms(8);
 193:net_compat.c  **** 
 194:net_compat.c  **** }
 751               	.LM78:
 752 01f8 0895      		ret
 754               	.Lscope11:
 756               		.stabd	78,0,0
 760               	.global	et_start_checksum
 762               	et_start_checksum:
 763               		.stabd	46,0,0
 195:net_compat.c  **** 
 196:net_compat.c  **** void et_start_checksum( uint16_t start, uint16_t len )
 197:net_compat.c  **** {
 765               	.LM79:
 766               	.LFBB12:
 767               	/* prologue: function */
 768               	/* frame size = 0 */
 769               	/* stack size = 0 */
 770               	.L__stack_usage = 0
 771 01fa 0895      		ret
 773               	.Lscope12:
 775               		.stabd	78,0,0
 782               	.global	et_copy_memory
 784               	et_copy_memory:
 785               		.stabd	46,0,0
 198:net_compat.c  **** 	//XXX !!! TODO
 199:net_compat.c  **** }
 200:net_compat.c  **** 
 201:net_compat.c  **** void et_copy_memory( uint16_t to, uint16_t from, uint16_t length, uint16_t range_start, uint16_t ra
 202:net_compat.c  **** {
 787               	.LM80:
 788               	.LFBB13:
 789               	/* prologue: function */
 790               	/* frame size = 0 */
 791               	/* stack size = 0 */
 792               	.L__stack_usage = 0
 793 01fc 0895      		ret
 795               	.Lscope13:
 797               		.stabd	78,0,0
 798               	.global	ManchesterTable
 799               		.data
 800               		.p2align	4
 803               	ManchesterTable:
 804 0000 AA        		.byte	-86
 805 0001 6A        		.byte	106
 806 0002 9A        		.byte	-102
 807 0003 5A        		.byte	90
 808 0004 A6        		.byte	-90
 809 0005 66        		.byte	102
GAS LISTING /tmp/ccCeDQZH.s 			page 15


 810 0006 96        		.byte	-106
 811 0007 56        		.byte	86
 812 0008 A9        		.byte	-87
 813 0009 69        		.byte	105
 814 000a 99        		.byte	-103
 815 000b 59        		.byte	89
 816 000c A5        		.byte	-91
 817 000d 65        		.byte	101
 818 000e 95        		.byte	-107
 819 000f 55        		.byte	85
 820               		.comm	ETchecksum,2,1
 821               		.comm	sendbaseaddress,2,1
 822               		.comm	ETsendplace,2,1
 823               		.comm	ETbuffer,324,1
 824               		.comm	MyMAC,6,1
 831               		.text
 833               	.Letext0:
 834               		.ident	"GCC: (GNU) 4.8.2"
 835               	.global __do_copy_data
 836               	.global __do_clear_bss
GAS LISTING /tmp/ccCeDQZH.s 			page 16


DEFINED SYMBOLS
                            *ABS*:0000000000000000 net_compat.c
     /tmp/ccCeDQZH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccCeDQZH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccCeDQZH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccCeDQZH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccCeDQZH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccCeDQZH.s:110    .text:0000000000000000 et_push8
                            *COM*:0000000000000002 ETsendplace
                            *COM*:0000000000000144 ETbuffer
     /tmp/ccCeDQZH.s:145    .text:0000000000000020 GotPack
     /tmp/ccCeDQZH.s:170    .text:0000000000000024 waitforpacket
     /tmp/ccCeDQZH.s:345    .text:00000000000000c8 et_popblob
     /tmp/ccCeDQZH.s:399    .text:00000000000000f4 et_pushpgmstr
     /tmp/ccCeDQZH.s:453    .text:0000000000000110 et_pushpgmblob
     /tmp/ccCeDQZH.s:516    .text:0000000000000142 et_pushstr
     /tmp/ccCeDQZH.s:553    .text:0000000000000158 et_pushblob
     /tmp/ccCeDQZH.s:605    .text:0000000000000188 et_init
                            *COM*:0000000000000006 MyMAC
     /tmp/ccCeDQZH.s:691    .text:00000000000001d4 et_xmitpacket
     /tmp/ccCeDQZH.s:710    .text:00000000000001d6 et_recvpack
     /tmp/ccCeDQZH.s:762    .text:00000000000001fa et_start_checksum
     /tmp/ccCeDQZH.s:784    .text:00000000000001fc et_copy_memory
     /tmp/ccCeDQZH.s:803    .data:0000000000000000 ManchesterTable
                            *COM*:0000000000000002 ETchecksum
                            *COM*:0000000000000002 sendbaseaddress

UNDEFINED SYMBOLS
Demanchestrate
MaybeHaveDataASM
__do_copy_data
__do_clear_bss
