GAS LISTING /tmp/cc4LkRLk.s 			page 1


   1               		.file	"test.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 114               	.global	delay_ms
 116               	delay_ms:
 117               		.stabd	46,0,0
   1:test.c        **** /*
   2:test.c        **** 
   3:test.c        **** 	WARNING: Connecting an AVR to ethernet without magnetics is VERY DANGEROUS.
   4:test.c        **** 	It may cause high voltages to go through the AVR and destroy it in DANGEROUS
   5:test.c        **** 	that may harm personal safety.  Do only at your own risk.
   6:test.c        **** 
   7:test.c        **** */
   8:test.c        **** 
   9:test.c        **** /*
  10:test.c        ****     Copyright (C) 2014 <>< Charles Lohr
  11:test.c        **** 
  12:test.c        **** 
  13:test.c        ****     Permission is hereby granted, free of charge, to any person obtaining a
  14:test.c        **** 	copy of this software and associated documentation files (the "Software"),
  15:test.c        **** 	to deal in the Software without restriction, including without limitation
  16:test.c        **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  17:test.c        **** 	and/or sell copies of the Software, and to permit persons to whom the
  18:test.c        **** 	Software is furnished to do so, subject to the following conditions:
  19:test.c        **** 
  20:test.c        ****     The above copyright notice and this permission notice shall be included
  21:test.c        **** 	in all copies or substantial portions of the Software.
  22:test.c        **** 
  23:test.c        ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  24:test.c        **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  25:test.c        **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  26:test.c        **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  27:test.c        **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  28:test.c        **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  29:test.c        **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  30:test.c        **** */
  31:test.c        **** 
  32:test.c        **** 
  33:test.c        **** #include <avr/io.h>
  34:test.c        **** #include <avr/interrupt.h>
  35:test.c        **** #include <avr/sleep.h>
  36:test.c        **** #include <util/delay.h>
  37:test.c        **** 
  38:test.c        **** #include "sendpack.h"
  39:test.c        **** #include "packetmater.h"
  40:test.c        **** 
  41:test.c        **** void delay_ms(uint32_t time) {
 119               	.LM0:
 120               	.LFBB1:
 121 0000 0F93      		push r16
 122 0002 1F93      		push r17
 123               	/* prologue: function */
GAS LISTING /tmp/cc4LkRLk.s 			page 2


 124               	/* frame size = 0 */
 125               	/* stack size = 2 */
 126               	.L__stack_usage = 2
  42:test.c        ****   uint32_t i;
  43:test.c        ****   for (i = 0; i < time; i++) {
 128               	.LM1:
 129 0004 00E0      		ldi r16,0
 130 0006 10E0      		ldi r17,0
 131 0008 9801      		movw r18,r16
 132               	.L2:
 134               	.LM2:
 135 000a 0617      		cp r16,r22
 136 000c 1707      		cpc r17,r23
 137 000e 2807      		cpc r18,r24
 138 0010 3907      		cpc r19,r25
 139 0012 01F0      		breq .L5
 140               	.LBB4:
 141               	.LBB5:
 143               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
GAS LISTING /tmp/cc4LkRLk.s 			page 3


  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
GAS LISTING /tmp/cc4LkRLk.s 			page 4


  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/cc4LkRLk.s 			page 5


 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 145               	.LM3:
 146 0014 E7E8      		ldi r30,lo8(4999)
 147 0016 F3E1      		ldi r31,hi8(4999)
 148 0018 3197      		1: sbiw r30,1
 149 001a 01F4      		brne 1b
 150 001c 00C0      		rjmp .
 151 001e 0000      		nop
 152               	.LBE5:
 153               	.LBE4:
 155               	.Ltext2:
 157               	.LM4:
 158 0020 0F5F      		subi r16,-1
 159 0022 1F4F      		sbci r17,-1
 160 0024 2F4F      		sbci r18,-1
 161 0026 3F4F      		sbci r19,-1
 162 0028 00C0      		rjmp .L2
 163               	.L5:
 164               	/* epilogue start */
  44:test.c        ****     _delay_ms(1);
  45:test.c        ****   }
  46:test.c        **** }
 166               	.LM5:
 167 002a 1F91      		pop r17
 168 002c 0F91      		pop r16
 169 002e 0895      		ret
 174               	.Lscope1:
 176               		.stabd	78,0,0
 180               	.global	waitforpacket
 182               	waitforpacket:
 183               		.stabd	46,0,0
  47:test.c        **** 
  48:test.c        **** #define NOOP asm volatile("nop" ::)
  49:test.c        **** 
  50:test.c        **** #define OSC20 0xB7
  51:test.c        **** #define OSCHIGH 0xFF
  52:test.c        **** 
  53:test.c        **** static void setup_clock( void )
  54:test.c        **** {
  55:test.c        **** 	/*Examine Page 33*/
  56:test.c        **** 
  57:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
  58:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
  59:test.c        **** 
  60:test.c        **** 
  61:test.c        **** 	PLLCSR = _BV(PLLE) | _BV( PCKE );
GAS LISTING /tmp/cc4LkRLk.s 			page 6


  62:test.c        **** 	PLLCSR |= _BV(LSM);
  63:test.c        **** 	OSCCAL = OSC20;
  64:test.c        **** 
  65:test.c        **** }
  66:test.c        **** 
  67:test.c        **** #define SMARTPWR
  68:test.c        **** 
  69:test.c        **** //Inverting the manchester seems to universally make things worse.
  70:test.c        **** //#define INVERT_MANCHESTER
  71:test.c        **** 
  72:test.c        **** #ifndef INVERT_MANCHESTER
  73:test.c        **** //Do not split this across byte-addressing boundaries.
  74:test.c        **** char ManchesterTable[16] __attribute__ ((aligned (16))) = {
  75:test.c        **** 	0b10101010, 0b01101010, 0b10011010, 0b01011010,
  76:test.c        **** 	0b10100110, 0b01100110, 0b10010110, 0b01010110,
  77:test.c        **** 	0b10101001, 0b01101001, 0b10011001, 0b01011001,
  78:test.c        **** 	0b10100101, 0b01100101, 0b10010101, 0b01010101,
  79:test.c        **** };
  80:test.c        **** #else
  81:test.c        **** //Inverted
  82:test.c        **** char ManchesterTable[16] __attribute__ ((aligned (16))) = {
  83:test.c        **** 	0b01010101, 0b10010101, 0b01100101, 0b10100101,
  84:test.c        **** 	0b01011001, 0b10011001, 0b01101001, 0b10101001,
  85:test.c        **** 	0b01010110, 0b10010110, 0b01100110, 0b10100110,
  86:test.c        **** 	0b01011010, 0b10011010, 0b01101010, 0b10101010,
  87:test.c        **** };
  88:test.c        **** #endif
  89:test.c        **** /*
  90:test.c        **** //Debug
  91:test.c        **** char ManchesterTableDEBUG[16] __attribute__ ((aligned (16))) = {
  92:test.c        **** 	0b00000000, 0b11000000, 0b00110000, 0b11110000,
  93:test.c        **** 	0b00001100, 0b11001100, 0b00111100, 0b11111100,
  94:test.c        **** 	0b00000011, 0b11000011, 0b00110011, 0b11110011,
  95:test.c        **** 	0b00001111, 0b11001111, 0b00111111, 0b11111111,
  96:test.c        **** };
  97:test.c        **** */
  98:test.c        **** unsigned char sendbuffer[370];
  99:test.c        **** 
 100:test.c        **** void SendTestASM( const unsigned char * c, uint8_t len );
 101:test.c        **** void MaybeHaveDataASM( unsigned char * c, uint8_t len );
 102:test.c        **** /*
 103:test.c        **** void MaybeHaveDataTest( unsigned char * c, uint8_t lenX2 ) //LenX2 = 128->256, i.e. put in half the
 104:test.c        **** {
 105:test.c        **** 	while( lenX2-- )
 106:test.c        **** 	{
 107:test.c        **** 		*(c++) = USIBR;
 108:test.c        **** 		*(c++) = USIBR;
 109:test.c        **** 	}
 110:test.c        **** }*/
 111:test.c        **** 
 112:test.c        **** void waitforpacket( unsigned char * buffer, uint16_t len, uint16_t ltime )
 113:test.c        **** {
 185               	.LM6:
 186               	.LFBB2:
 187 0030 FF92      		push r15
 188 0032 0F93      		push r16
 189 0034 1F93      		push r17
GAS LISTING /tmp/cc4LkRLk.s 			page 7


 190 0036 CF93      		push r28
 191 0038 DF93      		push r29
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 5 */
 195               	.L__stack_usage = 5
 196 003a 8C01      		movw r16,r24
 197 003c F62E      		mov r15,r22
 114:test.c        **** 		OSCCAL = OSCHIGH;
 199               	.LM7:
 200 003e 8FEF      		ldi r24,lo8(-1)
 201 0040 81BF      		out 0x31,r24
 115:test.c        **** 
 116:test.c        **** 	//Make sure we're not walking in on something.
 117:test.c        **** 	while( ltime-- )
 203               	.LM8:
 204 0042 4150      		subi r20,1
 205 0044 5109      		sbc r21,__zero_reg__
 206               	.L7:
 208               	.LM9:
 209 0046 4F3F      		cpi r20,-1
 210 0048 8FEF      		ldi r24,-1
 211 004a 5807      		cpc r21,r24
 212 004c 01F0      		breq .L8
 118:test.c        **** 	{
 119:test.c        **** 		if( USIBR == 0x00 ) break;
 214               	.LM10:
 215 004e 80B3      		in r24,0x10
 216 0050 8823      		tst r24
 217 0052 01F0      		breq .L8
 120:test.c        **** 		if( USIBR == 0xFF ) break;
 219               	.LM11:
 220 0054 20B3      		in r18,0x10
 221 0056 CA01      		movw r24,r20
 222 0058 0197      		sbiw r24,1
 223 005a 2F3F      		cpi r18,lo8(-1)
 224 005c 01F0      		breq .L8
 121:test.c        **** 		NOOP;
 226               	.LM12:
 227               	/* #APP */
 228               	 ;  121 "test.c" 1
 229 005e 0000      		nop
 230               	 ;  0 "" 2
 122:test.c        **** 		NOOP;
 232               	.LM13:
 233               	 ;  122 "test.c" 1
 234 0060 0000      		nop
 235               	 ;  0 "" 2
 123:test.c        **** 		NOOP;
 237               	.LM14:
 238               	 ;  123 "test.c" 1
 239 0062 0000      		nop
 240               	 ;  0 "" 2
 241               	/* #NOAPP */
 242 0064 AC01      		movw r20,r24
 243 0066 00C0      		rjmp .L7
 244               	.L8:
GAS LISTING /tmp/cc4LkRLk.s 			page 8


 117:test.c        **** 	while( ltime-- )
 246               	.LM15:
 247 0068 EA01      		movw r28,r20
 248               	.L10:
 124:test.c        **** 	}
 125:test.c        **** 
 126:test.c        **** 
 127:test.c        **** 	while( ltime-- )
 250               	.LM16:
 251 006a 2097      		sbiw r28,0
 252 006c 01F0      		breq .L25
 128:test.c        **** 	{
 129:test.c        **** 		if( USIBR && (USIBR != 0xFF ) )
 254               	.LM17:
 255 006e 80B3      		in r24,0x10
 256 0070 8823      		tst r24
 257 0072 01F0      		breq .L11
 259               	.LM18:
 260 0074 80B3      		in r24,0x10
 261 0076 8F3F      		cpi r24,lo8(-1)
 262 0078 01F0      		breq .L11
 130:test.c        **** 		{
 131:test.c        **** 			MaybeHaveDataASM( buffer, len );
 264               	.LM19:
 265 007a 6F2D      		mov r22,r15
 266 007c C801      		movw r24,r16
 267 007e 00D0      		rcall MaybeHaveDataASM
 268               	.L11:
 269 0080 2197      		sbiw r28,1
 270 0082 00C0      		rjmp .L10
 271               	.L25:
 132:test.c        **** 		}
 133:test.c        **** //		NOOP;
 134:test.c        **** //		NOOP;
 135:test.c        **** //		NOOP;
 136:test.c        **** 	}
 137:test.c        **** 		OSCCAL = OSC20;
 273               	.LM20:
 274 0084 87EB      		ldi r24,lo8(-73)
 275 0086 81BF      		out 0x31,r24
 276               	/* epilogue start */
 138:test.c        **** }
 278               	.LM21:
 279 0088 DF91      		pop r29
 280 008a CF91      		pop r28
 281 008c 1F91      		pop r17
 282 008e 0F91      		pop r16
 283 0090 FF90      		pop r15
 284 0092 0895      		ret
 286               	.Lscope2:
 288               		.stabd	78,0,0
 289               		.section	.text.startup,"ax",@progbits
 291               	.global	main
 293               	main:
 294               		.stabd	46,0,0
 139:test.c        **** 
 140:test.c        **** 
GAS LISTING /tmp/cc4LkRLk.s 			page 9


 141:test.c        **** int main( )
 142:test.c        **** {
 296               	.LM22:
 297               	.LFBB3:
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 0 */
 301               	.L__stack_usage = 0
 143:test.c        **** 	int i;
 144:test.c        **** 	cli();
 303               	.LM23:
 304               	/* #APP */
 305               	 ;  144 "test.c" 1
 306 0000 F894      		cli
 307               	 ;  0 "" 2
 308               	/* #NOAPP */
 309               	.LBB10:
 310               	.LBB11:
  57:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
 312               	.LM24:
 313 0002 80E8      		ldi r24,lo8(-128)
 314 0004 86BD      		out 0x26,r24
  58:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
 316               	.LM25:
 317 0006 16BC      		out 0x26,__zero_reg__
  61:test.c        **** 	PLLCSR = _BV(PLLE) | _BV( PCKE );
 319               	.LM26:
 320 0008 86E0      		ldi r24,lo8(6)
 321 000a 87BD      		out 0x27,r24
  62:test.c        **** 	PLLCSR |= _BV(LSM);
 323               	.LM27:
 324 000c 87B5      		in r24,0x27
 325 000e 8068      		ori r24,lo8(-128)
 326 0010 87BD      		out 0x27,r24
  63:test.c        **** 	OSCCAL = OSC20;
 328               	.LM28:
 329 0012 87EB      		ldi r24,lo8(-73)
 330 0014 81BF      		out 0x31,r24
 331               	.LBE11:
 332               	.LBE10:
 145:test.c        **** 
 146:test.c        **** 	setup_clock();
 147:test.c        **** 
 148:test.c        **** 	DDRB = _BV(1);
 334               	.LM29:
 335 0016 82E0      		ldi r24,lo8(2)
 336 0018 87BB      		out 0x17,r24
 149:test.c        **** 
 150:test.c        **** 	//1st let's see how fast we can clock the pin.
 151:test.c        **** 
 152:test.c        **** 
 153:test.c        **** 	TCCR0A = _BV(WGM01);
 338               	.LM30:
 339 001a 8ABD      		out 0x2a,r24
 154:test.c        **** 	TCCR0B = _BV(CS00);
 341               	.LM31:
 342 001c 81E0      		ldi r24,lo8(1)
GAS LISTING /tmp/cc4LkRLk.s 			page 10


 343 001e 83BF      		out 0x33,r24
 155:test.c        **** 	OCR0A = 0;
 345               	.LM32:
 346 0020 19BC      		out 0x29,__zero_reg__
 156:test.c        **** 
 157:test.c        **** 	USICR = _BV(USIWM0) | _BV(USICS0) | _BV(USICLK) | _BV(USITC);
 348               	.LM33:
 349 0022 87E1      		ldi r24,lo8(23)
 350 0024 8DB9      		out 0xd,r24
 351 0026 80E0      		ldi r24,lo8(PacketA)
 352 0028 90E0      		ldi r25,hi8(PacketA)
 353 002a A0E0      		ldi r26,lo8(sendbuffer)
 354 002c B0E0      		ldi r27,hi8(sendbuffer)
 355               	.L28:
 356               	.LBB12:
 158:test.c        **** 
 159:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
 160:test.c        **** 	{
 161:test.c        **** 		sendbuffer[i] = pgm_read_word( &PacketA[i] );
 358               	.LM34:
 359 002e FC01      		movw r30,r24
 360               	/* #APP */
 361               	 ;  161 "test.c" 1
 362 0030 2591      		lpm r18, Z+
 363 0032 3491      		lpm r19, Z
 364               		
 365               	 ;  0 "" 2
 366               	/* #NOAPP */
 367               	.LBE12:
 368 0034 2D93      		st X+,r18
 369 0036 0196      		adiw r24,1
 159:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
 371               	.LM35:
 372 0038 20E0      		ldi r18,hi8(PacketA+76)
 373 003a 8030      		cpi r24,lo8(PacketA+76)
 374 003c 9207      		cpc r25,r18
 375 003e 01F4      		brne .L28
 162:test.c        **** 	}
 163:test.c        **** 
 164:test.c        **** 	i = 0;
 165:test.c        **** 
 166:test.c        **** 	int frame = 0;
 167:test.c        **** 
 168:test.c        **** 	struct EthernetPacket * sbe = (struct EthernetPacket*)sendbuffer;
 169:test.c        **** 
 170:test.c        **** 	//??? I have no idea why this makes everyhting much more rubust.
 171:test.c        **** 	PORTB |= _BV(0);
 377               	.LM36:
 378 0040 C09A      		sbi 0x18,0
 172:test.c        **** 
 173:test.c        **** 	while(1)
 174:test.c        **** 	{
 175:test.c        **** 	//	SendTestASM( sendbuffer, PacketABytes/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
 176:test.c        **** 	//	continue;
 177:test.c        **** 
 178:test.c        **** 		waitforpacket(sbe->payload, sizeof( sendbuffer )/2-25, 30000); //wait for 2048 cycles (30MHz/8 = 
 179:test.c        **** //		_delay_ms(8);
GAS LISTING /tmp/cc4LkRLk.s 			page 11


 180:test.c        **** #ifdef SMARTPWR
 181:test.c        **** 		DDRB |= _BV(1);
 182:test.c        **** #endif
 183:test.c        **** 		USIDR = 0x07;
 380               	.LM37:
 381 0042 17E0      		ldi r17,lo8(7)
 382               	.LBB13:
 184:test.c        **** #ifdef SMARTPWR
 185:test.c        **** 		DDRB &= ~_BV(1);
 186:test.c        **** #endif
 187:test.c        **** 		waitforpacket(sbe->payload, sizeof( sendbuffer )/2-25, 30000); //wait for 2048  (30MHz/8 = 3.75MH
 188:test.c        **** 		//_delay_ms(8);
 189:test.c        **** 
 190:test.c        **** 			i++;
 191:test.c        **** 
 192:test.c        **** 		if( i == 20 )
 193:test.c        **** 		{
 194:test.c        **** #ifdef SMARTPWR
 195:test.c        **** 			DDRB |= _BV(1);
 196:test.c        **** #endif
 197:test.c        **** 
 198:test.c        **** 			//UDP Data starts at byte #50
 199:test.c        **** 			struct EthernetPacket * sbe = (struct EthernetPacket*)sendbuffer;
 200:test.c        **** //			sbe->payload[0] = 0xBB;
 201:test.c        **** //			sbe->payload[1] = frame++;
 202:test.c        **** 			sbe->addyfrom = 0x450a000a;
 384               	.LM38:
 385 0044 9AE0      		ldi r25,lo8(10)
 386 0046 C92E      		mov r12,r25
 387 0048 D12C      		mov r13,__zero_reg__
 388 004a EC2C      		mov r14,r12
 389 004c 95E4      		ldi r25,lo8(69)
 390 004e F92E      		mov r15,r25
 391               	.L32:
 392               	.LBE13:
 142:test.c        **** {
 394               	.LM39:
 395 0050 C4E1      		ldi r28,lo8(20)
 396 0052 D0E0      		ldi r29,0
 397               	.L30:
 178:test.c        **** 		waitforpacket(sbe->payload, sizeof( sendbuffer )/2-25, 30000); //wait for 2048 cycles (30MHz/8 = 
 399               	.LM40:
 400 0054 40E3      		ldi r20,lo8(48)
 401 0056 55E7      		ldi r21,lo8(117)
 402 0058 60EA      		ldi r22,lo8(-96)
 403 005a 70E0      		ldi r23,0
 404 005c 80E0      		ldi r24,lo8(sendbuffer+50)
 405 005e 90E0      		ldi r25,hi8(sendbuffer+50)
 406 0060 00D0      		rcall waitforpacket
 181:test.c        **** 		DDRB |= _BV(1);
 408               	.LM41:
 409 0062 B99A      		sbi 0x17,1
 183:test.c        **** 		USIDR = 0x07;
 411               	.LM42:
 412 0064 1FB9      		out 0xf,r17
 185:test.c        **** 		DDRB &= ~_BV(1);
 414               	.LM43:
GAS LISTING /tmp/cc4LkRLk.s 			page 12


 415 0066 B998      		cbi 0x17,1
 187:test.c        **** 		waitforpacket(sbe->payload, sizeof( sendbuffer )/2-25, 30000); //wait for 2048  (30MHz/8 = 3.75MH
 417               	.LM44:
 418 0068 40E3      		ldi r20,lo8(48)
 419 006a 55E7      		ldi r21,lo8(117)
 420 006c 60EA      		ldi r22,lo8(-96)
 421 006e 70E0      		ldi r23,0
 422 0070 80E0      		ldi r24,lo8(sendbuffer+50)
 423 0072 90E0      		ldi r25,hi8(sendbuffer+50)
 424 0074 00D0      		rcall waitforpacket
 425 0076 2197      		sbiw r28,1
 192:test.c        **** 		if( i == 20 )
 427               	.LM45:
 428 0078 2097      		sbiw r28,0
 429 007a 01F4      		brne .L30
 430               	.LBB14:
 195:test.c        **** 			DDRB |= _BV(1);
 432               	.LM46:
 433 007c B99A      		sbi 0x17,1
 435               	.LM47:
 436 007e C092 0000 		sts sendbuffer+34,r12
 437 0082 D092 0000 		sts sendbuffer+34+1,r13
 438 0086 E092 0000 		sts sendbuffer+34+2,r14
 439 008a F092 0000 		sts sendbuffer+34+3,r15
 203:test.c        **** 			int rr = Ethernetize( sendbuffer, PacketABytes, 300);
 441               	.LM48:
 442 008e 4CE2      		ldi r20,lo8(44)
 443 0090 51E0      		ldi r21,lo8(1)
 444 0092 6CE4      		ldi r22,lo8(76)
 445 0094 70E0      		ldi r23,0
 446 0096 80E0      		ldi r24,lo8(sendbuffer)
 447 0098 90E0      		ldi r25,hi8(sendbuffer)
 448 009a 00D0      		rcall Ethernetize
 204:test.c        **** 
 205:test.c        **** 			SendTestASM( sendbuffer, rr/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
 450               	.LM49:
 451 009c 97FD      		sbrc r25,7
 452 009e 0396      		adiw r24,3
 453               	.L31:
 454 00a0 BC01      		movw r22,r24
 455 00a2 7595      		asr r23
 456 00a4 6795      		ror r22
 457 00a6 7595      		asr r23
 458 00a8 6795      		ror r22
 459 00aa 6D5F      		subi r22,lo8(-(3))
 460 00ac 80E0      		ldi r24,lo8(sendbuffer)
 461 00ae 90E0      		ldi r25,hi8(sendbuffer)
 462 00b0 00D0      		rcall SendTestASM
 206:test.c        **** #ifdef SMARTPWR
 207:test.c        **** 			DDRB &= ~_BV(1);
 464               	.LM50:
 465 00b2 B998      		cbi 0x17,1
 466 00b4 00C0      		rjmp .L32
 467               	.LBE14:
 469               	.Lscope3:
 471               		.stabd	78,0,0
 472               		.comm	sendbuffer,370,1
GAS LISTING /tmp/cc4LkRLk.s 			page 13


 473               	.global	ManchesterTable
 474               		.data
 475               		.p2align	4
 478               	ManchesterTable:
 479 0000 AA        		.byte	-86
 480 0001 6A        		.byte	106
 481 0002 9A        		.byte	-102
 482 0003 5A        		.byte	90
 483 0004 A6        		.byte	-90
 484 0005 66        		.byte	102
 485 0006 96        		.byte	-106
 486 0007 56        		.byte	86
 487 0008 A9        		.byte	-87
 488 0009 69        		.byte	105
 489 000a 99        		.byte	-103
 490 000b 59        		.byte	89
 491 000c A5        		.byte	-91
 492 000d 65        		.byte	101
 493 000e 95        		.byte	-107
 494 000f 55        		.byte	85
 497               		.text
 499               	.Letext0:
 500               		.ident	"GCC: (GNU) 4.8.2"
 501               	.global __do_copy_data
 502               	.global __do_clear_bss
GAS LISTING /tmp/cc4LkRLk.s 			page 14


DEFINED SYMBOLS
                            *ABS*:0000000000000000 test.c
     /tmp/cc4LkRLk.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc4LkRLk.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc4LkRLk.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc4LkRLk.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc4LkRLk.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc4LkRLk.s:116    .text:0000000000000000 delay_ms
     /tmp/cc4LkRLk.s:182    .text:0000000000000030 waitforpacket
     /tmp/cc4LkRLk.s:293    .text.startup:0000000000000000 main
                            *COM*:0000000000000172 sendbuffer
     /tmp/cc4LkRLk.s:478    .data:0000000000000000 ManchesterTable

UNDEFINED SYMBOLS
MaybeHaveDataASM
PacketA
Ethernetize
SendTestASM
__do_copy_data
__do_clear_bss
GAS LISTING /tmp/cc4LkRLk.s 			page 1


   1               	# 1 "asmtest.S"
   1               	/*
   1               	...
   0               	
   2               	    Copyright (C) 2014 <>< Charles Lohr
   3               	
   4               	
   5               	    Permission is hereby granted, free of charge, to any person obtaining a
   6               		copy of this software and associated documentation files (the "Software"),
   7               		to deal in the Software without restriction, including without limitation
   8               		the rights to use, copy, modify, merge, publish, distribute, sublicense,
   9               		and/or sell copies of the Software, and to permit persons to whom the
  10               		Software is furnished to do so, subject to the following conditions:
  11               	
  12               	    The above copyright notice and this permission notice shall be included
  13               		in all copies or substantial portions of the Software.
  14               	
  15               	    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  16               		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  17               		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  18               		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  19               		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  20               		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  21               		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  22               	*/
  23               	
  24               	
  25               	
  26               	#define _SFR_ASM_COMPAT 1
  27               	#define __SFR_OFFSET 0
  28               	
  29               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
GAS LISTING /tmp/cc4LkRLk.s 			page 2


  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h 2211 2011-02-14 14:04:25Z aboyapati $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
GAS LISTING /tmp/cc4LkRLk.s 			page 3


  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
GAS LISTING /tmp/cc4LkRLk.s 			page 4


 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
GAS LISTING /tmp/cc4LkRLk.s 			page 5


 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__) || defined (__AVR_ATmega325A__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__) || defined (__AVR_ATmega3250A__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__) || defined (__AVR_ATmega329A__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__) || defined (__AVR_ATmega3290A__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega32HVBREVB__)
 234               	#  include <avr/iom32hvbrevb.h>
 235               	#elif defined (__AVR_ATmega406__)
 236               	#  include <avr/iom406.h>
 237               	#elif defined (__AVR_ATmega16__)
 238               	#  include <avr/iom16.h>
 239               	#elif defined (__AVR_ATmega16A__)
 240               	#  include <avr/iom16a.h>
 241               	#elif defined (__AVR_ATmega161__)
 242               	#  include <avr/iom161.h>
 243               	#elif defined (__AVR_ATmega162__)
 244               	#  include <avr/iom162.h>
 245               	#elif defined (__AVR_ATmega163__)
 246               	#  include <avr/iom163.h>
 247               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 248               	#  include <avr/iom164.h>
 249               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 250               	#  include <avr/iom165.h>
 251               	#elif defined (__AVR_ATmega165P__)
 252               	#  include <avr/iom165p.h>
GAS LISTING /tmp/cc4LkRLk.s 			page 6


 253               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 254               	#  include <avr/iom168.h>
 255               	#elif defined (__AVR_ATmega168P__)
 256               	#  include <avr/iom168p.h>
 257               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 258               	#  include <avr/iom169.h>
 259               	#elif defined (__AVR_ATmega169P__)
 260               	#  include <avr/iom169p.h>
 261               	#elif defined (__AVR_ATmega169PA__)
 262               	#  include <avr/iom169pa.h>
 263               	#elif defined (__AVR_ATmega8HVA__)
 264               	#  include <avr/iom8hva.h>
 265               	#elif defined (__AVR_ATmega16HVA__)
 266               	#  include <avr/iom16hva.h>
 267               	#elif defined (__AVR_ATmega16HVA2__)
 268               	#  include <avr/iom16hva2.h>
 269               	#elif defined (__AVR_ATmega16HVB__)
 270               	#  include <avr/iom16hvb.h>
 271               	#elif defined (__AVR_ATmega16HVBREVB__)
 272               	#  include <avr/iom16hvbrevb.h>
 273               	#elif defined (__AVR_ATmega8__)
 274               	#  include <avr/iom8.h>
 275               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 276               	#  include <avr/iom48.h>
 277               	#elif defined (__AVR_ATmega48P__)
 278               	#  include <avr/iom48p.h>
 279               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 280               	#  include <avr/iom88.h>
 281               	#elif defined (__AVR_ATmega88P__)
 282               	#  include <avr/iom88p.h>
 283               	#elif defined (__AVR_ATmega88PA__)
 284               	#  include <avr/iom88pa.h>
 285               	#elif defined (__AVR_ATmega8515__)
 286               	#  include <avr/iom8515.h>
 287               	#elif defined (__AVR_ATmega8535__)
 288               	#  include <avr/iom8535.h>
 289               	#elif defined (__AVR_AT90S8535__)
 290               	#  include <avr/io8535.h>
 291               	#elif defined (__AVR_AT90C8534__)
 292               	#  include <avr/io8534.h>
 293               	#elif defined (__AVR_AT90S8515__)
 294               	#  include <avr/io8515.h>
 295               	#elif defined (__AVR_AT90S4434__)
 296               	#  include <avr/io4434.h>
 297               	#elif defined (__AVR_AT90S4433__)
 298               	#  include <avr/io4433.h>
 299               	#elif defined (__AVR_AT90S4414__)
 300               	#  include <avr/io4414.h>
 301               	#elif defined (__AVR_ATtiny22__)
 302               	#  include <avr/iotn22.h>
 303               	#elif defined (__AVR_ATtiny26__)
 304               	#  include <avr/iotn26.h>
 305               	#elif defined (__AVR_AT90S2343__)
 306               	#  include <avr/io2343.h>
 307               	#elif defined (__AVR_AT90S2333__)
 308               	#  include <avr/io2333.h>
 309               	#elif defined (__AVR_AT90S2323__)
GAS LISTING /tmp/cc4LkRLk.s 			page 7


 310               	#  include <avr/io2323.h>
 311               	#elif defined (__AVR_AT90S2313__)
 312               	#  include <avr/io2313.h>
 313               	#elif defined (__AVR_ATtiny4__)
 314               	#  include <avr/iotn4.h>
 315               	#elif defined (__AVR_ATtiny5__)
 316               	#  include <avr/iotn5.h>
 317               	#elif defined (__AVR_ATtiny9__)
 318               	#  include <avr/iotn9.h>
 319               	#elif defined (__AVR_ATtiny10__)
 320               	#  include <avr/iotn10.h>
 321               	#elif defined (__AVR_ATtiny20__)
 322               	#  include <avr/iotn20.h>
 323               	#elif defined (__AVR_ATtiny40__)
 324               	#  include <avr/iotn40.h>
 325               	#elif defined (__AVR_ATtiny2313__)
 326               	#  include <avr/iotn2313.h>
 327               	#elif defined (__AVR_ATtiny2313A__)
 328               	#  include <avr/iotn2313a.h>
 329               	#elif defined (__AVR_ATtiny13__)
 330               	#  include <avr/iotn13.h>
 331               	#elif defined (__AVR_ATtiny13A__)
 332               	#  include <avr/iotn13a.h>
 333               	#elif defined (__AVR_ATtiny25__)
 334               	#  include <avr/iotn25.h>
 335               	#elif defined (__AVR_ATtiny4313__)
 336               	#  include <avr/iotn4313.h>
 337               	#elif defined (__AVR_ATtiny45__)
 338               	#  include <avr/iotn45.h>
 339               	#elif defined (__AVR_ATtiny85__)
 340               	#  include <avr/iotn85.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
GAS LISTING /tmp/cc4LkRLk.s 			page 8


  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iotn85.h 2115 2010-04-05 23:19:53Z arcanum $ */
  32               	
  33               	/* avr/iotn85.h - definitions for ATtiny85 */
  34               	
  35               	#ifndef _AVR_IOTN85_H_
  36               	#define _AVR_IOTN85_H_ 1
  37               	
  38               	#include <avr/iotnx5.h>
   1               	/* Copyright (c) 2005,2007 Anatoly Sokolov
  39               	
 341               	#elif defined (__AVR_ATtiny24__)
 342               	#  include <avr/iotn24.h>
 343               	#elif defined (__AVR_ATtiny24A__)
 344               	#  include <avr/iotn24a.h>
 345               	#elif defined (__AVR_ATtiny44__)
 346               	#  include <avr/iotn44.h>
 347               	#elif defined (__AVR_ATtiny44A__)
 348               	#  include <avr/iotn44a.h>
 349               	#elif defined (__AVR_ATtiny84__)
 350               	#  include <avr/iotn84.h>
 351               	#elif defined (__AVR_ATtiny84A__)
 352               	#  include <avr/iotn84a.h>  
 353               	#elif defined (__AVR_ATtiny261__)
 354               	#  include <avr/iotn261.h>
 355               	#elif defined (__AVR_ATtiny261A__)
 356               	#  include <avr/iotn261a.h>
 357               	#elif defined (__AVR_ATtiny461__)
 358               	#  include <avr/iotn461.h>
 359               	#elif defined (__AVR_ATtiny461A__)
 360               	#  include <avr/iotn461a.h>
 361               	#elif defined (__AVR_ATtiny861__)
 362               	#  include <avr/iotn861.h>
 363               	#elif defined (__AVR_ATtiny861A__)
 364               	#  include <avr/iotn861a.h>
 365               	#elif defined (__AVR_ATtiny43U__)
 366               	#  include <avr/iotn43u.h>
 367               	#elif defined (__AVR_ATtiny48__)
 368               	#  include <avr/iotn48.h>
 369               	#elif defined (__AVR_ATtiny88__)
 370               	#  include <avr/iotn88.h>
 371               	#elif defined (__AVR_ATtiny87__)
 372               	#  include <avr/iotn87.h>
 373               	#elif defined (__AVR_ATtiny167__)
 374               	#  include <avr/iotn167.h>
 375               	#elif defined (__AVR_AT90SCR100__)
 376               	#  include <avr/io90scr100.h>
 377               	#elif defined (__AVR_ATxmega16A4__)
 378               	#  include <avr/iox16a4.h>
 379               	#elif defined (__AVR_ATxmega16D4__)
 380               	#  include <avr/iox16d4.h>
 381               	#elif defined (__AVR_ATxmega32A4__)
 382               	#  include <avr/iox32a4.h>
 383               	#elif defined (__AVR_ATxmega32D4__)
GAS LISTING /tmp/cc4LkRLk.s 			page 9


 384               	#  include <avr/iox32d4.h>
 385               	#elif defined (__AVR_ATxmega64A1__)
 386               	#  include <avr/iox64a1.h>
 387               	#elif defined (__AVR_ATxmega64A1U__)
 388               	#  include <avr/iox64a1u.h>
 389               	#elif defined (__AVR_ATxmega64A3__)
 390               	#  include <avr/iox64a3.h>
 391               	#elif defined (__AVR_ATxmega64D3__)
 392               	#  include <avr/iox64d3.h>
 393               	#elif defined (__AVR_ATxmega128A1__)
 394               	#  include <avr/iox128a1.h>
 395               	#elif defined (__AVR_ATxmega128A1U__)
 396               	#  include <avr/iox128a1u.h>
 397               	#elif defined (__AVR_ATxmega128A3__)
 398               	#  include <avr/iox128a3.h>
 399               	#elif defined (__AVR_ATxmega128D3__)
 400               	#  include <avr/iox128d3.h>
 401               	#elif defined (__AVR_ATxmega192A3__)
 402               	#  include <avr/iox192a3.h>
 403               	#elif defined (__AVR_ATxmega192D3__)
 404               	#  include <avr/iox192d3.h>
 405               	#elif defined (__AVR_ATxmega256A3__)
 406               	#  include <avr/iox256a3.h>
 407               	#elif defined (__AVR_ATxmega256A3B__)
 408               	#  include <avr/iox256a3b.h>
 409               	#elif defined (__AVR_ATxmega256D3__)
 410               	#  include <avr/iox256d3.h>
 411               	#elif defined (__AVR_ATA6289__)
 412               	#  include <avr/ioa6289.h>
 413               	/* avr1: the following only supported for assembler programs */
 414               	#elif defined (__AVR_ATtiny28__)
 415               	#  include <avr/iotn28.h>
 416               	#elif defined (__AVR_AT90S1200__)
 417               	#  include <avr/io1200.h>
 418               	#elif defined (__AVR_ATtiny15__)
 419               	#  include <avr/iotn15.h>
 420               	#elif defined (__AVR_ATtiny12__)
 421               	#  include <avr/iotn12.h>
 422               	#elif defined (__AVR_ATtiny11__)
 423               	#  include <avr/iotn11.h>
 424               	#elif defined (__AVR_M3000__)
 425               	#  include <avr/iom3000.h>
 426               	#else
 427               	#  if !defined(__COMPILING_AVR_LIBC__)
 428               	#    warning "device type not defined"
 429               	#  endif
 430               	#endif
 431               	
 432               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 433               	
 434               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 435               	
 436               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 437               	
GAS LISTING /tmp/cc4LkRLk.s 			page 10


 438               	/* Include fuse.h after individual IO header files. */
 439               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 440               	
 441               	/* Include lock.h after individual IO header files. */
 442               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 443               	
  30               	
  31               	.global SendTick
  32               	SendTick:
  33:asmtest.S     **** 	ori r18, 0b00010101
  34:asmtest.S     **** 	ori r19, 0b00001101
  35:asmtest.S     **** 	ori r20, 0b00000101
  36:asmtest.S     **** 	out PORTB, r19
  37:asmtest.S     **** 	out PORTB, r19
  38:asmtest.S     **** 	out PORTB, r18
  39:asmtest.S     **** 	out PORTB, r18
  40:asmtest.S     **** 	out PORTB, r20
  41:asmtest.S     **** 	ret
  42               	
  43               	.global SendTestASM  // ( unsigned char * ptr_to_packet, uint8_t packet_length_longs ); (longs = pa
  44               	SendTestASM:
  45:asmtest.S     **** 	push r16
  46:asmtest.S     **** 	push r18
  47:asmtest.S     **** 	push r19
  48:asmtest.S     **** 	push r20
  49:asmtest.S     **** 	ldi r27,0
  50:asmtest.S     **** 	ldi r26,0
  51:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable))
  52:asmtest.S     **** 	sbci r27,hi8(-(ManchesterTable))
  53               	//	mov r17, r26 // For backup
  54               		  //Manchester table now in X.
  55               	
  56               		//Move "Packet to send" into Z (R30, 31)
  57:asmtest.S     **** 	movw r30,r24
  58               	//	add r22,r24
  59               	//	adc r23,r25
  60               	
  61               		//r22 = how big to send.
  62               		
  63:asmtest.S     **** 	mov r16, r22
  64:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
  65:asmtest.S     **** 	mov r26, r18   //1  R26 = To be read Manchester lookup
  66:asmtest.S     **** 	andi r26, 0x0f //1
  67:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  68               	SendLoop:
  69:asmtest.S     **** 	tst r16
  70:asmtest.S     **** 	breq Done
  71               	KeepGoing:			///subi r26,lo8(-(ManchesterTable))
  72               	
  73               		//Heavily interleved code.  Need a new OUTB every 8 cycles exactly.
  74:asmtest.S     ****     nop           //1 //Look, ma ONE EXTRA CYCLE!
  75               		//nop
  76               	
  77:asmtest.S     **** 	ld r19, X      //2
  78:asmtest.S     **** 	swap r18       //1
GAS LISTING /tmp/cc4LkRLk.s 			page 11


  79:asmtest.S     **** 	out USIDR, r19 //1  START HERE
  80:asmtest.S     **** 	mov r26, r18   //1
  81:asmtest.S     **** 	andi r26, 0x0f //1
  82:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  83:asmtest.S     **** 	ld r19, X      //2
  84:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
  85:asmtest.S     **** 	out USIDR, r19 //1 ** OK
  86:asmtest.S     **** 	mov r26, r18   //1
  87               	
  88               	
  89:asmtest.S     **** 	andi r26, 0x0f //1
  90:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  91:asmtest.S     **** 	ld r19, X      //2
  92:asmtest.S     **** 	swap r18       //1
  93:asmtest.S     **** 	mov r26, r18   //1
  94:asmtest.S     **** 	out USIDR, r19 //1  ** OK
  95:asmtest.S     **** 	andi r26, 0x0f //1
  96:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
  97:asmtest.S     **** 	ld r19, X      //2
  98:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
  99:asmtest.S     **** 	mov r26, r18   //1
 100:asmtest.S     **** 	out USIDR, r19 //1  **OK
 101               	
 102               	
 103:asmtest.S     **** 	andi r26, 0x0f //1
 104:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 105:asmtest.S     **** 	ld r19, X      //2
 106:asmtest.S     **** 	swap r18       //1
 107:asmtest.S     **** 	mov r26, r18   //1
 108:asmtest.S     **** 	andi r26, 0x0f //1
 109:asmtest.S     **** 	out USIDR, r19 //1  ** OK 
 110:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 111:asmtest.S     **** 	ld r19, X      //2
 112:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 113:asmtest.S     **** 	mov r26, r18   //1
 114:asmtest.S     **** 	andi r26, 0x0f //1
 115:asmtest.S     **** 	out USIDR, r19 //1 ** OK
 116:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 117:asmtest.S     **** 	ld r19, X      //2
 118:asmtest.S     **** 	swap r18       //1
 119:asmtest.S     **** 	mov r26, r18   //1
 120:asmtest.S     **** 	andi r26, 0x0f //1
 121:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 122:asmtest.S     **** 	out USIDR, r19 //1 ** OK
 123:asmtest.S     **** 	ld r19, X      //2
 124:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 125:asmtest.S     **** 	mov r26, r18   //1
 126:asmtest.S     **** 	andi r26, 0x0f //1
 127:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 128:asmtest.S     **** 	out USIDR, r19 //1 ** OK
 129               	
 130:asmtest.S     **** 	dec r16         //1
 131:asmtest.S     **** 	brne KeepGoing  //2
 132               	Done:
 133:asmtest.S     **** 	pop r20
 134:asmtest.S     **** 	pop r19
 135:asmtest.S     **** 	pop r18
GAS LISTING /tmp/cc4LkRLk.s 			page 12


 136:asmtest.S     **** 	pop r16
 137:asmtest.S     **** 	ret
 138               	
 139               	
 140               	
 141               	.global MaybeHaveDataASM
 142               	MaybeHaveDataASM:
 143               	
 144               	
 145:asmtest.S     **** 	push r16
 146:asmtest.S     **** 	push r18
 147:asmtest.S     **** 	push r19
 148:asmtest.S     **** 	push r20
 149               	
 150               						//r22:r23 = bytes in buffer.
 151:asmtest.S     **** 	movw r30,r24    //r24:r25 = pointer to staging ram.
 152               	
 153               		//In here, we're operating at 30 ~MHz (hopefully)
 154               		//We want to peel the data off the SPI bus as fast as possible!
 155               	
 156               		//First, let's make sure it wasn't just a glitch.
 157:asmtest.S     **** 	in r18,USIBR  
 158:asmtest.S     **** 	tst r18
 159:asmtest.S     **** 	breq rlend
 160               	
 161               	
 162:asmtest.S     **** 	tst r22
 163:asmtest.S     **** 	breq rlend
 164               	rloop:
 165:asmtest.S     **** 	in r18,USIDR  //1  ****
 166:asmtest.S     **** 	st Z+, r18    //2
 167               	//	tst r18       //1
 168:asmtest.S     **** 	inc r18			//1
 169:asmtest.S     ****     breq rlend    //2
 170:asmtest.S     ****     nop           //1
 171:asmtest.S     ****     nop           //1
 172:asmtest.S     **** 	in r18,USIDR  //1  ****
 173:asmtest.S     **** 	st Z+, r18    //2
 174:asmtest.S     **** 	dec r22       //1
 175:asmtest.S     ****     nop           //
 176:asmtest.S     ****     nop           //1
 177:asmtest.S     **** 	brne rloop    //2
 178               	
 179               	rlend:
 180:asmtest.S     **** 	pop r20
 181:asmtest.S     **** 	pop r19
 182:asmtest.S     **** 	pop r18
 183:asmtest.S     **** 	pop r16
 184:asmtest.S     **** 	ret
GAS LISTING /tmp/cc4LkRLk.s 			page 13


DEFINED SYMBOLS
           asmtest.S:32     .text:0000000000000000 SendTick
           asmtest.S:44     .text:0000000000000012 SendTestASM
           asmtest.S:68     .text:000000000000002e SendLoop
           asmtest.S:132    .text:0000000000000098 Done
           asmtest.S:71     .text:0000000000000032 KeepGoing
           asmtest.S:142    .text:00000000000000a2 MaybeHaveDataASM
           asmtest.S:179    .text:00000000000000ce rlend
           asmtest.S:164    .text:00000000000000b6 rloop

UNDEFINED SYMBOLS
ManchesterTable
GAS LISTING /tmp/cc4LkRLk.s 			page 1


   1               		.file	"sendpack.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 107               	.global	PacketA
 108               		.section	.progmem.data,"a",@progbits
 111               	PacketA:
 112 0000 55        		.byte	85
 113 0001 55        		.byte	85
 114 0002 55        		.byte	85
 115 0003 55        		.byte	85
 116 0004 55        		.byte	85
 117 0005 55        		.byte	85
 118 0006 55        		.byte	85
 119 0007 D5        		.byte	-43
 120 0008 FF        		.byte	-1
 121 0009 FF        		.byte	-1
 122 000a FF        		.byte	-1
 123 000b FF        		.byte	-1
 124 000c FF        		.byte	-1
 125 000d FF        		.byte	-1
 126 000e 00        		.byte	0
 127 000f 55        		.byte	85
 128 0010 00        		.byte	0
 129 0011 55        		.byte	85
 130 0012 00        		.byte	0
 131 0013 55        		.byte	85
 132 0014 08        		.byte	8
 133 0015 00        		.byte	0
 134 0016 45        		.byte	69
 135 0017 00        		.byte	0
 136 0018 00        		.byte	0
 137 0019 32        		.byte	50
 138 001a B3        		.byte	-77
 139 001b 1E        		.byte	30
 140 001c 00        		.byte	0
 141 001d 00        		.byte	0
 142 001e 80        		.byte	-128
 143 001f 11        		.byte	17
 144 0020 C6        		.byte	-58
 145 0021 8D        		.byte	-115
 146 0022 C0        		.byte	-64
 147 0023 A8        		.byte	-88
 148 0024 00        		.byte	0
 149 0025 67        		.byte	103
 150 0026 FF        		.byte	-1
 151 0027 FF        		.byte	-1
 152 0028 FF        		.byte	-1
 153 0029 FF        		.byte	-1
 154 002a 04        		.byte	4
 155 002b 00        		.byte	0
 156 002c 34        		.byte	52
 157 002d 00        		.byte	0
GAS LISTING /tmp/cc4LkRLk.s 			page 2


 158 002e 00        		.byte	0
 159 002f 1E        		.byte	30
 160 0030 18        		.byte	24
 161 0031 EE        		.byte	-18
 162 0032 43        		.byte	67
 163 0033 0A        		.byte	10
 164 0034 AA        		.byte	-86
 165 0035 AA        		.byte	-86
 166 0036 AA        		.byte	-86
 167 0037 AA        		.byte	-86
 168 0038 AA        		.byte	-86
 169 0039 AA        		.byte	-86
 170 003a AA        		.byte	-86
 171 003b AA        		.byte	-86
 172 003c AA        		.byte	-86
 173 003d AA        		.byte	-86
 174 003e AA        		.byte	-86
 175 003f AA        		.byte	-86
 176 0040 AA        		.byte	-86
 177 0041 AA        		.byte	-86
 178 0042 AA        		.byte	-86
 179 0043 AA        		.byte	-86
 180 0044 AA        		.byte	-86
 181 0045 AA        		.byte	-86
 182 0046 AA        		.byte	-86
 183 0047 AA        		.byte	-86
 184 0048 5D        		.byte	93
 185 0049 FA        		.byte	-6
 186 004a B6        		.byte	-74
 187 004b 1A        		.byte	26
 189               		.text
 191               	.Letext0:
 192               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/cc4LkRLk.s 			page 3


DEFINED SYMBOLS
                            *ABS*:0000000000000000 sendpack.c
     /tmp/cc4LkRLk.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc4LkRLk.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc4LkRLk.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc4LkRLk.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc4LkRLk.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc4LkRLk.s:111    .progmem.data:0000000000000000 PacketA

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/cc4LkRLk.s 			page 1


   1               		.file	"packetmater.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  98               	.global	crc32b
 100               	crc32b:
 101               		.stabd	46,0,0
   1:packetmater.c **** //Packet mater.  A super tiny file that helps with checksums and ethernet CRCs.
   2:packetmater.c **** //CRC Was taken from linked page.
   3:packetmater.c **** 
   4:packetmater.c **** /*
   5:packetmater.c ****     Copyright (C) 2014 <>< Charles Lohr
   6:packetmater.c **** 
   7:packetmater.c **** 
   8:packetmater.c ****     Permission is hereby granted, free of charge, to any person obtaining a
   9:packetmater.c **** 	copy of this software and associated documentation files (the "Software"),
  10:packetmater.c **** 	to deal in the Software without restriction, including without limitation
  11:packetmater.c **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  12:packetmater.c **** 	and/or sell copies of the Software, and to permit persons to whom the
  13:packetmater.c **** 	Software is furnished to do so, subject to the following conditions:
  14:packetmater.c **** 
  15:packetmater.c ****     The above copyright notice and this permission notice shall be included
  16:packetmater.c **** 	in all copies or substantial portions of the Software.
  17:packetmater.c **** 
  18:packetmater.c ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  19:packetmater.c **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  20:packetmater.c **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  21:packetmater.c **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  22:packetmater.c **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  23:packetmater.c **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  24:packetmater.c **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  25:packetmater.c **** */
  26:packetmater.c **** #include "packetmater.h"
  27:packetmater.c **** 
  28:packetmater.c **** //Fix all checksums for UDP packets and add etherlink CRC.
  29:packetmater.c **** uint16_t Ethernetize( unsigned char * packet, int plen, int udplenoverride )
  30:packetmater.c **** {
  31:packetmater.c **** 	plen -= 12;
  32:packetmater.c **** 	packet += 8; //User must provide preamble.
  33:packetmater.c **** 
  34:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
  35:packetmater.c **** 		plen = (udplenoverride+8) + 34;
  36:packetmater.c **** 
  37:packetmater.c **** 	//Need to buffer to 4-byte boundaries.
  38:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
  39:packetmater.c **** 
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
  41:packetmater.c **** 	{
  42:packetmater.c **** 		uint16_t fullpacklen = plen-14;
  43:packetmater.c **** 		packet[16] = fullpacklen>>8;
  44:packetmater.c **** 		packet[17] = fullpacklen&0xff;
  45:packetmater.c **** 		packet[24] = 0;
  46:packetmater.c **** 		packet[25] = 0;
GAS LISTING /tmp/cc4LkRLk.s 			page 2


  47:packetmater.c **** 		uint16_t csumr;
  48:packetmater.c **** //		fprintf( stderr, "Header checksum: 0x%04x\n", csumr = csrange(14,20) );
  49:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
  50:packetmater.c **** 
  51:packetmater.c **** 		packet[24] = csumr>>8;
  52:packetmater.c **** 		packet[25] = csumr&0xff;
  53:packetmater.c **** 
  54:packetmater.c **** 		if( packet[23] == 0x11  )
  55:packetmater.c **** 		{
  56:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
  57:packetmater.c **** 			packet[32+6] = udppacklen>>8;
  58:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
  59:packetmater.c **** 
  60:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
  61:packetmater.c **** 			packet[40+0] = pseudo>>8;
  62:packetmater.c **** 			packet[40+1] = pseudo&0xff;
  63:packetmater.c **** 
  64:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
  65:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
  66:packetmater.c **** 			packet[40+0] = csumr>>8;
  67:packetmater.c **** 			packet[40+1] = csumr&0xff;
  68:packetmater.c **** 		}
  69:packetmater.c **** 	}
  70:packetmater.c **** 
  71:packetmater.c **** 
  72:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
  73:packetmater.c **** 
  74:packetmater.c **** 	packet[plen+0] = crc & 0xff;
  75:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
  76:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
  77:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
  78:packetmater.c **** 
  79:packetmater.c **** 	return plen;
  80:packetmater.c **** }
  81:packetmater.c **** 
  82:packetmater.c **** 
  83:packetmater.c **** //From: http://www.hackersdelight.org/hdcodetxt/crc.c.txt
  84:packetmater.c **** uint32_t crc32b(uint32_t crc, unsigned char *message, int len) {
 103               	.LM0:
 104               	.LFBB1:
 105 0000 AF92      		push r10
 106 0002 BF92      		push r11
 107 0004 CF92      		push r12
 108 0006 DF92      		push r13
 109 0008 EF92      		push r14
 110 000a FF92      		push r15
 111 000c 0F93      		push r16
 112 000e 1F93      		push r17
 113 0010 CF93      		push r28
 114 0012 DF93      		push r29
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 10 */
 118               	.L__stack_usage = 10
 119 0014 5901      		movw r10,r18
  85:packetmater.c ****    int i, j;
  86:packetmater.c ****    uint32_t mask;
GAS LISTING /tmp/cc4LkRLk.s 			page 3


  87:packetmater.c **** 	uint8_t byte;
  88:packetmater.c **** 
  89:packetmater.c ****    i = 0;
  90:packetmater.c **** //   crc = 0xFFFFFFFF;
  91:packetmater.c **** 	crc = ~crc;
 121               	.LM1:
 122 0016 6095      		com r22
 123 0018 7095      		com r23
 124 001a 8095      		com r24
 125 001c 9095      		com r25
  92:packetmater.c ****    while (i < len) {
 127               	.LM2:
 128 001e FA01      		movw r30,r20
 129               	.L2:
 130 0020 9F01      		movw r18,r30
 131 0022 241B      		sub r18,r20
 132 0024 350B      		sbc r19,r21
 134               	.LM3:
 135 0026 2A15      		cp r18,r10
 136 0028 3B05      		cpc r19,r11
 137 002a 04F4      		brge .L8
  93:packetmater.c ****       byte = message[i];            // Get next byte.
 139               	.LM4:
 140 002c 2191      		ld r18,Z+
  94:packetmater.c ****       crc = crc ^ byte;
 142               	.LM5:
 143 002e 6227      		eor r22,r18
 144 0030 A8E0      		ldi r26,lo8(8)
 145 0032 B0E0      		ldi r27,0
 146               	.L4:
  95:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
  96:packetmater.c ****          mask = -(crc & 1);
  97:packetmater.c ****          crc = (crc >> 1) ^ (0xEDB88320 & mask);
 148               	.LM6:
 149 0034 8B01      		movw r16,r22
 150 0036 9C01      		movw r18,r24
 151 0038 3695      		lsr r19
 152 003a 2795      		ror r18
 153 003c 1795      		ror r17
 154 003e 0795      		ror r16
  96:packetmater.c ****          mask = -(crc & 1);
 156               	.LM7:
 157 0040 6B01      		movw r12,r22
 158 0042 7C01      		movw r14,r24
 159 0044 C1E0      		ldi r28,1
 160 0046 CC22      		and r12,r28
 161 0048 DD24      		clr r13
 162 004a EE24      		clr r14
 163 004c FF24      		clr r15
 164 004e 6627      		clr r22
 165 0050 7727      		clr r23
 166 0052 CB01      		movw r24,r22
 167 0054 6C19      		sub r22,r12
 168 0056 7D09      		sbc r23,r13
 169 0058 8E09      		sbc r24,r14
 170 005a 9F09      		sbc r25,r15
 172               	.LM8:
GAS LISTING /tmp/cc4LkRLk.s 			page 4


 173 005c 6072      		andi r22,32
 174 005e 7378      		andi r23,131
 175 0060 887B      		andi r24,184
 176 0062 9D7E      		andi r25,237
 177 0064 6027      		eor r22,r16
 178 0066 7127      		eor r23,r17
 179 0068 8227      		eor r24,r18
 180 006a 9327      		eor r25,r19
 181 006c 1197      		sbiw r26,1
  95:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
 183               	.LM9:
 184 006e 1097      		sbiw r26,0
 185 0070 01F4      		brne .L4
 186 0072 00C0      		rjmp .L2
 187               	.L8:
  98:packetmater.c ****       }
  99:packetmater.c ****       i = i + 1;
 100:packetmater.c ****    }
 101:packetmater.c ****    return ~crc;
 189               	.LM10:
 190 0074 6095      		com r22
 191 0076 7095      		com r23
 192 0078 8095      		com r24
 193 007a 9095      		com r25
 194               	/* epilogue start */
 102:packetmater.c **** }
 196               	.LM11:
 197 007c DF91      		pop r29
 198 007e CF91      		pop r28
 199 0080 1F91      		pop r17
 200 0082 0F91      		pop r16
 201 0084 FF90      		pop r15
 202 0086 EF90      		pop r14
 203 0088 DF90      		pop r13
 204 008a CF90      		pop r12
 205 008c BF90      		pop r11
 206 008e AF90      		pop r10
 207 0090 0895      		ret
 212               	.Lscope1:
 214               		.stabd	78,0,0
 218               	.global	internet_checksum
 220               	internet_checksum:
 221               		.stabd	46,0,0
 103:packetmater.c **** 
 104:packetmater.c **** uint16_t internet_checksum( const unsigned char * start, uint16_t len )
 105:packetmater.c **** {
 223               	.LM12:
 224               	.LFBB2:
 225 0092 CF93      		push r28
 226 0094 DF93      		push r29
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 2 */
 230               	.L__stack_usage = 2
 231 0096 9B01      		movw r18,r22
 232 0098 DC01      		movw r26,r24
 106:packetmater.c **** 	uint16_t i;
GAS LISTING /tmp/cc4LkRLk.s 			page 5


 107:packetmater.c **** 	const uint16_t * wptr = (uint16_t*) start;
 108:packetmater.c **** 	uint32_t csum = 0;
 234               	.LM13:
 235 009a 40E0      		ldi r20,0
 236 009c 50E0      		ldi r21,0
 237 009e BA01      		movw r22,r20
 109:packetmater.c **** 	for (i=1;i<len;i+=2)
 239               	.LM14:
 240 00a0 E1E0      		ldi r30,lo8(1)
 241 00a2 F0E0      		ldi r31,0
 242               	.L10:
 244               	.LM15:
 245 00a4 E217      		cp r30,r18
 246 00a6 F307      		cpc r31,r19
 247 00a8 00F4      		brsh .L18
 110:packetmater.c **** 	{
 111:packetmater.c **** 		csum = csum + (uint32_t)(*(wptr++));	
 249               	.LM16:
 250 00aa CD91      		ld r28,X+
 251 00ac DD91      		ld r29,X+
 252 00ae 4C0F      		add r20,r28
 253 00b0 5D1F      		adc r21,r29
 254 00b2 611D      		adc r22,__zero_reg__
 255 00b4 711D      		adc r23,__zero_reg__
 109:packetmater.c **** 	for (i=1;i<len;i+=2)
 257               	.LM17:
 258 00b6 3296      		adiw r30,2
 259 00b8 00C0      		rjmp .L10
 260               	.L18:
 261 00ba F901      		movw r30,r18
 262 00bc EE7F      		andi r30,254
 263 00be E80F      		add r30,r24
 264 00c0 F91F      		adc r31,r25
 112:packetmater.c **** 	}
 113:packetmater.c **** 	if( len & 1 )  //See if there's an odd number of bytes?
 266               	.LM18:
 267 00c2 20FF      		sbrs r18,0
 268 00c4 00C0      		rjmp .L13
 269               	.LBB2:
 114:packetmater.c **** 	{
 115:packetmater.c **** 		uint8_t * tt = (uint8_t*)wptr;
 116:packetmater.c **** 		csum += *tt;
 271               	.LM19:
 272 00c6 8081      		ld r24,Z
 273 00c8 480F      		add r20,r24
 274 00ca 511D      		adc r21,__zero_reg__
 275 00cc 611D      		adc r22,__zero_reg__
 276 00ce 711D      		adc r23,__zero_reg__
 277               	.L13:
 278               	.LBE2:
 117:packetmater.c **** 	}
 118:packetmater.c **** 	while (csum>>16)
 280               	.LM20:
 281 00d0 CB01      		movw r24,r22
 282 00d2 AA27      		clr r26
 283 00d4 BB27      		clr r27
 284 00d6 0097      		sbiw r24,0
GAS LISTING /tmp/cc4LkRLk.s 			page 6


 285 00d8 A105      		cpc r26,__zero_reg__
 286 00da B105      		cpc r27,__zero_reg__
 287 00dc 01F0      		breq .L19
 119:packetmater.c **** 		csum = (csum & 0xFFFF)+(csum >> 16);
 289               	.LM21:
 290 00de 6627      		clr r22
 291 00e0 7727      		clr r23
 292 00e2 480F      		add r20,r24
 293 00e4 591F      		adc r21,r25
 294 00e6 6A1F      		adc r22,r26
 295 00e8 7B1F      		adc r23,r27
 296 00ea 00C0      		rjmp .L13
 297               	.L19:
 120:packetmater.c **** 	csum = (csum>>8) | ((csum&0xff)<<8);
 299               	.LM22:
 300 00ec BB27      		clr r27
 301 00ee A72F      		mov r26,r23
 302 00f0 962F      		mov r25,r22
 303 00f2 852F      		mov r24,r21
 304 00f4 762F      		mov r23,r22
 305 00f6 652F      		mov r22,r21
 306 00f8 542F      		mov r21,r20
 307 00fa 4427      		clr r20
 308 00fc 6627      		clr r22
 309 00fe 7727      		clr r23
 310 0100 482B      		or r20,r24
 311 0102 592B      		or r21,r25
 312 0104 6A2B      		or r22,r26
 313 0106 7B2B      		or r23,r27
 121:packetmater.c **** 	return ~csum;
 315               	.LM23:
 316 0108 CA01      		movw r24,r20
 317 010a 8095      		com r24
 318 010c 9095      		com r25
 319               	/* epilogue start */
 122:packetmater.c **** }
 321               	.LM24:
 322 010e DF91      		pop r29
 323 0110 CF91      		pop r28
 324 0112 0895      		ret
 329               	.Lscope2:
 331               		.stabd	78,0,0
 336               	.global	Ethernetize
 338               	Ethernetize:
 339               		.stabd	46,0,0
  30:packetmater.c **** {
 341               	.LM25:
 342               	.LFBB3:
 343 0114 AF92      		push r10
 344 0116 BF92      		push r11
 345 0118 CF92      		push r12
 346 011a DF92      		push r13
 347 011c EF92      		push r14
 348 011e FF92      		push r15
 349 0120 0F93      		push r16
 350 0122 1F93      		push r17
 351 0124 CF93      		push r28
GAS LISTING /tmp/cc4LkRLk.s 			page 7


 352 0126 DF93      		push r29
 353               	/* prologue: function */
 354               	/* frame size = 0 */
 355               	/* stack size = 10 */
 356               	.L__stack_usage = 10
 357 0128 EC01      		movw r28,r24
 358 012a 7A01      		movw r14,r20
  32:packetmater.c **** 	packet += 8; //User must provide preamble.
 360               	.LM26:
 361 012c 5C01      		movw r10,r24
 362 012e 88E0      		ldi r24,8
 363 0130 A80E      		add r10,r24
 364 0132 B11C      		adc r11,__zero_reg__
  34:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
 366               	.LM27:
 367 0134 9A01      		movw r18,r20
 368 0136 295F      		subi r18,-7
 369 0138 3F4F      		sbci r19,-1
 370 013a CB01      		movw r24,r22
 371 013c 8E97      		sbiw r24,46
 372 013e 2817      		cp r18,r24
 373 0140 3907      		cpc r19,r25
 374 0142 04F4      		brge .L21
  31:packetmater.c **** 	plen -= 12;
 376               	.LM28:
 377 0144 8B01      		movw r16,r22
 378 0146 0C50      		subi r16,12
 379 0148 1109      		sbc r17,__zero_reg__
 380 014a 00C0      		rjmp .L22
 381               	.L21:
  35:packetmater.c **** 		plen = (udplenoverride+8) + 34;
 383               	.LM29:
 384 014c 8A01      		movw r16,r20
 385 014e 065D      		subi r16,-42
 386 0150 1F4F      		sbci r17,-1
 387               	.L22:
  38:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
 389               	.LM30:
 390 0152 0150      		subi r16,1
 391 0154 1109      		sbc r17,__zero_reg__
 392 0156 0C7F      		andi r16,252
 393 0158 6801      		movw r12,r16
 394 015a 84E0      		ldi r24,4
 395 015c C80E      		add r12,r24
 396 015e D11C      		adc r13,__zero_reg__
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 398               	.LM31:
 399 0160 8C89      		ldd r24,Y+20
 400 0162 8830      		cpi r24,lo8(8)
 401 0164 01F4      		brne .L24
  40:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 403               	.LM32:
 404 0166 8D89      		ldd r24,Y+21
 405 0168 8111      		cpse r24,__zero_reg__
 406 016a 00C0      		rjmp .L24
 407               	.LBB3:
  42:packetmater.c **** 		uint16_t fullpacklen = plen-14;
GAS LISTING /tmp/cc4LkRLk.s 			page 8


 409               	.LM33:
 410 016c C801      		movw r24,r16
 411 016e 0A97      		sbiw r24,10
  43:packetmater.c **** 		packet[16] = fullpacklen>>8;
 413               	.LM34:
 414 0170 988F      		std Y+24,r25
  44:packetmater.c **** 		packet[17] = fullpacklen&0xff;
 416               	.LM35:
 417 0172 898F      		std Y+25,r24
  45:packetmater.c **** 		packet[24] = 0;
 419               	.LM36:
 420 0174 18A2      		std Y+32,__zero_reg__
  46:packetmater.c **** 		packet[25] = 0;
 422               	.LM37:
 423 0176 19A2      		std Y+33,__zero_reg__
  49:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
 425               	.LM38:
 426 0178 64E1      		ldi r22,lo8(20)
 427 017a 70E0      		ldi r23,0
 428 017c CE01      		movw r24,r28
 429 017e 4696      		adiw r24,22
 430 0180 00D0      		rcall internet_checksum
  51:packetmater.c **** 		packet[24] = csumr>>8;
 432               	.LM39:
 433 0182 98A3      		std Y+32,r25
  52:packetmater.c **** 		packet[25] = csumr&0xff;
 435               	.LM40:
 436 0184 89A3      		std Y+33,r24
  54:packetmater.c **** 		if( packet[23] == 0x11  )
 438               	.LM41:
 439 0186 8F8D      		ldd r24,Y+31
 440 0188 8131      		cpi r24,lo8(17)
 441 018a 01F4      		brne .L24
 442               	.LBB4:
  56:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
 444               	.LM42:
 445 018c B701      		movw r22,r14
 446 018e 685F      		subi r22,-8
 447 0190 7F4F      		sbci r23,-1
  57:packetmater.c **** 			packet[32+6] = udppacklen>>8;
 449               	.LM43:
 450 0192 7EA7      		std Y+46,r23
  58:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
 452               	.LM44:
 453 0194 6FA7      		std Y+47,r22
  60:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
 455               	.LM45:
 456 0196 89E1      		ldi r24,25
 457 0198 E80E      		add r14,r24
 458 019a F11C      		adc r15,__zero_reg__
  61:packetmater.c **** 			packet[40+0] = pseudo>>8;
 460               	.LM46:
 461 019c F8AA      		std Y+48,r15
  62:packetmater.c **** 			packet[40+1] = pseudo&0xff;
 463               	.LM47:
 464 019e E9AA      		std Y+49,r14
  64:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
GAS LISTING /tmp/cc4LkRLk.s 			page 9


 466               	.LM48:
 467 01a0 685F      		subi r22,-8
 468 01a2 7F4F      		sbci r23,-1
 469 01a4 CE01      		movw r24,r28
 470 01a6 8296      		adiw r24,34
 471 01a8 00D0      		rcall internet_checksum
  65:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
 473               	.LM49:
 474 01aa 0097      		sbiw r24,0
 475 01ac 01F4      		brne .L26
 476 01ae 8FEF      		ldi r24,lo8(-1)
 477 01b0 9FEF      		ldi r25,lo8(-1)
 478               	.L26:
  66:packetmater.c **** 			packet[40+0] = csumr>>8;
 480               	.LM50:
 481 01b2 98AB      		std Y+48,r25
  67:packetmater.c **** 			packet[40+1] = csumr&0xff;
 483               	.LM51:
 484 01b4 89AB      		std Y+49,r24
 485               	.L24:
 486               	.LBE4:
 487               	.LBE3:
  72:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
 489               	.LM52:
 490 01b6 9601      		movw r18,r12
 491 01b8 A501      		movw r20,r10
 492 01ba 60E0      		ldi r22,0
 493 01bc 70E0      		ldi r23,0
 494 01be CB01      		movw r24,r22
 495 01c0 00D0      		rcall crc32b
  74:packetmater.c **** 	packet[plen+0] = crc & 0xff;
 497               	.LM53:
 498 01c2 F501      		movw r30,r10
 499 01c4 EC0D      		add r30,r12
 500 01c6 FD1D      		adc r31,r13
 501 01c8 6083      		st Z,r22
  75:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
 503               	.LM54:
 504 01ca F501      		movw r30,r10
 505 01cc E00F      		add r30,r16
 506 01ce F11F      		adc r31,r17
 507 01d0 7583      		std Z+5,r23
  76:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
 509               	.LM55:
 510 01d2 8683      		std Z+6,r24
  77:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
 512               	.LM56:
 513 01d4 9783      		std Z+7,r25
  80:packetmater.c **** }
 515               	.LM57:
 516 01d6 C601      		movw r24,r12
 517               	/* epilogue start */
 518 01d8 DF91      		pop r29
 519 01da CF91      		pop r28
 520 01dc 1F91      		pop r17
 521 01de 0F91      		pop r16
 522 01e0 FF90      		pop r15
GAS LISTING /tmp/cc4LkRLk.s 			page 10


 523 01e2 EF90      		pop r14
 524 01e4 DF90      		pop r13
 525 01e6 CF90      		pop r12
 526 01e8 BF90      		pop r11
 527 01ea AF90      		pop r10
 528 01ec 0895      		ret
 533               	.Lscope3:
 535               		.stabd	78,0,0
 537               	.Letext0:
 538               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/cc4LkRLk.s 			page 11


DEFINED SYMBOLS
                            *ABS*:0000000000000000 packetmater.c
     /tmp/cc4LkRLk.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc4LkRLk.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc4LkRLk.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc4LkRLk.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc4LkRLk.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc4LkRLk.s:100    .text:0000000000000000 crc32b
     /tmp/cc4LkRLk.s:220    .text:0000000000000092 internet_checksum
     /tmp/cc4LkRLk.s:338    .text:0000000000000114 Ethernetize

NO UNDEFINED SYMBOLS
