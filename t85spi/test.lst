GAS LISTING /tmp/ccMP3Ntm.s 			page 1


   1               		.file	"test.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 114               	.global	delay_ms
 116               	delay_ms:
 117               		.stabd	46,0,0
   1:test.c        **** /*
   2:test.c        **** 
   3:test.c        **** 	WARNING: Connecting an AVR to ethernet without magnetics is VERY DANGEROUS.
   4:test.c        **** 	It may cause high voltages to go through the AVR and destroy it in DANGEROUS
   5:test.c        **** 	that may harm personal safety.  Do only at your own risk.
   6:test.c        **** 
   7:test.c        **** */
   8:test.c        **** 
   9:test.c        **** /*
  10:test.c        ****     Copyright (C) 2014 <>< Charles Lohr
  11:test.c        **** 
  12:test.c        **** 
  13:test.c        ****     Permission is hereby granted, free of charge, to any person obtaining a
  14:test.c        **** 	copy of this software and associated documentation files (the "Software"),
  15:test.c        **** 	to deal in the Software without restriction, including without limitation
  16:test.c        **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  17:test.c        **** 	and/or sell copies of the Software, and to permit persons to whom the
  18:test.c        **** 	Software is furnished to do so, subject to the following conditions:
  19:test.c        **** 
  20:test.c        ****     The above copyright notice and this permission notice shall be included
  21:test.c        **** 	in all copies or substantial portions of the Software.
  22:test.c        **** 
  23:test.c        ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  24:test.c        **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  25:test.c        **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  26:test.c        **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  27:test.c        **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  28:test.c        **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  29:test.c        **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  30:test.c        **** */
  31:test.c        **** 
  32:test.c        **** 
  33:test.c        **** #include <avr/io.h>
  34:test.c        **** #include <avr/interrupt.h>
  35:test.c        **** #include <avr/sleep.h>
  36:test.c        **** #include <util/delay.h>
  37:test.c        **** 
  38:test.c        **** #include "net_compat.h"
  39:test.c        **** #include "sendpack.h"
  40:test.c        **** #include "packetmater.h"
  41:test.c        **** #include "hlprocess.h"
  42:test.c        **** 
  43:test.c        **** void delay_ms(uint32_t time) {
 119               	.LM0:
 120               	.LFBB1:
 121 0000 0F93      		push r16
GAS LISTING /tmp/ccMP3Ntm.s 			page 2


 122 0002 1F93      		push r17
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 2 */
 126               	.L__stack_usage = 2
  44:test.c        ****   uint32_t i;
  45:test.c        ****   for (i = 0; i < time; i++) {
 128               	.LM1:
 129 0004 00E0      		ldi r16,0
 130 0006 10E0      		ldi r17,0
 131 0008 9801      		movw r18,r16
 132               	.L2:
 134               	.LM2:
 135 000a 0617      		cp r16,r22
 136 000c 1707      		cpc r17,r23
 137 000e 2807      		cpc r18,r24
 138 0010 3907      		cpc r19,r25
 139 0012 01F0      		breq .L5
 140               	.LBB4:
 141               	.LBB5:
 143               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
GAS LISTING /tmp/ccMP3Ntm.s 			page 3


  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
GAS LISTING /tmp/ccMP3Ntm.s 			page 4


  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
GAS LISTING /tmp/ccMP3Ntm.s 			page 5


 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 145               	.LM3:
 146 0014 E7E8      		ldi r30,lo8(4999)
 147 0016 F3E1      		ldi r31,hi8(4999)
 148 0018 3197      		1: sbiw r30,1
 149 001a 01F4      		brne 1b
 150 001c 00C0      		rjmp .
 151 001e 0000      		nop
 152               	.LBE5:
 153               	.LBE4:
 155               	.Ltext2:
 157               	.LM4:
 158 0020 0F5F      		subi r16,-1
 159 0022 1F4F      		sbci r17,-1
 160 0024 2F4F      		sbci r18,-1
 161 0026 3F4F      		sbci r19,-1
 162 0028 00C0      		rjmp .L2
 163               	.L5:
 164               	/* epilogue start */
  46:test.c        ****     _delay_ms(1);
  47:test.c        ****   }
  48:test.c        **** }
 166               	.LM5:
 167 002a 1F91      		pop r17
 168 002c 0F91      		pop r16
 169 002e 0895      		ret
 174               	.Lscope1:
 176               		.stabd	78,0,0
 177               		.section	.text.startup,"ax",@progbits
 179               	.global	main
 181               	main:
 182               		.stabd	46,0,0
  49:test.c        **** 
  50:test.c        **** #define NOOP asm volatile("nop" ::)
  51:test.c        **** 
  52:test.c        **** static void setup_clock( void )
  53:test.c        **** {
  54:test.c        **** 	/*Examine Page 33*/
  55:test.c        **** 
  56:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
  57:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
  58:test.c        **** 
  59:test.c        **** 
  60:test.c        **** }
GAS LISTING /tmp/ccMP3Ntm.s 			page 6


  61:test.c        **** 
  62:test.c        **** //#define SMARTPWR
  63:test.c        **** 
  64:test.c        **** 
  65:test.c        **** //unsigned char ETbuffer[390];
  66:test.c        **** 
  67:test.c        **** void SendTestASM( const unsigned char * c, uint8_t len );
  68:test.c        **** int MaybeHaveDataASM( unsigned char * c, uint8_t lenX2 ); //returns the number of pairs.
  69:test.c        **** 
  70:test.c        **** 
  71:test.c        **** 
  72:test.c        **** int main( )
  73:test.c        **** {
 184               	.LM6:
 185               	.LFBB2:
 186               	/* prologue: function */
 187               	/* frame size = 0 */
 188               	/* stack size = 0 */
 189               	.L__stack_usage = 0
  74:test.c        **** 	int i;
  75:test.c        **** 	cli();
 191               	.LM7:
 192               	/* #APP */
 193               	 ;  75 "test.c" 1
 194 0000 F894      		cli
 195               	 ;  0 "" 2
 196               	/* #NOAPP */
 197               	.LBB10:
 198               	.LBB11:
  56:test.c        **** 	CLKPR = 0x80;	/*Setup CLKPCE to be receptive*/
 200               	.LM8:
 201 0002 80E8      		ldi r24,lo8(-128)
 202 0004 86BD      		out 0x26,r24
  57:test.c        **** 	CLKPR = 0x00;	/*No scalar*/
 204               	.LM9:
 205 0006 16BC      		out 0x26,__zero_reg__
 206               	.LBE11:
 207               	.LBE10:
  76:test.c        **** 
  77:test.c        **** 	setup_clock();
  78:test.c        **** 
  79:test.c        **** 	DDRB = _BV(1);
 209               	.LM10:
 210 0008 82E0      		ldi r24,lo8(2)
 211 000a 87BB      		out 0x17,r24
  80:test.c        **** 
  81:test.c        **** 	//1st let's see how fast we can clock the pin.
  82:test.c        **** 	et_init( MyMAC );
 213               	.LM11:
 214 000c 80E0      		ldi r24,lo8(MyMAC)
 215 000e 90E0      		ldi r25,hi8(MyMAC)
 216 0010 00D0      		rcall et_init
 217 0012 80E0      		ldi r24,lo8(PacketA)
 218 0014 90E0      		ldi r25,hi8(PacketA)
 219 0016 A0E0      		ldi r26,lo8(ETbuffer)
 220 0018 B0E0      		ldi r27,hi8(ETbuffer)
 221               	.L8:
GAS LISTING /tmp/ccMP3Ntm.s 			page 7


 222               	.LBB12:
  83:test.c        **** 
  84:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
  85:test.c        **** 	{
  86:test.c        **** 		ETbuffer[i] = pgm_read_word( &PacketA[i] );
 224               	.LM12:
 225 001a FC01      		movw r30,r24
 226               	/* #APP */
 227               	 ;  86 "test.c" 1
 228 001c 2591      		lpm r18, Z+
 229 001e 3491      		lpm r19, Z
 230               		
 231               	 ;  0 "" 2
 232               	/* #NOAPP */
 233               	.LBE12:
 234 0020 2D93      		st X+,r18
 235 0022 0196      		adiw r24,1
  84:test.c        **** 	for( i = 0; i < PacketABytes; i++ )
 237               	.LM13:
 238 0024 20E0      		ldi r18,hi8(PacketA+76)
 239 0026 8030      		cpi r24,lo8(PacketA+76)
 240 0028 9207      		cpc r25,r18
 241 002a 01F4      		brne .L8
 242               	.LBB13:
  87:test.c        **** 	}
  88:test.c        **** 
  89:test.c        **** 	i = 0;
  90:test.c        **** 
  91:test.c        **** 	int frame = 0;
  92:test.c        **** 
  93:test.c        **** 	struct EthernetPacket * sbe = (struct EthernetPacket*)ETbuffer;
  94:test.c        **** 
  95:test.c        **** 	while(1)
  96:test.c        **** 	{
  97:test.c        **** 	//	SendTestASM( ETbuffer, PacketABytes/4 + 3 ); //MUST BE DIVISIBLE BY 2 # of bytes.
  98:test.c        **** 	//	continue;
  99:test.c        **** 		et_recvpack();
 100:test.c        **** 
 101:test.c        **** 		i++;
 102:test.c        **** 
 103:test.c        **** 		if( i == 20 )
 104:test.c        **** 		{
 105:test.c        **** #ifdef SMARTPWR
 106:test.c        **** 			DDRB |= _BV(1);
 107:test.c        **** #endif
 108:test.c        **** 
 109:test.c        **** 			//UDP Data starts at byte #50
 110:test.c        **** 			struct EthernetPacket * sbe = (struct EthernetPacket*)ETbuffer;
 111:test.c        **** //			sbe->payload[0] = 0xBB;
 112:test.c        **** //			sbe->payload[1] = frame++;
 113:test.c        **** 			sbe->addyfrom = 0x450a000a;
 244               	.LM14:
 245 002c 9AE0      		ldi r25,lo8(10)
 246 002e C92E      		mov r12,r25
 247 0030 D12C      		mov r13,__zero_reg__
 248 0032 EC2C      		mov r14,r12
 249 0034 95E4      		ldi r25,lo8(69)
GAS LISTING /tmp/ccMP3Ntm.s 			page 8


 250 0036 F92E      		mov r15,r25
 251               	.L12:
 252               	.LBE13:
  73:test.c        **** {
 254               	.LM15:
 255 0038 C4E1      		ldi r28,lo8(20)
 256 003a D0E0      		ldi r29,0
 257               	.L10:
  99:test.c        **** 		et_recvpack();
 259               	.LM16:
 260 003c 00D0      		rcall et_recvpack
 261 003e 2197      		sbiw r28,1
 103:test.c        **** 		if( i == 20 )
 263               	.LM17:
 264 0040 2097      		sbiw r28,0
 265 0042 01F4      		brne .L10
 266               	.LBB14:
 268               	.LM18:
 269 0044 C092 0000 		sts ETbuffer+26,r12
 270 0048 D092 0000 		sts ETbuffer+26+1,r13
 271 004c E092 0000 		sts ETbuffer+26+2,r14
 272 0050 F092 0000 		sts ETbuffer+26+3,r15
 114:test.c        **** 			int rr = Ethernetize( ETbuffer, PacketABytes, 320);
 274               	.LM19:
 275 0054 40E4      		ldi r20,lo8(64)
 276 0056 51E0      		ldi r21,lo8(1)
 277 0058 6CE4      		ldi r22,lo8(76)
 278 005a 70E0      		ldi r23,0
 279 005c 80E0      		ldi r24,lo8(ETbuffer)
 280 005e 90E0      		ldi r25,hi8(ETbuffer)
 281 0060 00D0      		rcall Ethernetize
 115:test.c        **** 
 116:test.c        **** 			SendTestASM( ETbuffer, rr/4 + 3 - 2 ); //MUST BE DIVISIBLE BY 2 # of bytes.
 283               	.LM20:
 284 0062 97FD      		sbrc r25,7
 285 0064 0396      		adiw r24,3
 286               	.L11:
 287 0066 BC01      		movw r22,r24
 288 0068 7595      		asr r23
 289 006a 6795      		ror r22
 290 006c 7595      		asr r23
 291 006e 6795      		ror r22
 292 0070 6F5F      		subi r22,lo8(-(1))
 293 0072 80E0      		ldi r24,lo8(ETbuffer)
 294 0074 90E0      		ldi r25,hi8(ETbuffer)
 295 0076 00D0      		rcall SendTestASM
 296 0078 00C0      		rjmp .L12
 297               	.LBE14:
 299               	.Lscope2:
 301               		.stabd	78,0,0
 302               		.text
 304               	.Letext0:
 305               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccMP3Ntm.s 			page 9


DEFINED SYMBOLS
                            *ABS*:0000000000000000 test.c
     /tmp/ccMP3Ntm.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccMP3Ntm.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccMP3Ntm.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccMP3Ntm.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccMP3Ntm.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccMP3Ntm.s:116    .text:0000000000000000 delay_ms
     /tmp/ccMP3Ntm.s:181    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
MyMAC
et_init
PacketA
ETbuffer
et_recvpack
Ethernetize
SendTestASM
GAS LISTING /tmp/ccMP3Ntm.s 			page 1


   1               	# 1 "asmtest.S"
   1               	/*
   1               	...
   0               	
   2               	    Copyright (C) 2014 <>< Charles Lohr
   3               	
   4               	
   5               	    Permission is hereby granted, free of charge, to any person obtaining a
   6               		copy of this software and associated documentation files (the "Software"),
   7               		to deal in the Software without restriction, including without limitation
   8               		the rights to use, copy, modify, merge, publish, distribute, sublicense,
   9               		and/or sell copies of the Software, and to permit persons to whom the
  10               		Software is furnished to do so, subject to the following conditions:
  11               	
  12               	    The above copyright notice and this permission notice shall be included
  13               		in all copies or substantial portions of the Software.
  14               	
  15               	    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  16               		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  17               		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  18               		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  19               		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  20               		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  21               		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  22               	*/
  23               	
  24               	
  25               	
  26               	#define _SFR_ASM_COMPAT 1
  27               	#define __SFR_OFFSET 0
  28               	
  29               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
GAS LISTING /tmp/ccMP3Ntm.s 			page 2


  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h 2211 2011-02-14 14:04:25Z aboyapati $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
GAS LISTING /tmp/ccMP3Ntm.s 			page 3


  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
GAS LISTING /tmp/ccMP3Ntm.s 			page 4


 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
GAS LISTING /tmp/ccMP3Ntm.s 			page 5


 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__) || defined (__AVR_ATmega325A__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__) || defined (__AVR_ATmega3250A__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__) || defined (__AVR_ATmega329A__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__) || defined (__AVR_ATmega3290A__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega32HVBREVB__)
 234               	#  include <avr/iom32hvbrevb.h>
 235               	#elif defined (__AVR_ATmega406__)
 236               	#  include <avr/iom406.h>
 237               	#elif defined (__AVR_ATmega16__)
 238               	#  include <avr/iom16.h>
 239               	#elif defined (__AVR_ATmega16A__)
 240               	#  include <avr/iom16a.h>
 241               	#elif defined (__AVR_ATmega161__)
 242               	#  include <avr/iom161.h>
 243               	#elif defined (__AVR_ATmega162__)
 244               	#  include <avr/iom162.h>
 245               	#elif defined (__AVR_ATmega163__)
 246               	#  include <avr/iom163.h>
 247               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 248               	#  include <avr/iom164.h>
 249               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 250               	#  include <avr/iom165.h>
 251               	#elif defined (__AVR_ATmega165P__)
 252               	#  include <avr/iom165p.h>
GAS LISTING /tmp/ccMP3Ntm.s 			page 6


 253               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 254               	#  include <avr/iom168.h>
 255               	#elif defined (__AVR_ATmega168P__)
 256               	#  include <avr/iom168p.h>
 257               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 258               	#  include <avr/iom169.h>
 259               	#elif defined (__AVR_ATmega169P__)
 260               	#  include <avr/iom169p.h>
 261               	#elif defined (__AVR_ATmega169PA__)
 262               	#  include <avr/iom169pa.h>
 263               	#elif defined (__AVR_ATmega8HVA__)
 264               	#  include <avr/iom8hva.h>
 265               	#elif defined (__AVR_ATmega16HVA__)
 266               	#  include <avr/iom16hva.h>
 267               	#elif defined (__AVR_ATmega16HVA2__)
 268               	#  include <avr/iom16hva2.h>
 269               	#elif defined (__AVR_ATmega16HVB__)
 270               	#  include <avr/iom16hvb.h>
 271               	#elif defined (__AVR_ATmega16HVBREVB__)
 272               	#  include <avr/iom16hvbrevb.h>
 273               	#elif defined (__AVR_ATmega8__)
 274               	#  include <avr/iom8.h>
 275               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 276               	#  include <avr/iom48.h>
 277               	#elif defined (__AVR_ATmega48P__)
 278               	#  include <avr/iom48p.h>
 279               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 280               	#  include <avr/iom88.h>
 281               	#elif defined (__AVR_ATmega88P__)
 282               	#  include <avr/iom88p.h>
 283               	#elif defined (__AVR_ATmega88PA__)
 284               	#  include <avr/iom88pa.h>
 285               	#elif defined (__AVR_ATmega8515__)
 286               	#  include <avr/iom8515.h>
 287               	#elif defined (__AVR_ATmega8535__)
 288               	#  include <avr/iom8535.h>
 289               	#elif defined (__AVR_AT90S8535__)
 290               	#  include <avr/io8535.h>
 291               	#elif defined (__AVR_AT90C8534__)
 292               	#  include <avr/io8534.h>
 293               	#elif defined (__AVR_AT90S8515__)
 294               	#  include <avr/io8515.h>
 295               	#elif defined (__AVR_AT90S4434__)
 296               	#  include <avr/io4434.h>
 297               	#elif defined (__AVR_AT90S4433__)
 298               	#  include <avr/io4433.h>
 299               	#elif defined (__AVR_AT90S4414__)
 300               	#  include <avr/io4414.h>
 301               	#elif defined (__AVR_ATtiny22__)
 302               	#  include <avr/iotn22.h>
 303               	#elif defined (__AVR_ATtiny26__)
 304               	#  include <avr/iotn26.h>
 305               	#elif defined (__AVR_AT90S2343__)
 306               	#  include <avr/io2343.h>
 307               	#elif defined (__AVR_AT90S2333__)
 308               	#  include <avr/io2333.h>
 309               	#elif defined (__AVR_AT90S2323__)
GAS LISTING /tmp/ccMP3Ntm.s 			page 7


 310               	#  include <avr/io2323.h>
 311               	#elif defined (__AVR_AT90S2313__)
 312               	#  include <avr/io2313.h>
 313               	#elif defined (__AVR_ATtiny4__)
 314               	#  include <avr/iotn4.h>
 315               	#elif defined (__AVR_ATtiny5__)
 316               	#  include <avr/iotn5.h>
 317               	#elif defined (__AVR_ATtiny9__)
 318               	#  include <avr/iotn9.h>
 319               	#elif defined (__AVR_ATtiny10__)
 320               	#  include <avr/iotn10.h>
 321               	#elif defined (__AVR_ATtiny20__)
 322               	#  include <avr/iotn20.h>
 323               	#elif defined (__AVR_ATtiny40__)
 324               	#  include <avr/iotn40.h>
 325               	#elif defined (__AVR_ATtiny2313__)
 326               	#  include <avr/iotn2313.h>
 327               	#elif defined (__AVR_ATtiny2313A__)
 328               	#  include <avr/iotn2313a.h>
 329               	#elif defined (__AVR_ATtiny13__)
 330               	#  include <avr/iotn13.h>
 331               	#elif defined (__AVR_ATtiny13A__)
 332               	#  include <avr/iotn13a.h>
 333               	#elif defined (__AVR_ATtiny25__)
 334               	#  include <avr/iotn25.h>
 335               	#elif defined (__AVR_ATtiny4313__)
 336               	#  include <avr/iotn4313.h>
 337               	#elif defined (__AVR_ATtiny45__)
 338               	#  include <avr/iotn45.h>
 339               	#elif defined (__AVR_ATtiny85__)
 340               	#  include <avr/iotn85.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
GAS LISTING /tmp/ccMP3Ntm.s 			page 8


  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iotn85.h 2115 2010-04-05 23:19:53Z arcanum $ */
  32               	
  33               	/* avr/iotn85.h - definitions for ATtiny85 */
  34               	
  35               	#ifndef _AVR_IOTN85_H_
  36               	#define _AVR_IOTN85_H_ 1
  37               	
  38               	#include <avr/iotnx5.h>
   1               	/* Copyright (c) 2005,2007 Anatoly Sokolov
  39               	
 341               	#elif defined (__AVR_ATtiny24__)
 342               	#  include <avr/iotn24.h>
 343               	#elif defined (__AVR_ATtiny24A__)
 344               	#  include <avr/iotn24a.h>
 345               	#elif defined (__AVR_ATtiny44__)
 346               	#  include <avr/iotn44.h>
 347               	#elif defined (__AVR_ATtiny44A__)
 348               	#  include <avr/iotn44a.h>
 349               	#elif defined (__AVR_ATtiny84__)
 350               	#  include <avr/iotn84.h>
 351               	#elif defined (__AVR_ATtiny84A__)
 352               	#  include <avr/iotn84a.h>  
 353               	#elif defined (__AVR_ATtiny261__)
 354               	#  include <avr/iotn261.h>
 355               	#elif defined (__AVR_ATtiny261A__)
 356               	#  include <avr/iotn261a.h>
 357               	#elif defined (__AVR_ATtiny461__)
 358               	#  include <avr/iotn461.h>
 359               	#elif defined (__AVR_ATtiny461A__)
 360               	#  include <avr/iotn461a.h>
 361               	#elif defined (__AVR_ATtiny861__)
 362               	#  include <avr/iotn861.h>
 363               	#elif defined (__AVR_ATtiny861A__)
 364               	#  include <avr/iotn861a.h>
 365               	#elif defined (__AVR_ATtiny43U__)
 366               	#  include <avr/iotn43u.h>
 367               	#elif defined (__AVR_ATtiny48__)
 368               	#  include <avr/iotn48.h>
 369               	#elif defined (__AVR_ATtiny88__)
 370               	#  include <avr/iotn88.h>
 371               	#elif defined (__AVR_ATtiny87__)
 372               	#  include <avr/iotn87.h>
 373               	#elif defined (__AVR_ATtiny167__)
 374               	#  include <avr/iotn167.h>
 375               	#elif defined (__AVR_AT90SCR100__)
 376               	#  include <avr/io90scr100.h>
 377               	#elif defined (__AVR_ATxmega16A4__)
 378               	#  include <avr/iox16a4.h>
 379               	#elif defined (__AVR_ATxmega16D4__)
 380               	#  include <avr/iox16d4.h>
 381               	#elif defined (__AVR_ATxmega32A4__)
 382               	#  include <avr/iox32a4.h>
 383               	#elif defined (__AVR_ATxmega32D4__)
GAS LISTING /tmp/ccMP3Ntm.s 			page 9


 384               	#  include <avr/iox32d4.h>
 385               	#elif defined (__AVR_ATxmega64A1__)
 386               	#  include <avr/iox64a1.h>
 387               	#elif defined (__AVR_ATxmega64A1U__)
 388               	#  include <avr/iox64a1u.h>
 389               	#elif defined (__AVR_ATxmega64A3__)
 390               	#  include <avr/iox64a3.h>
 391               	#elif defined (__AVR_ATxmega64D3__)
 392               	#  include <avr/iox64d3.h>
 393               	#elif defined (__AVR_ATxmega128A1__)
 394               	#  include <avr/iox128a1.h>
 395               	#elif defined (__AVR_ATxmega128A1U__)
 396               	#  include <avr/iox128a1u.h>
 397               	#elif defined (__AVR_ATxmega128A3__)
 398               	#  include <avr/iox128a3.h>
 399               	#elif defined (__AVR_ATxmega128D3__)
 400               	#  include <avr/iox128d3.h>
 401               	#elif defined (__AVR_ATxmega192A3__)
 402               	#  include <avr/iox192a3.h>
 403               	#elif defined (__AVR_ATxmega192D3__)
 404               	#  include <avr/iox192d3.h>
 405               	#elif defined (__AVR_ATxmega256A3__)
 406               	#  include <avr/iox256a3.h>
 407               	#elif defined (__AVR_ATxmega256A3B__)
 408               	#  include <avr/iox256a3b.h>
 409               	#elif defined (__AVR_ATxmega256D3__)
 410               	#  include <avr/iox256d3.h>
 411               	#elif defined (__AVR_ATA6289__)
 412               	#  include <avr/ioa6289.h>
 413               	/* avr1: the following only supported for assembler programs */
 414               	#elif defined (__AVR_ATtiny28__)
 415               	#  include <avr/iotn28.h>
 416               	#elif defined (__AVR_AT90S1200__)
 417               	#  include <avr/io1200.h>
 418               	#elif defined (__AVR_ATtiny15__)
 419               	#  include <avr/iotn15.h>
 420               	#elif defined (__AVR_ATtiny12__)
 421               	#  include <avr/iotn12.h>
 422               	#elif defined (__AVR_ATtiny11__)
 423               	#  include <avr/iotn11.h>
 424               	#elif defined (__AVR_M3000__)
 425               	#  include <avr/iom3000.h>
 426               	#else
 427               	#  if !defined(__COMPILING_AVR_LIBC__)
 428               	#    warning "device type not defined"
 429               	#  endif
 430               	#endif
 431               	
 432               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 433               	
 434               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 435               	
 436               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 437               	
GAS LISTING /tmp/ccMP3Ntm.s 			page 10


 438               	/* Include fuse.h after individual IO header files. */
 439               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 440               	
 441               	/* Include lock.h after individual IO header files. */
 442               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 443               	
  30               	
  31               	#define USEBR  USIDR
  32               	.global SendTick
  33               	SendTick:
  34:asmtest.S     **** 	ori r18, 0b00010101
  35:asmtest.S     **** 	ori r19, 0b00001101
  36:asmtest.S     **** 	ori r20, 0b00000101
  37:asmtest.S     **** 	out PORTB, r19
  38:asmtest.S     **** 	out PORTB, r19
  39:asmtest.S     **** 	out PORTB, r18
  40:asmtest.S     **** 	out PORTB, r18
  41:asmtest.S     **** 	out PORTB, r20
  42:asmtest.S     **** 	ret
  43               	
  44               	
  45               	//Handles sending preamble + Packet ovr the USI
  46               	.global SendTestASM  // ( unsigned char * ptr_to_packet, uint8_t packet_length_longs ); (longs = pa
  47               	SendTestASM:
  48:asmtest.S     **** 	push r16
  49:asmtest.S     **** 	push r17
  50:asmtest.S     **** 	push r18
  51:asmtest.S     **** 	push r19
  52:asmtest.S     **** 	push r20
  53:asmtest.S     **** 	ldi r27,0
  54:asmtest.S     **** 	ldi r26,0
  55:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable))
  56:asmtest.S     **** 	sbci r27,hi8(-(ManchesterTable))
  57               	//	mov r17, r26 // For backup
  58               		  //Manchester table now in X.
  59               	
  60               		//Move "Packet to send" into Z (R30, 31)
  61:asmtest.S     **** 	movw r30,r24
  62               	//	add r22,r24
  63               	//	adc r23,r25
  64               	
  65               		//r22 = how big to send.
  66               		
  67:asmtest.S     **** 	mov r16, r22
  68:asmtest.S     **** 	ld r18,Z+
  69:asmtest.S     **** 	mov r26, r18 
  70:asmtest.S     **** 	andi r26, 0x0f
  71:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1  (This sets X up)
  72               	SendLoop:
  73:asmtest.S     **** 	tst r16
  74:asmtest.S     **** 	brne .SkipD
  75:asmtest.S     **** 	rjmp .Done
  76               	.SkipD:
  77               	
  78               	
GAS LISTING /tmp/ccMP3Ntm.s 			page 11


  79               	//////////////////////////////////////////////////
  80               	//Special: preamble.
  81:asmtest.S     **** 	ldi r20, 15   //Iterate 15 times. (the 0x55 pattern) then finish out with the 0xD5 pattern.
  82:asmtest.S     **** 	ldi r19, 0b01100110  //Standard 0x55 pattern
  83:asmtest.S     **** 	ldi r17, 0b01100101  //Final pattern marker.
  84               		//Go ahead with the preamble.
  85               		//Enable the USI
  86:asmtest.S     **** 	SBI USICR, USIWM0
  87               	
  88               	.PreambleLoop:
  89:asmtest.S     **** 	out USEBR, r19
  90:asmtest.S     **** 	nop
  91:asmtest.S     **** 	nop
  92:asmtest.S     **** 	nop
  93:asmtest.S     **** 	nop
  94:asmtest.S     **** 	dec r20
  95:asmtest.S     **** 	brne .PreambleLoop
  96:asmtest.S     ****     nop
  97:asmtest.S     **** 	out USEBR, r17
  98:asmtest.S     **** 	nop
  99               	
 100:asmtest.S     **** 	nop
 101:asmtest.S     **** 	nop
 102               	
 103               	KeepGoing:			///subi r26,lo8(-(ManchesterTable))
 104               	
 105               		//Heavily interleved code.  Need a new OUTB every 8 cycles exactly.
 106:asmtest.S     ****     nop           //1 //Look, ma ONE EXTRA CYCLE!
 107               		//nop
 108               	
 109:asmtest.S     **** 	ld r19, X      //2
 110:asmtest.S     **** 	swap r18       //1
 111:asmtest.S     **** 	out USEBR, r19 //1  START HERE
 112:asmtest.S     **** 	mov r26, r18   //1
 113:asmtest.S     **** 	andi r26, 0x0f //1
 114:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 115:asmtest.S     **** 	ld r19, X      //2
 116:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 117:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 118:asmtest.S     **** 	mov r26, r18   //1
 119               	
 120               	
 121:asmtest.S     **** 	andi r26, 0x0f //1
 122:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 123:asmtest.S     **** 	ld r19, X      //2
 124:asmtest.S     **** 	swap r18       //1
 125:asmtest.S     **** 	mov r26, r18   //1
 126:asmtest.S     **** 	out USEBR, r19 //1  ** OK
 127:asmtest.S     **** 	andi r26, 0x0f //1
 128:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 129:asmtest.S     **** 	ld r19, X      //2
 130:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 131:asmtest.S     **** 	mov r26, r18   //1
 132:asmtest.S     **** 	out USEBR, r19 //1  **OK
 133               	
 134               	
 135:asmtest.S     **** 	andi r26, 0x0f //1
GAS LISTING /tmp/ccMP3Ntm.s 			page 12


 136:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 137:asmtest.S     **** 	ld r19, X      //2
 138:asmtest.S     **** 	swap r18       //1
 139:asmtest.S     **** 	mov r26, r18   //1
 140:asmtest.S     **** 	andi r26, 0x0f //1
 141:asmtest.S     **** 	out USEBR, r19 //1  ** OK 
 142:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 143:asmtest.S     **** 	ld r19, X      //2
 144:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 145:asmtest.S     **** 	mov r26, r18   //1
 146:asmtest.S     **** 	andi r26, 0x0f //1
 147:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 148:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 149:asmtest.S     **** 	ld r19, X      //2
 150:asmtest.S     **** 	swap r18       //1
 151:asmtest.S     **** 	mov r26, r18   //1
 152:asmtest.S     **** 	andi r26, 0x0f //1
 153:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 154:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 155:asmtest.S     **** 	ld r19, X      //2
 156:asmtest.S     **** 	ld r18,Z+      //2  //Read off the bytes.
 157:asmtest.S     **** 	mov r26, r18   //1
 158:asmtest.S     **** 	andi r26, 0x0f //1
 159:asmtest.S     **** 	subi r26,lo8(-(ManchesterTable)) //1
 160:asmtest.S     **** 	out USEBR, r19 //1 ** OK
 161               	
 162:asmtest.S     **** 	dec r16         //1
 163:asmtest.S     **** 	brne KeepGoing  //2
 164               	.Done:
 165:asmtest.S     **** 	nop
 166:asmtest.S     **** 	nop
 167:asmtest.S     **** 	nop
 168:asmtest.S     **** 	nop
 169:asmtest.S     **** 	andi r19,0
 170:asmtest.S     **** 	nop
 171:asmtest.S     **** 	out USEBR,r19 
 172:asmtest.S     **** 	CBI USICR, USIWM0
 173               	
 174:asmtest.S     **** 	pop r20
 175:asmtest.S     **** 	pop r19
 176:asmtest.S     **** 	pop r18
 177:asmtest.S     **** 	pop r17
 178:asmtest.S     **** 	mov r24, r16
 179:asmtest.S     **** 	pop r16
 180:asmtest.S     **** 	ret
 181               	
 182               	
 183               	#define USEBRR  USIDR
 184               	//#define USEBRR  ADCL
 185               	
 186               	.global MaybeHaveDataASM
 187               	MaybeHaveDataASM:
 188               	
 189:asmtest.S     **** 	push r16
 190:asmtest.S     **** 	push r22
 191:asmtest.S     **** 	push r18
 192:asmtest.S     **** 	push r19
GAS LISTING /tmp/ccMP3Ntm.s 			page 13


 193:asmtest.S     **** 	push r20
 194               	
 195               						//r22 = words in buffer.
 196:asmtest.S     **** 	movw r30,r24    //r24:r25 = pointer to staging ram.
 197               	
 198               		//In here, we're operating at 30 ~MHz (hopefully)
 199               		//We want to peel the data off the SPI bus as fast as possible!
 200               	
 201:asmtest.S     **** 	tst r22
 202:asmtest.S     **** 	breq rlend
 203               	rloop:
 204               	
 205               	///XXX TODO: Scrutenize the "breq" 
 206:asmtest.S     **** 	in r19,USEBRR  //1  ****
 207:asmtest.S     **** 	inc r19			//1
 208:asmtest.S     ****     breq rlend    //2???
 209:asmtest.S     ****     nop           //1????
 210:asmtest.S     **** 	dec r19		//1
 211:asmtest.S     **** 	breq rlend  //2????
 212:asmtest.S     **** 	nop         //1
 213:asmtest.S     **** 	nop         //1
 214               	
 215:asmtest.S     **** 	in r18,USEBRR  //1  ****
 216:asmtest.S     **** 	st Z+, r19    //2
 217:asmtest.S     **** 	st Z+, r18    //2
 218:asmtest.S     **** 	dec r22       //1
 219:asmtest.S     **** 	brne rloop    //2
 220               	
 221               	rlend:
 222:asmtest.S     **** 	mov r24,r22
 223:asmtest.S     **** 	pop r20
 224:asmtest.S     **** 	pop r19
 225:asmtest.S     **** 	pop r18
 226:asmtest.S     **** 	pop r22
 227:asmtest.S     **** 	pop r16
 228:asmtest.S     **** 	ret
GAS LISTING /tmp/ccMP3Ntm.s 			page 14


DEFINED SYMBOLS
           asmtest.S:33     .text:0000000000000000 SendTick
           asmtest.S:47     .text:0000000000000012 SendTestASM
           asmtest.S:72     .text:0000000000000030 SendLoop
           asmtest.S:76     .text:0000000000000036 .SkipD
           asmtest.S:164    .text:00000000000000bc .Done
           asmtest.S:88     .text:000000000000003e .PreambleLoop
           asmtest.S:103    .text:0000000000000056 KeepGoing
           asmtest.S:187    .text:00000000000000da MaybeHaveDataASM
           asmtest.S:221    .text:0000000000000104 rlend
           asmtest.S:203    .text:00000000000000ea rloop

UNDEFINED SYMBOLS
ManchesterTable
GAS LISTING /tmp/ccMP3Ntm.s 			page 1


   1               		.file	"sendpack.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 107               	.global	PacketA
 108               		.section	.progmem.data,"a",@progbits
 111               	PacketA:
 112 0000 FF        		.byte	-1
 113 0001 FF        		.byte	-1
 114 0002 FF        		.byte	-1
 115 0003 FF        		.byte	-1
 116 0004 FF        		.byte	-1
 117 0005 FF        		.byte	-1
 118 0006 00        		.byte	0
 119 0007 55        		.byte	85
 120 0008 00        		.byte	0
 121 0009 55        		.byte	85
 122 000a 00        		.byte	0
 123 000b 55        		.byte	85
 124 000c 08        		.byte	8
 125 000d 00        		.byte	0
 126 000e 45        		.byte	69
 127 000f 00        		.byte	0
 128 0010 00        		.byte	0
 129 0011 32        		.byte	50
 130 0012 B3        		.byte	-77
 131 0013 1E        		.byte	30
 132 0014 00        		.byte	0
 133 0015 00        		.byte	0
 134 0016 80        		.byte	-128
 135 0017 11        		.byte	17
 136 0018 C6        		.byte	-58
 137 0019 8D        		.byte	-115
 138 001a C0        		.byte	-64
 139 001b A8        		.byte	-88
 140 001c 00        		.byte	0
 141 001d 67        		.byte	103
 142 001e FF        		.byte	-1
 143 001f FF        		.byte	-1
 144 0020 FF        		.byte	-1
 145 0021 FF        		.byte	-1
 146 0022 04        		.byte	4
 147 0023 00        		.byte	0
 148 0024 34        		.byte	52
 149 0025 00        		.byte	0
 150 0026 00        		.byte	0
 151 0027 1E        		.byte	30
 152 0028 18        		.byte	24
 153 0029 EE        		.byte	-18
 154 002a 43        		.byte	67
 155 002b 0A        		.byte	10
 156 002c AA        		.byte	-86
 157 002d AA        		.byte	-86
GAS LISTING /tmp/ccMP3Ntm.s 			page 2


 158 002e AA        		.byte	-86
 159 002f AA        		.byte	-86
 160 0030 AA        		.byte	-86
 161 0031 AA        		.byte	-86
 162 0032 AA        		.byte	-86
 163 0033 AA        		.byte	-86
 164 0034 AA        		.byte	-86
 165 0035 AA        		.byte	-86
 166 0036 AA        		.byte	-86
 167 0037 AA        		.byte	-86
 168 0038 AA        		.byte	-86
 169 0039 AA        		.byte	-86
 170 003a AA        		.byte	-86
 171 003b AA        		.byte	-86
 172 003c AA        		.byte	-86
 173 003d AA        		.byte	-86
 174 003e AA        		.byte	-86
 175 003f AA        		.byte	-86
 176 0040 5D        		.byte	93
 177 0041 FA        		.byte	-6
 178 0042 B6        		.byte	-74
 179 0043 1A        		.byte	26
 181               		.text
 183               	.Letext0:
 184               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccMP3Ntm.s 			page 3


DEFINED SYMBOLS
                            *ABS*:0000000000000000 sendpack.c
     /tmp/ccMP3Ntm.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccMP3Ntm.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccMP3Ntm.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccMP3Ntm.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccMP3Ntm.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccMP3Ntm.s:111    .progmem.data:0000000000000000 PacketA

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccMP3Ntm.s 			page 1


   1               		.file	"packetmater.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  98               	.global	crc32b
 100               	crc32b:
 101               		.stabd	46,0,0
   1:packetmater.c **** //Packet mater.  A super tiny file that helps with checksums and ethernet CRCs.
   2:packetmater.c **** //CRC Was taken from linked page.
   3:packetmater.c **** 
   4:packetmater.c **** /*
   5:packetmater.c ****     Copyright (C) 2014 <>< Charles Lohr
   6:packetmater.c **** 
   7:packetmater.c **** 
   8:packetmater.c ****     Permission is hereby granted, free of charge, to any person obtaining a
   9:packetmater.c **** 	copy of this software and associated documentation files (the "Software"),
  10:packetmater.c **** 	to deal in the Software without restriction, including without limitation
  11:packetmater.c **** 	the rights to use, copy, modify, merge, publish, distribute, sublicense,
  12:packetmater.c **** 	and/or sell copies of the Software, and to permit persons to whom the
  13:packetmater.c **** 	Software is furnished to do so, subject to the following conditions:
  14:packetmater.c **** 
  15:packetmater.c ****     The above copyright notice and this permission notice shall be included
  16:packetmater.c **** 	in all copies or substantial portions of the Software.
  17:packetmater.c **** 
  18:packetmater.c ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  19:packetmater.c **** 	OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  20:packetmater.c **** 	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  21:packetmater.c **** 	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  22:packetmater.c **** 	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  23:packetmater.c **** 	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  24:packetmater.c **** 	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  25:packetmater.c **** */
  26:packetmater.c **** #include "packetmater.h"
  27:packetmater.c **** 
  28:packetmater.c **** //Fix all checksums for UDP packets and add etherlink CRC.
  29:packetmater.c **** uint16_t Ethernetize( unsigned char * packet, int plen, int udplenoverride )
  30:packetmater.c **** {
  31:packetmater.c **** 	plen -= 4;
  32:packetmater.c **** 
  33:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
  34:packetmater.c **** 		plen = (udplenoverride+8) + 34;
  35:packetmater.c **** 
  36:packetmater.c **** 	//Need to buffer to 4-byte boundaries.
  37:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
  38:packetmater.c **** 
  39:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
  40:packetmater.c **** 	{
  41:packetmater.c **** 		uint16_t fullpacklen = plen-14;
  42:packetmater.c **** 		packet[16] = fullpacklen>>8;
  43:packetmater.c **** 		packet[17] = fullpacklen&0xff;
  44:packetmater.c **** 		packet[24] = 0;
  45:packetmater.c **** 		packet[25] = 0;
  46:packetmater.c **** 		uint16_t csumr;
GAS LISTING /tmp/ccMP3Ntm.s 			page 2


  47:packetmater.c **** //		fprintf( stderr, "Header checksum: 0x%04x\n", csumr = csrange(14,20) );
  48:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
  49:packetmater.c **** 
  50:packetmater.c **** 		packet[24] = csumr>>8;
  51:packetmater.c **** 		packet[25] = csumr&0xff;
  52:packetmater.c **** 
  53:packetmater.c **** 		if( packet[23] == 0x11  )
  54:packetmater.c **** 		{
  55:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
  56:packetmater.c **** 			packet[32+6] = udppacklen>>8;
  57:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
  58:packetmater.c **** 
  59:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
  60:packetmater.c **** 			packet[40+0] = pseudo>>8;
  61:packetmater.c **** 			packet[40+1] = pseudo&0xff;
  62:packetmater.c **** 
  63:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
  64:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
  65:packetmater.c **** 			packet[40+0] = csumr>>8;
  66:packetmater.c **** 			packet[40+1] = csumr&0xff;
  67:packetmater.c **** 		}
  68:packetmater.c **** 	}
  69:packetmater.c **** 
  70:packetmater.c **** 
  71:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
  72:packetmater.c **** 
  73:packetmater.c **** 	packet[plen+0] = crc & 0xff;
  74:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
  75:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
  76:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
  77:packetmater.c **** 
  78:packetmater.c **** 	return plen;
  79:packetmater.c **** }
  80:packetmater.c **** 
  81:packetmater.c **** 
  82:packetmater.c **** //From: http://www.hackersdelight.org/hdcodetxt/crc.c.txt
  83:packetmater.c **** uint32_t crc32b(uint32_t crc, unsigned char *message, int len) {
 103               	.LM0:
 104               	.LFBB1:
 105 0000 AF92      		push r10
 106 0002 BF92      		push r11
 107 0004 CF92      		push r12
 108 0006 DF92      		push r13
 109 0008 EF92      		push r14
 110 000a FF92      		push r15
 111 000c 0F93      		push r16
 112 000e 1F93      		push r17
 113 0010 CF93      		push r28
 114 0012 DF93      		push r29
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 10 */
 118               	.L__stack_usage = 10
 119 0014 5901      		movw r10,r18
  84:packetmater.c ****    int i, j;
  85:packetmater.c ****    uint32_t mask;
  86:packetmater.c **** 	uint8_t byte;
GAS LISTING /tmp/ccMP3Ntm.s 			page 3


  87:packetmater.c **** 
  88:packetmater.c ****    i = 0;
  89:packetmater.c **** //   crc = 0xFFFFFFFF;
  90:packetmater.c **** 	crc = ~crc;
 121               	.LM1:
 122 0016 6095      		com r22
 123 0018 7095      		com r23
 124 001a 8095      		com r24
 125 001c 9095      		com r25
  91:packetmater.c ****    while (i < len) {
 127               	.LM2:
 128 001e FA01      		movw r30,r20
 129               	.L2:
 130 0020 9F01      		movw r18,r30
 131 0022 241B      		sub r18,r20
 132 0024 350B      		sbc r19,r21
 134               	.LM3:
 135 0026 2A15      		cp r18,r10
 136 0028 3B05      		cpc r19,r11
 137 002a 04F4      		brge .L8
  92:packetmater.c ****       byte = message[i];            // Get next byte.
 139               	.LM4:
 140 002c 2191      		ld r18,Z+
  93:packetmater.c ****       crc = crc ^ byte;
 142               	.LM5:
 143 002e 6227      		eor r22,r18
 144 0030 A8E0      		ldi r26,lo8(8)
 145 0032 B0E0      		ldi r27,0
 146               	.L4:
  94:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
  95:packetmater.c ****          mask = -(crc & 1);
  96:packetmater.c ****          crc = (crc >> 1) ^ (0xEDB88320 & mask);
 148               	.LM6:
 149 0034 8B01      		movw r16,r22
 150 0036 9C01      		movw r18,r24
 151 0038 3695      		lsr r19
 152 003a 2795      		ror r18
 153 003c 1795      		ror r17
 154 003e 0795      		ror r16
  95:packetmater.c ****          mask = -(crc & 1);
 156               	.LM7:
 157 0040 6B01      		movw r12,r22
 158 0042 7C01      		movw r14,r24
 159 0044 C1E0      		ldi r28,1
 160 0046 CC22      		and r12,r28
 161 0048 DD24      		clr r13
 162 004a EE24      		clr r14
 163 004c FF24      		clr r15
 164 004e 6627      		clr r22
 165 0050 7727      		clr r23
 166 0052 CB01      		movw r24,r22
 167 0054 6C19      		sub r22,r12
 168 0056 7D09      		sbc r23,r13
 169 0058 8E09      		sbc r24,r14
 170 005a 9F09      		sbc r25,r15
 172               	.LM8:
 173 005c 6072      		andi r22,32
GAS LISTING /tmp/ccMP3Ntm.s 			page 4


 174 005e 7378      		andi r23,131
 175 0060 887B      		andi r24,184
 176 0062 9D7E      		andi r25,237
 177 0064 6027      		eor r22,r16
 178 0066 7127      		eor r23,r17
 179 0068 8227      		eor r24,r18
 180 006a 9327      		eor r25,r19
 181 006c 1197      		sbiw r26,1
  94:packetmater.c ****       for (j = 7; j >= 0; j--) {    // Do eight times.
 183               	.LM9:
 184 006e 1097      		sbiw r26,0
 185 0070 01F4      		brne .L4
 186 0072 00C0      		rjmp .L2
 187               	.L8:
  97:packetmater.c ****       }
  98:packetmater.c ****       i = i + 1;
  99:packetmater.c ****    }
 100:packetmater.c ****    return ~crc;
 189               	.LM10:
 190 0074 6095      		com r22
 191 0076 7095      		com r23
 192 0078 8095      		com r24
 193 007a 9095      		com r25
 194               	/* epilogue start */
 101:packetmater.c **** }
 196               	.LM11:
 197 007c DF91      		pop r29
 198 007e CF91      		pop r28
 199 0080 1F91      		pop r17
 200 0082 0F91      		pop r16
 201 0084 FF90      		pop r15
 202 0086 EF90      		pop r14
 203 0088 DF90      		pop r13
 204 008a CF90      		pop r12
 205 008c BF90      		pop r11
 206 008e AF90      		pop r10
 207 0090 0895      		ret
 212               	.Lscope1:
 214               		.stabd	78,0,0
 218               	.global	internet_checksum
 220               	internet_checksum:
 221               		.stabd	46,0,0
 102:packetmater.c **** 
 103:packetmater.c **** uint16_t internet_checksum( const unsigned char * start, uint16_t len )
 104:packetmater.c **** {
 223               	.LM12:
 224               	.LFBB2:
 225 0092 CF93      		push r28
 226 0094 DF93      		push r29
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 2 */
 230               	.L__stack_usage = 2
 231 0096 9B01      		movw r18,r22
 232 0098 DC01      		movw r26,r24
 105:packetmater.c **** 	uint16_t i;
 106:packetmater.c **** 	const uint16_t * wptr = (uint16_t*) start;
GAS LISTING /tmp/ccMP3Ntm.s 			page 5


 107:packetmater.c **** 	uint32_t csum = 0;
 234               	.LM13:
 235 009a 40E0      		ldi r20,0
 236 009c 50E0      		ldi r21,0
 237 009e BA01      		movw r22,r20
 108:packetmater.c **** 	for (i=1;i<len;i+=2)
 239               	.LM14:
 240 00a0 E1E0      		ldi r30,lo8(1)
 241 00a2 F0E0      		ldi r31,0
 242               	.L10:
 244               	.LM15:
 245 00a4 E217      		cp r30,r18
 246 00a6 F307      		cpc r31,r19
 247 00a8 00F4      		brsh .L18
 109:packetmater.c **** 	{
 110:packetmater.c **** 		csum = csum + (uint32_t)(*(wptr++));	
 249               	.LM16:
 250 00aa CD91      		ld r28,X+
 251 00ac DD91      		ld r29,X+
 252 00ae 4C0F      		add r20,r28
 253 00b0 5D1F      		adc r21,r29
 254 00b2 611D      		adc r22,__zero_reg__
 255 00b4 711D      		adc r23,__zero_reg__
 108:packetmater.c **** 	for (i=1;i<len;i+=2)
 257               	.LM17:
 258 00b6 3296      		adiw r30,2
 259 00b8 00C0      		rjmp .L10
 260               	.L18:
 261 00ba F901      		movw r30,r18
 262 00bc EE7F      		andi r30,254
 263 00be E80F      		add r30,r24
 264 00c0 F91F      		adc r31,r25
 111:packetmater.c **** 	}
 112:packetmater.c **** 	if( len & 1 )  //See if there's an odd number of bytes?
 266               	.LM18:
 267 00c2 20FF      		sbrs r18,0
 268 00c4 00C0      		rjmp .L13
 269               	.LBB2:
 113:packetmater.c **** 	{
 114:packetmater.c **** 		uint8_t * tt = (uint8_t*)wptr;
 115:packetmater.c **** 		csum += *tt;
 271               	.LM19:
 272 00c6 8081      		ld r24,Z
 273 00c8 480F      		add r20,r24
 274 00ca 511D      		adc r21,__zero_reg__
 275 00cc 611D      		adc r22,__zero_reg__
 276 00ce 711D      		adc r23,__zero_reg__
 277               	.L13:
 278               	.LBE2:
 116:packetmater.c **** 	}
 117:packetmater.c **** 	while (csum>>16)
 280               	.LM20:
 281 00d0 CB01      		movw r24,r22
 282 00d2 AA27      		clr r26
 283 00d4 BB27      		clr r27
 284 00d6 0097      		sbiw r24,0
 285 00d8 A105      		cpc r26,__zero_reg__
GAS LISTING /tmp/ccMP3Ntm.s 			page 6


 286 00da B105      		cpc r27,__zero_reg__
 287 00dc 01F0      		breq .L19
 118:packetmater.c **** 		csum = (csum & 0xFFFF)+(csum >> 16);
 289               	.LM21:
 290 00de 6627      		clr r22
 291 00e0 7727      		clr r23
 292 00e2 480F      		add r20,r24
 293 00e4 591F      		adc r21,r25
 294 00e6 6A1F      		adc r22,r26
 295 00e8 7B1F      		adc r23,r27
 296 00ea 00C0      		rjmp .L13
 297               	.L19:
 119:packetmater.c **** 	csum = (csum>>8) | ((csum&0xff)<<8);
 299               	.LM22:
 300 00ec BB27      		clr r27
 301 00ee A72F      		mov r26,r23
 302 00f0 962F      		mov r25,r22
 303 00f2 852F      		mov r24,r21
 304 00f4 762F      		mov r23,r22
 305 00f6 652F      		mov r22,r21
 306 00f8 542F      		mov r21,r20
 307 00fa 4427      		clr r20
 308 00fc 6627      		clr r22
 309 00fe 7727      		clr r23
 310 0100 482B      		or r20,r24
 311 0102 592B      		or r21,r25
 312 0104 6A2B      		or r22,r26
 313 0106 7B2B      		or r23,r27
 120:packetmater.c **** 	return ~csum;
 315               	.LM23:
 316 0108 CA01      		movw r24,r20
 317 010a 8095      		com r24
 318 010c 9095      		com r25
 319               	/* epilogue start */
 121:packetmater.c **** }
 321               	.LM24:
 322 010e DF91      		pop r29
 323 0110 CF91      		pop r28
 324 0112 0895      		ret
 329               	.Lscope2:
 331               		.stabd	78,0,0
 336               	.global	Ethernetize
 338               	Ethernetize:
 339               		.stabd	46,0,0
  30:packetmater.c **** {
 341               	.LM25:
 342               	.LFBB3:
 343 0114 CF92      		push r12
 344 0116 DF92      		push r13
 345 0118 EF92      		push r14
 346 011a FF92      		push r15
 347 011c 0F93      		push r16
 348 011e 1F93      		push r17
 349 0120 CF93      		push r28
 350 0122 DF93      		push r29
 351               	/* prologue: function */
 352               	/* frame size = 0 */
GAS LISTING /tmp/ccMP3Ntm.s 			page 7


 353               	/* stack size = 8 */
 354               	.L__stack_usage = 8
 355 0124 EC01      		movw r28,r24
 356 0126 7A01      		movw r14,r20
  33:packetmater.c **** 	if( (udplenoverride+8) > plen-34 )
 358               	.LM26:
 359 0128 9A01      		movw r18,r20
 360 012a 295F      		subi r18,-7
 361 012c 3F4F      		sbci r19,-1
 362 012e CB01      		movw r24,r22
 363 0130 8697      		sbiw r24,38
 364 0132 2817      		cp r18,r24
 365 0134 3907      		cpc r19,r25
 366 0136 04F4      		brge .L21
  31:packetmater.c **** 	plen -= 4;
 368               	.LM27:
 369 0138 8B01      		movw r16,r22
 370 013a 0450      		subi r16,4
 371 013c 1109      		sbc r17,__zero_reg__
 372 013e 00C0      		rjmp .L22
 373               	.L21:
  34:packetmater.c **** 		plen = (udplenoverride+8) + 34;
 375               	.LM28:
 376 0140 8A01      		movw r16,r20
 377 0142 065D      		subi r16,-42
 378 0144 1F4F      		sbci r17,-1
 379               	.L22:
  37:packetmater.c **** 	plen = ((plen - 1)&0xfffc) + 4;
 381               	.LM29:
 382 0146 0150      		subi r16,1
 383 0148 1109      		sbc r17,__zero_reg__
 384 014a 0C7F      		andi r16,252
 385 014c 6801      		movw r12,r16
 386 014e 84E0      		ldi r24,4
 387 0150 C80E      		add r12,r24
 388 0152 D11C      		adc r13,__zero_reg__
  39:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 390               	.LM30:
 391 0154 8C85      		ldd r24,Y+12
 392 0156 8830      		cpi r24,lo8(8)
 393 0158 01F4      		brne .L24
  39:packetmater.c **** 	if( packet[12] == 0x08 && packet[13] == 0x00 )
 395               	.LM31:
 396 015a 8D85      		ldd r24,Y+13
 397 015c 8111      		cpse r24,__zero_reg__
 398 015e 00C0      		rjmp .L24
 399               	.LBB3:
  41:packetmater.c **** 		uint16_t fullpacklen = plen-14;
 401               	.LM32:
 402 0160 C801      		movw r24,r16
 403 0162 0A97      		sbiw r24,10
  42:packetmater.c **** 		packet[16] = fullpacklen>>8;
 405               	.LM33:
 406 0164 988B      		std Y+16,r25
  43:packetmater.c **** 		packet[17] = fullpacklen&0xff;
 408               	.LM34:
 409 0166 898B      		std Y+17,r24
GAS LISTING /tmp/ccMP3Ntm.s 			page 8


  44:packetmater.c **** 		packet[24] = 0;
 411               	.LM35:
 412 0168 188E      		std Y+24,__zero_reg__
  45:packetmater.c **** 		packet[25] = 0;
 414               	.LM36:
 415 016a 198E      		std Y+25,__zero_reg__
  48:packetmater.c **** 		csumr = internet_checksum( &packet[14], 20 );
 417               	.LM37:
 418 016c 64E1      		ldi r22,lo8(20)
 419 016e 70E0      		ldi r23,0
 420 0170 CE01      		movw r24,r28
 421 0172 0E96      		adiw r24,14
 422 0174 00D0      		rcall internet_checksum
  50:packetmater.c **** 		packet[24] = csumr>>8;
 424               	.LM38:
 425 0176 988F      		std Y+24,r25
  51:packetmater.c **** 		packet[25] = csumr&0xff;
 427               	.LM39:
 428 0178 898F      		std Y+25,r24
  53:packetmater.c **** 		if( packet[23] == 0x11  )
 430               	.LM40:
 431 017a 8F89      		ldd r24,Y+23
 432 017c 8131      		cpi r24,lo8(17)
 433 017e 01F4      		brne .L24
 434               	.LBB4:
  55:packetmater.c **** 			uint16_t udppacklen = udplenoverride + 8;//fullpacklen-20;
 436               	.LM41:
 437 0180 B701      		movw r22,r14
 438 0182 685F      		subi r22,-8
 439 0184 7F4F      		sbci r23,-1
  56:packetmater.c **** 			packet[32+6] = udppacklen>>8;
 441               	.LM42:
 442 0186 7EA3      		std Y+38,r23
  57:packetmater.c **** 			packet[32+7] = udppacklen&0xff;
 444               	.LM43:
 445 0188 6FA3      		std Y+39,r22
  59:packetmater.c **** 			uint16_t pseudo = 0x11 + 0x8 + udppacklen-8; //UDP number + size + length (of packet)
 447               	.LM44:
 448 018a 89E1      		ldi r24,25
 449 018c E80E      		add r14,r24
 450 018e F11C      		adc r15,__zero_reg__
  60:packetmater.c **** 			packet[40+0] = pseudo>>8;
 452               	.LM45:
 453 0190 F8A6      		std Y+40,r15
  61:packetmater.c **** 			packet[40+1] = pseudo&0xff;
 455               	.LM46:
 456 0192 E9A6      		std Y+41,r14
  63:packetmater.c **** 			csumr = internet_checksum( &packet[26], udppacklen+8 );
 458               	.LM47:
 459 0194 685F      		subi r22,-8
 460 0196 7F4F      		sbci r23,-1
 461 0198 CE01      		movw r24,r28
 462 019a 4A96      		adiw r24,26
 463 019c 00D0      		rcall internet_checksum
  64:packetmater.c **** 			if( csumr == 0 ) csumr = 0xffff;
 465               	.LM48:
 466 019e 0097      		sbiw r24,0
GAS LISTING /tmp/ccMP3Ntm.s 			page 9


 467 01a0 01F4      		brne .L26
 468 01a2 8FEF      		ldi r24,lo8(-1)
 469 01a4 9FEF      		ldi r25,lo8(-1)
 470               	.L26:
  65:packetmater.c **** 			packet[40+0] = csumr>>8;
 472               	.LM49:
 473 01a6 98A7      		std Y+40,r25
  66:packetmater.c **** 			packet[40+1] = csumr&0xff;
 475               	.LM50:
 476 01a8 89A7      		std Y+41,r24
 477               	.L24:
 478               	.LBE4:
 479               	.LBE3:
  71:packetmater.c **** 	uint32_t crc = crc32b( 0, packet, plen );
 481               	.LM51:
 482 01aa 9601      		movw r18,r12
 483 01ac AE01      		movw r20,r28
 484 01ae 60E0      		ldi r22,0
 485 01b0 70E0      		ldi r23,0
 486 01b2 CB01      		movw r24,r22
 487 01b4 00D0      		rcall crc32b
  73:packetmater.c **** 	packet[plen+0] = crc & 0xff;
 489               	.LM52:
 490 01b6 FE01      		movw r30,r28
 491 01b8 EC0D      		add r30,r12
 492 01ba FD1D      		adc r31,r13
 493 01bc 6083      		st Z,r22
  74:packetmater.c **** 	packet[plen+1] = (crc>>8) & 0xff;
 495               	.LM53:
 496 01be C00F      		add r28,r16
 497 01c0 D11F      		adc r29,r17
 498 01c2 7D83      		std Y+5,r23
  75:packetmater.c **** 	packet[plen+2] = (crc>>16) & 0xff;
 500               	.LM54:
 501 01c4 8E83      		std Y+6,r24
  76:packetmater.c **** 	packet[plen+3] = (crc>>24) & 0xff;
 503               	.LM55:
 504 01c6 9F83      		std Y+7,r25
  79:packetmater.c **** }
 506               	.LM56:
 507 01c8 C601      		movw r24,r12
 508               	/* epilogue start */
 509 01ca DF91      		pop r29
 510 01cc CF91      		pop r28
 511 01ce 1F91      		pop r17
 512 01d0 0F91      		pop r16
 513 01d2 FF90      		pop r15
 514 01d4 EF90      		pop r14
 515 01d6 DF90      		pop r13
 516 01d8 CF90      		pop r12
 517 01da 0895      		ret
 522               	.Lscope3:
 524               		.stabd	78,0,0
 526               	.Letext0:
 527               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccMP3Ntm.s 			page 10


DEFINED SYMBOLS
                            *ABS*:0000000000000000 packetmater.c
     /tmp/ccMP3Ntm.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccMP3Ntm.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccMP3Ntm.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccMP3Ntm.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccMP3Ntm.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccMP3Ntm.s:100    .text:0000000000000000 crc32b
     /tmp/ccMP3Ntm.s:220    .text:0000000000000092 internet_checksum
     /tmp/ccMP3Ntm.s:338    .text:0000000000000114 Ethernetize

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccMP3Ntm.s 			page 1


   1               		.file	"hlprocess.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  96               	.global	Demanchestrate
  98               	Demanchestrate:
  99               		.stabd	46,0,0
   1:hlprocess.c   **** #include "hlprocess.h"
   2:hlprocess.c   **** 
   3:hlprocess.c   **** //Note: -1 indicates unmatched short pulse.  I.e. quick transitions must pair up.
   4:hlprocess.c   **** int16_t Demanchestrate( unsigned char * raw_data_packet, uint16_t max_packet_data_len )
   5:hlprocess.c   **** {
 101               	.LM0:
 102               	.LFBB1:
 103 0000 CF92      		push r12
 104 0002 DF92      		push r13
 105 0004 EF92      		push r14
 106 0006 FF92      		push r15
 107 0008 0F93      		push r16
 108 000a 1F93      		push r17
 109 000c CF93      		push r28
 110 000e DF93      		push r29
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 8 */
 114               	.L__stack_usage = 8
 115 0010 FC01      		movw r30,r24
   6:hlprocess.c   **** 	uint8_t in_preamble = 4;
   7:hlprocess.c   **** 	uint8_t t;
   8:hlprocess.c   **** 	uint8_t mask;
   9:hlprocess.c   **** 
  10:hlprocess.c   **** 	uint8_t bit;
  11:hlprocess.c   **** 	uint8_t lastbit = 0;
  12:hlprocess.c   **** 	int8_t count = 0;
  13:hlprocess.c   **** 	uint16_t plen = 0;
  14:hlprocess.c   **** 	uint8_t shortflag = 0;
  15:hlprocess.c   **** 
  16:hlprocess.c   **** 	uint8_t cemitbit = 1; //current emitting bit.
  17:hlprocess.c   **** 	uint8_t cemitbyte = 0;
  18:hlprocess.c   **** 	uint8_t cemitmask = 1;
 117               	.LM1:
 118 0012 B1E0      		ldi r27,lo8(1)
  17:hlprocess.c   **** 	uint8_t cemitbyte = 0;
 120               	.LM2:
 121 0014 D0E0      		ldi r29,0
  16:hlprocess.c   **** 	uint8_t cemitbit = 1; //current emitting bit.
 123               	.LM3:
 124 0016 11E0      		ldi r17,lo8(1)
  14:hlprocess.c   **** 	uint8_t shortflag = 0;
 126               	.LM4:
 127 0018 A0E0      		ldi r26,0
  13:hlprocess.c   **** 	uint16_t plen = 0;
 129               	.LM5:
GAS LISTING /tmp/ccMP3Ntm.s 			page 2


 130 001a 20E0      		ldi r18,0
 131 001c 30E0      		ldi r19,0
  12:hlprocess.c   **** 	int8_t count = 0;
 133               	.LM6:
 134 001e 60E0      		ldi r22,0
  11:hlprocess.c   **** 	uint8_t lastbit = 0;
 136               	.LM7:
 137 0020 C0E0      		ldi r28,0
   6:hlprocess.c   **** 	uint8_t in_preamble = 4;
 139               	.LM8:
 140 0022 74E0      		ldi r23,lo8(4)
  19:hlprocess.c   **** 
  20:hlprocess.c   **** 	uint8_t * output = raw_data_packet;
  21:hlprocess.c   **** 
  22:hlprocess.c   **** 	while( 1 )
  23:hlprocess.c   **** 	{
  24:hlprocess.c   **** 		t = *(raw_data_packet++);
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
  26:hlprocess.c   **** 		{
  27:hlprocess.c   **** 			bit = (t&mask)?1:0;
 142               	.LM9:
 143 0024 DD24      		clr r13
 144 0026 D394      		inc r13
 145               	.L11:
  24:hlprocess.c   **** 		t = *(raw_data_packet++);
 147               	.LM10:
 148 0028 E190      		ld r14,Z+
 149 002a FC2E      		mov r15,r28
 150 002c 48E0      		ldi r20,lo8(8)
 151 002e 50E0      		ldi r21,0
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
 153               	.LM11:
 154 0030 00E8      		ldi r16,lo8(-128)
 155               	.L12:
 157               	.LM12:
 158 0032 C1E0      		ldi r28,lo8(1)
 159 0034 C02E      		mov r12,r16
 160 0036 CE20      		and r12,r14
 161 0038 01F4      		brne .L2
 162 003a C0E0      		ldi r28,0
 163               	.L2:
  28:hlprocess.c   **** 			if( bit != lastbit )
 165               	.LM13:
 166 003c CF15      		cp r28,r15
 167 003e 01F0      		breq .L3
  29:hlprocess.c   **** 			{
  30:hlprocess.c   **** 				//Ignore first two changes.
  31:hlprocess.c   **** 				if( in_preamble > 2 && count > 1 )
 169               	.LM14:
 170 0040 7330      		cpi r23,lo8(3)
 171 0042 00F0      		brlo .L4
 173               	.LM15:
 174 0044 6230      		cpi r22,lo8(2)
 175 0046 04F4      		brge .L21
 176 0048 00C0      		rjmp .L20
 177               	.L4:
  32:hlprocess.c   **** 				{
GAS LISTING /tmp/ccMP3Ntm.s 			page 3


  33:hlprocess.c   **** 					in_preamble--;
  34:hlprocess.c   **** 				}
  35:hlprocess.c   **** 				else if( in_preamble <= 2 && count < 2 && in_preamble )
 179               	.LM16:
 180 004a 6230      		cpi r22,lo8(2)
 181 004c 04F4      		brge .L6
 182 004e 7723      		tst r23
 183 0050 01F0      		breq .L7
 184               	.L21:
  36:hlprocess.c   **** 				{
  37:hlprocess.c   **** 					in_preamble--;
 186               	.LM17:
 187 0052 7150      		subi r23,lo8(-(-1))
 188 0054 00C0      		rjmp .L20
 189               	.L7:
 190               	.LBB2:
  38:hlprocess.c   **** 				}
  39:hlprocess.c   **** 				else if( !in_preamble )
  40:hlprocess.c   **** 				{
  41:hlprocess.c   **** 					uint8_t mark_emit = 0;
  42:hlprocess.c   **** 
  43:hlprocess.c   **** 					//Something happened.
  44:hlprocess.c   **** 					//If it's immediate, i.e. count = 0, count = 1 -> short (mark for ticking)
  45:hlprocess.c   **** 					//If it's later, i.e. count = 2, count = 3 -> long (invert)
  46:hlprocess.c   **** 					//We cannot get >3 as that's handled when we increase count.
  47:hlprocess.c   **** 					if( count > 1 )
  48:hlprocess.c   **** 					{
  49:hlprocess.c   **** 						if( shortflag )
  50:hlprocess.c   **** 						{
  51:hlprocess.c   **** 							return -1;
  52:hlprocess.c   **** 						}
  53:hlprocess.c   **** 						//invert bit.
  54:hlprocess.c   **** 						cemitbit = !cemitbit;
  55:hlprocess.c   **** 
  56:hlprocess.c   **** 						mark_emit = 1;
  57:hlprocess.c   **** 					}
  58:hlprocess.c   **** 					else
  59:hlprocess.c   **** 					{
  60:hlprocess.c   **** 						if( shortflag )
 192               	.LM18:
 193 0056 A111      		cpse r26,__zero_reg__
 194 0058 00C0      		rjmp .L9
  61:hlprocess.c   **** 						{
  62:hlprocess.c   **** 							mark_emit = 1;
  63:hlprocess.c   **** 							shortflag = 0;
  64:hlprocess.c   **** 						}
  65:hlprocess.c   **** 						else
  66:hlprocess.c   **** 						{
  67:hlprocess.c   **** 							shortflag = 1;
 196               	.LM19:
 197 005a A1E0      		ldi r26,lo8(1)
 198               	.L20:
 199               	.LBE2:
  68:hlprocess.c   **** 						}
  69:hlprocess.c   **** 					}
  70:hlprocess.c   **** 					if( mark_emit )
  71:hlprocess.c   **** 					{
GAS LISTING /tmp/ccMP3Ntm.s 			page 4


  72:hlprocess.c   **** 						//Emit cemitbit. 
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
  74:hlprocess.c   **** 						cemitmask <<= 1;
  75:hlprocess.c   **** 
  76:hlprocess.c   **** 						if( (cemitmask&0xff) == 0 )
  77:hlprocess.c   **** 						{
  78:hlprocess.c   **** 							output[plen++] = cemitbyte;
  79:hlprocess.c   **** 							cemitbyte = 0;
  80:hlprocess.c   **** 							cemitmask = 1;
  81:hlprocess.c   **** 						}
  82:hlprocess.c   **** 						mark_emit = 0;
  83:hlprocess.c   **** 					}
  84:hlprocess.c   **** 				}
  85:hlprocess.c   **** 
  86:hlprocess.c   **** 				lastbit = bit;
  87:hlprocess.c   **** 				count = 0;
 201               	.LM20:
 202 005c 60E0      		ldi r22,0
 203 005e 00C0      		rjmp .L5
 204               	.L3:
  88:hlprocess.c   **** 			}
  89:hlprocess.c   **** 			else
  90:hlprocess.c   **** 			{
  91:hlprocess.c   **** 				count++;
 206               	.LM21:
 207 0060 6F5F      		subi r22,lo8(-(1))
  92:hlprocess.c   **** 				if( count > 3 )
 209               	.LM22:
 210 0062 6430      		cpi r22,lo8(4)
 211 0064 04F0      		brlt .L5
  93:hlprocess.c   **** 				{
  94:hlprocess.c   **** 					return plen;
 213               	.LM23:
 214 0066 C901      		movw r24,r18
 215 0068 00C0      		rjmp .L19
 216               	.L6:
  39:hlprocess.c   **** 				else if( !in_preamble )
 218               	.LM24:
 219 006a 7111      		cpse r23,__zero_reg__
 220 006c 00C0      		rjmp .L20
 221               	.LBB3:
  49:hlprocess.c   **** 						if( shortflag )
 223               	.LM25:
 224 006e A111      		cpse r26,__zero_reg__
 225 0070 00C0      		rjmp .L17
  54:hlprocess.c   **** 						cemitbit = !cemitbit;
 227               	.LM26:
 228 0072 1D25      		eor r17,r13
 229               	.L9:
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 231               	.LM27:
 232 0074 1123      		tst r17
 233 0076 01F0      		breq .L23
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 235               	.LM28:
 236 0078 6B2F      		mov r22,r27
 237               	.L14:
GAS LISTING /tmp/ccMP3Ntm.s 			page 5


  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 239               	.LM29:
 240 007a D62B      		or r29,r22
  74:hlprocess.c   **** 						cemitmask <<= 1;
 242               	.LM30:
 243 007c BB0F      		lsl r27
  76:hlprocess.c   **** 						if( (cemitmask&0xff) == 0 )
 245               	.LM31:
 246 007e 01F4      		brne .L18
  78:hlprocess.c   **** 							output[plen++] = cemitbyte;
 248               	.LM32:
 249 0080 DC01      		movw r26,r24
 250 0082 A20F      		add r26,r18
 251 0084 B31F      		adc r27,r19
 252 0086 DC93      		st X,r29
 253 0088 2F5F      		subi r18,-1
 254 008a 3F4F      		sbci r19,-1
  80:hlprocess.c   **** 							cemitmask = 1;
 256               	.LM33:
 257 008c B1E0      		ldi r27,lo8(1)
  79:hlprocess.c   **** 							cemitbyte = 0;
 259               	.LM34:
 260 008e D0E0      		ldi r29,0
 261               	.L18:
 262 0090 A0E0      		ldi r26,0
 263               	.LBE3:
  87:hlprocess.c   **** 				count = 0;
 265               	.LM35:
 266 0092 60E0      		ldi r22,0
 267               	.LBB4:
 268 0094 70E0      		ldi r23,0
 269               	.L5:
 270               	.LBE4:
  25:hlprocess.c   **** 		for( mask = 0x80; mask; mask>>=1 )
 272               	.LM36:
 273 0096 0695      		lsr r16
 274 0098 4150      		subi r20,1
 275 009a 5109      		sbc r21,__zero_reg__
 276 009c 4115      		cp r20,__zero_reg__
 277 009e 5105      		cpc r21,__zero_reg__
 278 00a0 01F0      		breq .L11
  27:hlprocess.c   **** 			bit = (t&mask)?1:0;
 280               	.LM37:
 281 00a2 FC2E      		mov r15,r28
 282 00a4 00C0      		rjmp .L12
 283               	.L23:
 284               	.LBB5:
  73:hlprocess.c   **** 						cemitbyte |= cemitbit?cemitmask:0;
 286               	.LM38:
 287 00a6 60E0      		ldi r22,0
 288 00a8 00C0      		rjmp .L14
 289               	.L17:
  51:hlprocess.c   **** 							return -1;
 291               	.LM39:
 292 00aa 8FEF      		ldi r24,lo8(-1)
 293 00ac 9FEF      		ldi r25,lo8(-1)
 294               	.L19:
GAS LISTING /tmp/ccMP3Ntm.s 			page 6


 295               	/* epilogue start */
 296               	.LBE5:
  95:hlprocess.c   **** 				}
  96:hlprocess.c   **** 			}
  97:hlprocess.c   **** 		}
  98:hlprocess.c   **** 		//Next byte.
  99:hlprocess.c   **** 	}
 100:hlprocess.c   **** }
 298               	.LM40:
 299 00ae DF91      		pop r29
 300 00b0 CF91      		pop r28
 301 00b2 1F91      		pop r17
 302 00b4 0F91      		pop r16
 303 00b6 FF90      		pop r15
 304 00b8 EF90      		pop r14
 305 00ba DF90      		pop r13
 306 00bc CF90      		pop r12
 307 00be 0895      		ret
 319               	.Lscope1:
 321               		.stabd	78,0,0
 323               	.Letext0:
 324               		.ident	"GCC: (GNU) 4.8.2"
GAS LISTING /tmp/ccMP3Ntm.s 			page 7


DEFINED SYMBOLS
                            *ABS*:0000000000000000 hlprocess.c
     /tmp/ccMP3Ntm.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccMP3Ntm.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccMP3Ntm.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccMP3Ntm.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccMP3Ntm.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccMP3Ntm.s:98     .text:0000000000000000 Demanchestrate

NO UNDEFINED SYMBOLS
GAS LISTING /tmp/ccMP3Ntm.s 			page 1


   1               		.file	"net_compat.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 110               	et_push8:
 111               		.stabd	46,0,0
 113               	.Ltext1:
   1:net_compat.h  **** #ifndef _ENC424JCOMPAT_H
   2:net_compat.h  **** #define _ENC424JCOMPAT_H
   3:net_compat.h  **** 
   4:net_compat.h  **** //et compat lib.
   5:net_compat.h  **** //We're using the IP library from AVRCraft
   6:net_compat.h  **** 
   7:net_compat.h  **** //TODO: Should probably use Timer1 (since we can't use Timer0)
   8:net_compat.h  **** //to make sure we send media detect pulses at the right points.
   9:net_compat.h  **** //Also, as a user, you cannot use the USI or Timer0
  10:net_compat.h  **** 
  11:net_compat.h  **** #include <stdint.h>
  12:net_compat.h  **** #include "eth_config.h"
  13:net_compat.h  **** 
  14:net_compat.h  **** //MyMAC is included in this driver.
  15:net_compat.h  **** extern unsigned char MyMAC[6];
  16:net_compat.h  **** extern unsigned char ETbuffer[ETBUFFERSIZE+PREAMBLE];
  17:net_compat.h  **** extern unsigned short ETsendplace;
  18:net_compat.h  **** //For telling where the current transaction started.
  19:net_compat.h  **** extern uint16_t sendbaseaddress;
  20:net_compat.h  **** extern unsigned short ETchecksum;
  21:net_compat.h  **** 
  22:net_compat.h  **** //Do not split this across byte-addressing boundaries.
  23:net_compat.h  **** //We do some fancy stuff when we send the manchester out.
  24:net_compat.h  **** extern char ManchesterTable[16];
  25:net_compat.h  **** 
  26:net_compat.h  **** //return 0 if OK, otherwise nonzero.
  27:net_compat.h  **** int8_t et_init( const unsigned char * macaddy );
  28:net_compat.h  **** 
  29:net_compat.h  **** int8_t et_xmitpacket( uint16_t start, uint16_t len );
  30:net_compat.h  **** 
  31:net_compat.h  **** //This waits for 8ms, sends an autoneg notice, then waits for 8 more ms.
  32:net_compat.h  **** //Ordinarily this would if packets were processed and still ned processing, but
  33:net_compat.h  **** //that doesn't make sense for this driver.  Do not put this in a loop unto itself.
  34:net_compat.h  **** unsigned short et_recvpack();
  35:net_compat.h  **** 
  36:net_compat.h  **** //You have to write this! (Or the underlying IP core must)
  37:net_compat.h  **** void et_receivecallback( uint16_t packetlen );
  38:net_compat.h  **** 
  39:net_compat.h  **** //Finish up any reading. 							//CLOSURE
  40:net_compat.h  **** static inline void et_finish_callback_now() { }
  41:net_compat.h  **** 
  42:net_compat.h  **** //Raw, on-wire pops. (assuming already in read)
  43:net_compat.h  **** void et_popblob( uint8_t * data, uint8_t len );
  44:net_compat.h  **** static inline void et_dumpbytes( uint8_t len ) { ETsendplace += len; }
  45:net_compat.h  **** static inline uint16_t et_pop16() { return ETbuffer[ETsendplace++]; }
  46:net_compat.h  **** static inline uint8_t et_pop8() { return ETbuffer[ETsendplace++]; }
GAS LISTING /tmp/ccMP3Ntm.s 			page 2


  47:net_compat.h  **** 
  48:net_compat.h  **** //Raw, on-wire push. (assuming already in write)
  49:net_compat.h  **** void et_pushpgmstr( const char * msg );
  50:net_compat.h  **** void et_pushstr( const char * msg );
  51:net_compat.h  **** void et_pushblob( const uint8_t * data, uint8_t len );
  52:net_compat.h  **** void et_pushpgmblob( const uint8_t * data, uint8_t len );
  53:net_compat.h  **** static inline void et_push8( uint8_t d ) { ETbuffer[ETsendplace++] = d; }
 115               	.LM0:
 116               	.LFBB1:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 122               	.LM1:
 123 0000 2091 0000 		lds r18,ETsendplace
 124 0004 3091 0000 		lds r19,ETsendplace+1
 125 0008 A901      		movw r20,r18
 126 000a 4F5F      		subi r20,-1
 127 000c 5F4F      		sbci r21,-1
 128 000e 5093 0000 		sts ETsendplace+1,r21
 129 0012 4093 0000 		sts ETsendplace,r20
 130 0016 F901      		movw r30,r18
 131 0018 E050      		subi r30,lo8(-(ETbuffer))
 132 001a F040      		sbci r31,hi8(-(ETbuffer))
 133 001c 8083      		st Z,r24
 134 001e 0895      		ret
 136               	.Lscope1:
 138               		.stabd	78,0,0
 143               	.global	GotPack
 145               	GotPack:
 146               		.stabd	46,0,0
 148               	.Ltext2:
   1:net_compat.c  **** #include "net_compat.h"
   2:net_compat.c  **** #include <avr/pgmspace.h>
   3:net_compat.c  **** #include <string.h>
   4:net_compat.c  **** 
   5:net_compat.c  **** #define NOOP asm volatile("nop" ::)
   6:net_compat.c  **** 
   7:net_compat.c  **** 
   8:net_compat.c  **** unsigned char MyMAC[6];
   9:net_compat.c  **** unsigned char ETbuffer[ETBUFFERSIZE+PREAMBLE];
  10:net_compat.c  **** unsigned short ETsendplace;
  11:net_compat.c  **** uint16_t sendbaseaddress;
  12:net_compat.c  **** unsigned short ETchecksum;
  13:net_compat.c  **** 
  14:net_compat.c  **** 
  15:net_compat.c  **** //Do not split this across byte-addressing boundaries.
  16:net_compat.c  **** //We do some fancy stuff when we send the manchester out.
  17:net_compat.c  **** char ManchesterTable[16] __attribute__ ((aligned (16))) = {
  18:net_compat.c  **** 	0b10101010, 0b01101010, 0b10011010, 0b01011010,
  19:net_compat.c  **** 	0b10100110, 0b01100110, 0b10010110, 0b01010110,
  20:net_compat.c  **** 	0b10101001, 0b01101001, 0b10011001, 0b01011001,
  21:net_compat.c  **** 	0b10100101, 0b01100101, 0b10010101, 0b01010101,
  22:net_compat.c  **** };
  23:net_compat.c  **** 
  24:net_compat.c  **** 
  25:net_compat.c  **** 
GAS LISTING /tmp/ccMP3Ntm.s 			page 3


  26:net_compat.c  **** //Internal functs
  27:net_compat.c  **** 
  28:net_compat.c  **** //From the ASM file.
  29:net_compat.c  **** void SendTestASM( const unsigned char * c, uint8_t len );
  30:net_compat.c  **** int MaybeHaveDataASM( unsigned char * c, uint8_t lenX2 ); //returns the number of pairs.
  31:net_compat.c  **** 
  32:net_compat.c  **** //Attempt to return rough estimate of processing time.
  33:net_compat.c  **** int GotPack( unsigned char * machesterized, int estlen, uint16_t mlen )
  34:net_compat.c  **** {
 150               	.LM2:
 151               	.LFBB2:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  35:net_compat.c  **** 	int byr = 0;
  36:net_compat.c  **** 
  37:net_compat.c  **** 	byr = Demanchestrate( machesterized, mlen );
 157               	.LM3:
 158 0020 BA01      		movw r22,r20
 159 0022 00C0      		rjmp Demanchestrate
 161               	.Lscope2:
 163               		.stabd	78,0,0
 168               	.global	waitforpacket
 170               	waitforpacket:
 171               		.stabd	46,0,0
  38:net_compat.c  **** 
  39:net_compat.c  **** 	//Don't do anything yet...
  40:net_compat.c  **** 	//XXX TODO THIS will be some good stuff in here.
  41:net_compat.c  **** 
  42:net_compat.c  **** 	return byr;
  43:net_compat.c  **** }
  44:net_compat.c  **** 
  45:net_compat.c  **** void waitforpacket( unsigned char * buffer, uint16_t len, int16_t ltime )
  46:net_compat.c  **** {
 173               	.LM4:
 174               	.LFBB3:
 175 0024 CF92      		push r12
 176 0026 DF92      		push r13
 177 0028 EF92      		push r14
 178 002a FF92      		push r15
 179 002c 0F93      		push r16
 180 002e 1F93      		push r17
 181 0030 CF93      		push r28
 182 0032 DF93      		push r29
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 8 */
 186               	.L__stack_usage = 8
 187 0034 6C01      		movw r12,r24
 188 0036 7B01      		movw r14,r22
 189 0038 EA01      		movw r28,r20
  47:net_compat.c  **** 	OSCCAL = OSCHIGH;
 191               	.LM5:
 192 003a 8FEF      		ldi r24,lo8(-1)
 193 003c 81BF      		out 0x31,r24
 194               	.L4:
GAS LISTING /tmp/ccMP3Ntm.s 			page 4


  48:net_compat.c  **** 
  49:net_compat.c  **** 	//Make sure we're not walking in on something.
  50:net_compat.c  **** 	while( ltime-- > 0 )
 196               	.LM6:
 197 003e 2197      		sbiw r28,1
 198 0040 CE01      		movw r24,r28
 199 0042 0196      		adiw r24,1
 200 0044 1816      		cp __zero_reg__,r24
 201 0046 1906      		cpc __zero_reg__,r25
 202 0048 04F4      		brge .L10
  51:net_compat.c  **** 	{
  52:net_compat.c  **** 		if( USIBR == 0x00 ) break;
 204               	.LM7:
 205 004a 80B3      		in r24,0x10
 206 004c 8823      		tst r24
 207 004e 01F0      		breq .L10
  53:net_compat.c  **** 		if( USIBR == 0xFF ) break;
 209               	.LM8:
 210 0050 80B3      		in r24,0x10
 211 0052 8F3F      		cpi r24,lo8(-1)
 212 0054 01F0      		breq .L10
  54:net_compat.c  **** 		NOOP;
 214               	.LM9:
 215               	/* #APP */
 216               	 ;  54 "net_compat.c" 1
 217 0056 0000      		nop
 218               	 ;  0 "" 2
 219               	/* #NOAPP */
 220 0058 00C0      		rjmp .L4
 221               	.L11:
  55:net_compat.c  **** 	}
  56:net_compat.c  **** 
  57:net_compat.c  **** 
  58:net_compat.c  **** 	while( ltime-- > 0 )
  59:net_compat.c  **** 	{
  60:net_compat.c  **** 		if( USIBR && (USIBR != 0xFF ) )
 223               	.LM10:
 224 005a 80B3      		in r24,0x10
 225 005c 8111      		cpse r24,__zero_reg__
 226 005e 00C0      		rjmp .L27
 227               	.L10:
  58:net_compat.c  **** 	while( ltime-- > 0 )
 229               	.LM11:
 230 0060 2197      		sbiw r28,1
 231 0062 CE01      		movw r24,r28
 232 0064 0196      		adiw r24,1
 233 0066 1816      		cp __zero_reg__,r24
 234 0068 1906      		cpc __zero_reg__,r25
 235 006a 04F0      		brlt .L11
 236 006c 00C0      		rjmp .L9
 237               	.L27:
 239               	.LM12:
 240 006e 80B3      		in r24,0x10
 241 0070 8F3F      		cpi r24,lo8(-1)
 242 0072 01F0      		breq .L10
 243               	.LBB5:
  61:net_compat.c  **** 		{
GAS LISTING /tmp/ccMP3Ntm.s 			page 5


  62:net_compat.c  **** 			int r = MaybeHaveDataASM( buffer, len );
 245               	.LM13:
 246 0074 6E2D      		mov r22,r14
 247 0076 C601      		movw r24,r12
 248 0078 00D0      		rcall MaybeHaveDataASM
 249 007a 8C01      		movw r16,r24
  63:net_compat.c  **** 			if( r > 1 )
 251               	.LM14:
 252 007c 8230      		cpi r24,2
 253 007e 9105      		cpc r25,__zero_reg__
 254 0080 04F0      		brlt .L8
 255               	.LBB6:
 256               	.LBB7:
  37:net_compat.c  **** 	byr = Demanchestrate( machesterized, mlen );
 258               	.LM15:
 259 0082 B701      		movw r22,r14
 260 0084 C601      		movw r24,r12
 261 0086 00D0      		rcall Demanchestrate
 262               	.LBE7:
 263               	.LBE6:
  64:net_compat.c  **** 			{
  65:net_compat.c  **** 				r += GotPack( buffer, r, len );
 265               	.LM16:
 266 0088 080F      		add r16,r24
 267 008a 191F      		adc r17,r25
 268               	.L8:
  66:net_compat.c  **** 			}
  67:net_compat.c  **** 			ltime-=(len-r)*4+3; //About how long the function takes to execute.
 270               	.LM17:
 271 008c 2397      		sbiw r28,3
 272 008e E01A      		sub r14,r16
 273 0090 F10A      		sbc r15,r17
 274 0092 EE0C      		lsl r14
 275 0094 FF1C      		rol r15
 276 0096 EE0C      		lsl r14
 277 0098 FF1C      		rol r15
 278 009a CE19      		sub r28,r14
 279 009c DF09      		sbc r29,r15
 280               	.L9:
 281               	.LBE5:
  68:net_compat.c  **** 			break;
  69:net_compat.c  **** 		}
  70:net_compat.c  **** 	}
  71:net_compat.c  **** 
  72:net_compat.c  **** 
  73:net_compat.c  **** 	while( ltime-- > 0 )
 283               	.LM18:
 284 009e 1C16      		cp __zero_reg__,r28
 285 00a0 1D06      		cpc __zero_reg__,r29
 286 00a2 04F4      		brge .L28
  74:net_compat.c  **** 	{
  75:net_compat.c  **** 		NOOP;
 288               	.LM19:
 289               	/* #APP */
 290               	 ;  75 "net_compat.c" 1
 291 00a4 0000      		nop
 292               	 ;  0 "" 2
GAS LISTING /tmp/ccMP3Ntm.s 			page 6


  76:net_compat.c  **** 		NOOP;
 294               	.LM20:
 295               	 ;  76 "net_compat.c" 1
 296 00a6 0000      		nop
 297               	 ;  0 "" 2
  77:net_compat.c  **** 		NOOP;
 299               	.LM21:
 300               	 ;  77 "net_compat.c" 1
 301 00a8 0000      		nop
 302               	 ;  0 "" 2
  78:net_compat.c  **** 		NOOP;
 304               	.LM22:
 305               	 ;  78 "net_compat.c" 1
 306 00aa 0000      		nop
 307               	 ;  0 "" 2
  79:net_compat.c  **** 		NOOP;
 309               	.LM23:
 310               	 ;  79 "net_compat.c" 1
 311 00ac 0000      		nop
 312               	 ;  0 "" 2
 313               	/* #NOAPP */
 314 00ae 2197      		sbiw r28,1
 315 00b0 00C0      		rjmp .L9
 316               	.L28:
  80:net_compat.c  **** 	}
  81:net_compat.c  **** 
  82:net_compat.c  **** 	OSCCAL = OSC20;
 318               	.LM24:
 319 00b2 86EB      		ldi r24,lo8(-74)
 320 00b4 81BF      		out 0x31,r24
 321               	/* epilogue start */
  83:net_compat.c  **** }
 323               	.LM25:
 324 00b6 DF91      		pop r29
 325 00b8 CF91      		pop r28
 326 00ba 1F91      		pop r17
 327 00bc 0F91      		pop r16
 328 00be FF90      		pop r15
 329 00c0 EF90      		pop r14
 330 00c2 DF90      		pop r13
 331 00c4 CF90      		pop r12
 332 00c6 0895      		ret
 337               	.Lscope3:
 339               		.stabd	78,0,0
 343               	.global	et_popblob
 345               	et_popblob:
 346               		.stabd	46,0,0
  84:net_compat.c  **** 
  85:net_compat.c  **** 
  86:net_compat.c  **** 
  87:net_compat.c  **** 
  88:net_compat.c  **** 
  89:net_compat.c  **** 
  90:net_compat.c  **** 
  91:net_compat.c  **** 
  92:net_compat.c  **** 
  93:net_compat.c  **** //
GAS LISTING /tmp/ccMP3Ntm.s 			page 7


  94:net_compat.c  **** 
  95:net_compat.c  **** void et_popblob( uint8_t * data, uint8_t len )
  96:net_compat.c  **** {
 348               	.LM26:
 349               	.LFBB4:
 350               	/* prologue: function */
 351               	/* frame size = 0 */
 352               	/* stack size = 0 */
 353               	.L__stack_usage = 0
 354               	.L30:
  97:net_compat.c  **** 	while( len-- )
 356               	.LM27:
 357 00c8 6150      		subi r22,1
 358 00ca 00F0      		brcs .L32
 359               	.LBB10:
 360               	.LBB11:
 362               	.Ltext3:
  46:net_compat.h  **** static inline uint8_t et_pop8() { return ETbuffer[ETsendplace++]; }
 364               	.LM28:
 365 00cc 2091 0000 		lds r18,ETsendplace
 366 00d0 3091 0000 		lds r19,ETsendplace+1
 367 00d4 A901      		movw r20,r18
 368 00d6 4F5F      		subi r20,-1
 369 00d8 5F4F      		sbci r21,-1
 370 00da 5093 0000 		sts ETsendplace+1,r21
 371 00de 4093 0000 		sts ETsendplace,r20
 372 00e2 F901      		movw r30,r18
 373 00e4 E050      		subi r30,lo8(-(ETbuffer))
 374 00e6 F040      		sbci r31,hi8(-(ETbuffer))
 375 00e8 2081      		ld r18,Z
 376               	.LBE11:
 377               	.LBE10:
 379               	.Ltext4:
  98:net_compat.c  **** 	{
  99:net_compat.c  **** 		*(data++) = et_pop8();
 381               	.LM29:
 382 00ea FC01      		movw r30,r24
 383 00ec 2193      		st Z+,r18
 384 00ee CF01      		movw r24,r30
 385 00f0 00C0      		rjmp .L30
 386               	.L32:
 387               	/* epilogue start */
 100:net_compat.c  **** 	}
 101:net_compat.c  **** }
 389               	.LM30:
 390 00f2 0895      		ret
 392               	.Lscope4:
 394               		.stabd	78,0,0
 397               	.global	et_pushpgmstr
 399               	et_pushpgmstr:
 400               		.stabd	46,0,0
 102:net_compat.c  **** 
 103:net_compat.c  **** void et_pushpgmstr( const char * msg )
 104:net_compat.c  **** {
 402               	.LM31:
 403               	.LFBB5:
 404 00f4 CF93      		push r28
GAS LISTING /tmp/ccMP3Ntm.s 			page 8


 405 00f6 DF93      		push r29
 406               	/* prologue: function */
 407               	/* frame size = 0 */
 408               	/* stack size = 2 */
 409               	.L__stack_usage = 2
 410 00f8 FC01      		movw r30,r24
 411               	.L35:
 412               	.LBB12:
 105:net_compat.c  **** 	uint8_t r;
 106:net_compat.c  **** 	do
 107:net_compat.c  **** 	{
 108:net_compat.c  **** 		r = pgm_read_byte(msg++);
 414               	.LM32:
 415               	/* #APP */
 416               	 ;  108 "net_compat.c" 1
 417 00fa 8491      		lpm r24, Z
 418               		
 419               	 ;  0 "" 2
 420               	/* #NOAPP */
 421 00fc EF01      		movw r28,r30
 422 00fe 2196      		adiw r28,1
 423               	.LBE12:
 109:net_compat.c  **** 		if( !r ) break;
 425               	.LM33:
 426 0100 8823      		tst r24
 427 0102 01F0      		breq .L33
 110:net_compat.c  **** 		et_push8( r );
 429               	.LM34:
 430 0104 00D0      		rcall et_push8
 431 0106 FE01      		movw r30,r28
 111:net_compat.c  **** 	} while( 1 );
 433               	.LM35:
 434 0108 00C0      		rjmp .L35
 435               	.L33:
 436               	/* epilogue start */
 112:net_compat.c  **** }
 438               	.LM36:
 439 010a DF91      		pop r29
 440 010c CF91      		pop r28
 441 010e 0895      		ret
 446               	.Lscope5:
 448               		.stabd	78,0,0
 451               	.global	et_pushpgmblob
 453               	et_pushpgmblob:
 454               		.stabd	46,0,0
 113:net_compat.c  **** 
 114:net_compat.c  **** void et_pushpgmblob( const uint8_t * data, uint8_t len )
 115:net_compat.c  **** {
 456               	.LM37:
 457               	.LFBB6:
 458 0110 0F93      		push r16
 459 0112 1F93      		push r17
 460 0114 CF93      		push r28
 461 0116 DF93      		push r29
 462 0118 1F92      		push __zero_reg__
 463 011a CDB7      		in r28,__SP_L__
 464 011c DEB7      		in r29,__SP_H__
GAS LISTING /tmp/ccMP3Ntm.s 			page 9


 465               	/* prologue: function */
 466               	/* frame size = 1 */
 467               	/* stack size = 5 */
 468               	.L__stack_usage = 5
 116:net_compat.c  **** 	while( len-- )
 470               	.LM38:
 471 011e 8C01      		movw r16,r24
 472 0120 680F      		add r22,r24
 473               	.L37:
 475               	.LM39:
 476 0122 6017      		cp r22,r16
 477 0124 01F0      		breq .L39
 478               	.LBB13:
 117:net_compat.c  **** 	{
 118:net_compat.c  **** 		et_push8( pgm_read_byte(data++) );
 480               	.LM40:
 481 0126 F801      		movw r30,r16
 482               	/* #APP */
 483               	 ;  118 "net_compat.c" 1
 484 0128 8491      		lpm r24, Z
 485               		
 486               	 ;  0 "" 2
 487               	/* #NOAPP */
 488               	.LBE13:
 489 012a 6983      		std Y+1,r22
 490 012c 00D0      		rcall et_push8
 491 012e 0F5F      		subi r16,-1
 492 0130 1F4F      		sbci r17,-1
 493 0132 6981      		ldd r22,Y+1
 494 0134 00C0      		rjmp .L37
 495               	.L39:
 496               	/* epilogue start */
 119:net_compat.c  **** 	}
 120:net_compat.c  **** }
 498               	.LM41:
 499 0136 0F90      		pop __tmp_reg__
 500 0138 DF91      		pop r29
 501 013a CF91      		pop r28
 502 013c 1F91      		pop r17
 503 013e 0F91      		pop r16
 504 0140 0895      		ret
 509               	.Lscope6:
 511               		.stabd	78,0,0
 514               	.global	et_pushstr
 516               	et_pushstr:
 517               		.stabd	46,0,0
 121:net_compat.c  **** 
 122:net_compat.c  **** 
 123:net_compat.c  **** void et_pushstr( const char * msg )
 124:net_compat.c  **** {
 519               	.LM42:
 520               	.LFBB7:
 521 0142 CF93      		push r28
 522 0144 DF93      		push r29
 523               	/* prologue: function */
 524               	/* frame size = 0 */
 525               	/* stack size = 2 */
GAS LISTING /tmp/ccMP3Ntm.s 			page 10


 526               	.L__stack_usage = 2
 527 0146 EC01      		movw r28,r24
 528               	.L41:
 125:net_compat.c  **** 	for( ; *msg; msg++ ) 
 530               	.LM43:
 531 0148 8991      		ld r24,Y+
 532 014a 8823      		tst r24
 533 014c 01F0      		breq .L43
 126:net_compat.c  **** 		et_push8( *msg );
 535               	.LM44:
 536 014e 00D0      		rcall et_push8
 537 0150 00C0      		rjmp .L41
 538               	.L43:
 539               	/* epilogue start */
 127:net_compat.c  **** }
 541               	.LM45:
 542 0152 DF91      		pop r29
 543 0154 CF91      		pop r28
 544 0156 0895      		ret
 546               	.Lscope7:
 548               		.stabd	78,0,0
 551               	.global	et_pushblob
 553               	et_pushblob:
 554               		.stabd	46,0,0
 128:net_compat.c  **** 
 129:net_compat.c  **** void et_pushblob( const uint8_t * data, uint8_t len )
 130:net_compat.c  **** {
 556               	.LM46:
 557               	.LFBB8:
 558 0158 0F93      		push r16
 559 015a 1F93      		push r17
 560 015c CF93      		push r28
 561 015e DF93      		push r29
 562 0160 1F92      		push __zero_reg__
 563 0162 CDB7      		in r28,__SP_L__
 564 0164 DEB7      		in r29,__SP_H__
 565               	/* prologue: function */
 566               	/* frame size = 1 */
 567               	/* stack size = 5 */
 568               	.L__stack_usage = 5
 131:net_compat.c  **** 	while( len-- )
 570               	.LM47:
 571 0166 8C01      		movw r16,r24
 572 0168 680F      		add r22,r24
 573               	.L45:
 575               	.LM48:
 576 016a 6017      		cp r22,r16
 577 016c 01F0      		breq .L47
 132:net_compat.c  **** 	{
 133:net_compat.c  **** 		et_push8( *(data++) );
 579               	.LM49:
 580 016e F801      		movw r30,r16
 581 0170 8191      		ld r24,Z+
 582 0172 8F01      		movw r16,r30
 583 0174 6983      		std Y+1,r22
 584 0176 00D0      		rcall et_push8
 585 0178 6981      		ldd r22,Y+1
GAS LISTING /tmp/ccMP3Ntm.s 			page 11


 586 017a 00C0      		rjmp .L45
 587               	.L47:
 588               	/* epilogue start */
 134:net_compat.c  **** 	}
 135:net_compat.c  **** }
 590               	.LM50:
 591 017c 0F90      		pop __tmp_reg__
 592 017e DF91      		pop r29
 593 0180 CF91      		pop r28
 594 0182 1F91      		pop r17
 595 0184 0F91      		pop r16
 596 0186 0895      		ret
 598               	.Lscope8:
 600               		.stabd	78,0,0
 603               	.global	et_init
 605               	et_init:
 606               		.stabd	46,0,0
 136:net_compat.c  **** 
 137:net_compat.c  **** 
 138:net_compat.c  **** //return 0 if OK, otherwise nonzero.
 139:net_compat.c  **** int8_t et_init( const unsigned char * macaddy )
 140:net_compat.c  **** {
 608               	.LM51:
 609               	.LFBB9:
 610               	/* prologue: function */
 611               	/* frame size = 0 */
 612               	/* stack size = 0 */
 613               	.L__stack_usage = 0
 614 0188 FC01      		movw r30,r24
 141:net_compat.c  **** 	MyMAC[0] = macaddy[0];
 616               	.LM52:
 617 018a 8081      		ld r24,Z
 618 018c 8093 0000 		sts MyMAC,r24
 142:net_compat.c  **** 	MyMAC[1] = macaddy[1];
 620               	.LM53:
 621 0190 8181      		ldd r24,Z+1
 622 0192 8093 0000 		sts MyMAC+1,r24
 143:net_compat.c  **** 	MyMAC[2] = macaddy[2];
 624               	.LM54:
 625 0196 8281      		ldd r24,Z+2
 626 0198 8093 0000 		sts MyMAC+2,r24
 144:net_compat.c  **** 	MyMAC[3] = macaddy[3];
 628               	.LM55:
 629 019c 8381      		ldd r24,Z+3
 630 019e 8093 0000 		sts MyMAC+3,r24
 145:net_compat.c  **** 	MyMAC[4] = macaddy[4];
 632               	.LM56:
 633 01a2 8481      		ldd r24,Z+4
 634 01a4 8093 0000 		sts MyMAC+4,r24
 146:net_compat.c  **** 	MyMAC[5] = macaddy[5];
 636               	.LM57:
 637 01a8 8581      		ldd r24,Z+5
 638 01aa 8093 0000 		sts MyMAC+5,r24
 147:net_compat.c  **** 
 148:net_compat.c  **** 	PLLCSR = _BV(PLLE) | _BV( PCKE );
 640               	.LM58:
 641 01ae 86E0      		ldi r24,lo8(6)
GAS LISTING /tmp/ccMP3Ntm.s 			page 12


 642 01b0 87BD      		out 0x27,r24
 149:net_compat.c  **** 	PLLCSR |= _BV(LSM);
 644               	.LM59:
 645 01b2 87B5      		in r24,0x27
 646 01b4 8068      		ori r24,lo8(-128)
 647 01b6 87BD      		out 0x27,r24
 150:net_compat.c  **** 	OSCCAL = OSC20;
 649               	.LM60:
 650 01b8 86EB      		ldi r24,lo8(-74)
 651 01ba 81BF      		out 0x31,r24
 151:net_compat.c  **** 
 152:net_compat.c  **** 
 153:net_compat.c  **** 	//Setup timer 0 to speed along.
 154:net_compat.c  **** 	//Yes, this means you can't use it.
 155:net_compat.c  **** 	TCCR0A = _BV(WGM01);
 653               	.LM61:
 654 01bc 82E0      		ldi r24,lo8(2)
 655 01be 8ABD      		out 0x2a,r24
 156:net_compat.c  **** 	TCCR0B = _BV(CS00);
 657               	.LM62:
 658 01c0 81E0      		ldi r24,lo8(1)
 659 01c2 83BF      		out 0x33,r24
 157:net_compat.c  **** 	OCR0A = 0;
 661               	.LM63:
 662 01c4 19BC      		out 0x29,__zero_reg__
 158:net_compat.c  **** 
 159:net_compat.c  **** 	USICR = _BV(USIWM0) | _BV(USICS0) | _BV(USITC);
 664               	.LM64:
 665 01c6 85E1      		ldi r24,lo8(21)
 666 01c8 8DB9      		out 0xd,r24
 160:net_compat.c  **** 
 161:net_compat.c  **** 	//setup port B
 162:net_compat.c  **** 
 163:net_compat.c  **** 	PORTB &= ~_BV(0); 
 668               	.LM65:
 669 01ca C098      		cbi 0x18,0
 164:net_compat.c  **** 	DDRB &= ~_BV(0);
 671               	.LM66:
 672 01cc B898      		cbi 0x17,0
 165:net_compat.c  **** 	PORTB &= ~_BV(1);
 674               	.LM67:
 675 01ce C198      		cbi 0x18,1
 166:net_compat.c  **** 	USICR &= ~_BV(USIWM0);  //Disable USICR
 677               	.LM68:
 678 01d0 6C98      		cbi 0xd,4
 167:net_compat.c  **** 
 168:net_compat.c  **** 	return 0;
 169:net_compat.c  **** }
 680               	.LM69:
 681 01d2 80E0      		ldi r24,0
 682 01d4 0895      		ret
 684               	.Lscope9:
 686               		.stabd	78,0,0
 690               	.global	et_xmitpacket
 692               	et_xmitpacket:
 693               		.stabd	46,0,0
 170:net_compat.c  **** 
GAS LISTING /tmp/ccMP3Ntm.s 			page 13


 171:net_compat.c  **** int8_t et_xmitpacket( uint16_t start, uint16_t len )
 172:net_compat.c  **** {
 695               	.LM70:
 696               	.LFBB10:
 697               	/* prologue: function */
 698               	/* frame size = 0 */
 699               	/* stack size = 0 */
 700               	.L__stack_usage = 0
 173:net_compat.c  **** 	//XXX !!! TODO
 174:net_compat.c  **** }
 702               	.LM71:
 703 01d6 0895      		ret
 705               	.Lscope10:
 707               		.stabd	78,0,0
 709               	.global	et_recvpack
 711               	et_recvpack:
 712               		.stabd	46,0,0
 175:net_compat.c  **** 
 176:net_compat.c  **** //This waits for 8ms, sends an autoneg notice, then waits for 8 more ms.
 177:net_compat.c  **** unsigned short et_recvpack()
 178:net_compat.c  **** {
 714               	.LM72:
 715               	.LFBB11:
 716               	/* prologue: function */
 717               	/* frame size = 0 */
 718               	/* stack size = 0 */
 719               	.L__stack_usage = 0
 179:net_compat.c  **** 
 180:net_compat.c  **** #define LIMITSIZE  sizeof( ETbuffer )/2-30
 181:net_compat.c  **** //#define LIMITSIZE 10
 182:net_compat.c  **** 
 183:net_compat.c  **** 		waitforpacket(&ETbuffer[PREAMBLE+40], LIMITSIZE, 20000); //wait for 2048 cycles (30MHz/8 = 3.75MH
 721               	.LM73:
 722 01d8 40E2      		ldi r20,lo8(32)
 723 01da 5EE4      		ldi r21,lo8(78)
 724 01dc 64E8      		ldi r22,lo8(-124)
 725 01de 70E0      		ldi r23,0
 726 01e0 80E0      		ldi r24,lo8(ETbuffer+48)
 727 01e2 90E0      		ldi r25,hi8(ETbuffer+48)
 728 01e4 00D0      		rcall waitforpacket
 184:net_compat.c  **** //		_delay_ms(8);
 185:net_compat.c  **** #ifdef SMARTPWR
 186:net_compat.c  **** 		DDRB |= _BV(1);
 187:net_compat.c  **** #endif
 188:net_compat.c  **** 		PORTB|=_BV(1);
 730               	.LM74:
 731 01e6 C19A      		sbi 0x18,1
 189:net_compat.c  **** 		NOOP;
 733               	.LM75:
 734               	/* #APP */
 735               	 ;  189 "net_compat.c" 1
 736 01e8 0000      		nop
 737               	 ;  0 "" 2
 190:net_compat.c  **** 		PORTB &=~_BV(1);
 739               	.LM76:
 740               	/* #NOAPP */
 741 01ea C198      		cbi 0x18,1
GAS LISTING /tmp/ccMP3Ntm.s 			page 14


 191:net_compat.c  **** #ifdef SMARTPWR
 192:net_compat.c  **** 		DDRB &= ~_BV(1);
 193:net_compat.c  **** #endif
 194:net_compat.c  **** 		waitforpacket(&ETbuffer[PREAMBLE+40], LIMITSIZE, 20000); //wait for 2048  (30MHz/8 = 3.75MHz / 30
 743               	.LM77:
 744 01ec 40E2      		ldi r20,lo8(32)
 745 01ee 5EE4      		ldi r21,lo8(78)
 746 01f0 64E8      		ldi r22,lo8(-124)
 747 01f2 70E0      		ldi r23,0
 748 01f4 80E0      		ldi r24,lo8(ETbuffer+48)
 749 01f6 90E0      		ldi r25,hi8(ETbuffer+48)
 750 01f8 00D0      		rcall waitforpacket
 195:net_compat.c  **** // 		_delay_ms(8);
 196:net_compat.c  **** 
 197:net_compat.c  **** }
 752               	.LM78:
 753 01fa 0895      		ret
 755               	.Lscope11:
 757               		.stabd	78,0,0
 761               	.global	et_start_checksum
 763               	et_start_checksum:
 764               		.stabd	46,0,0
 198:net_compat.c  **** 
 199:net_compat.c  **** void et_start_checksum( uint16_t start, uint16_t len )
 200:net_compat.c  **** {
 766               	.LM79:
 767               	.LFBB12:
 768               	/* prologue: function */
 769               	/* frame size = 0 */
 770               	/* stack size = 0 */
 771               	.L__stack_usage = 0
 772 01fc 0895      		ret
 774               	.Lscope12:
 776               		.stabd	78,0,0
 783               	.global	et_copy_memory
 785               	et_copy_memory:
 786               		.stabd	46,0,0
 201:net_compat.c  **** //	ETchecksum = uint16_t internet_checksum( &ETbuffer[start], uint16_t len );
 202:net_compat.c  **** 	//XXX !!! TODO
 203:net_compat.c  **** }
 204:net_compat.c  **** 
 205:net_compat.c  **** void et_copy_memory( uint16_t to, uint16_t from, uint16_t length, uint16_t range_start, uint16_t ra
 206:net_compat.c  **** {
 788               	.LM80:
 789               	.LFBB13:
 790               	/* prologue: function */
 791               	/* frame size = 0 */
 792               	/* stack size = 0 */
 793               	.L__stack_usage = 0
 794 01fe 0895      		ret
 796               	.Lscope13:
 798               		.stabd	78,0,0
 799               	.global	ManchesterTable
 800               		.data
 801               		.p2align	4
 804               	ManchesterTable:
 805 0000 AA        		.byte	-86
GAS LISTING /tmp/ccMP3Ntm.s 			page 15


 806 0001 6A        		.byte	106
 807 0002 9A        		.byte	-102
 808 0003 5A        		.byte	90
 809 0004 A6        		.byte	-90
 810 0005 66        		.byte	102
 811 0006 96        		.byte	-106
 812 0007 56        		.byte	86
 813 0008 A9        		.byte	-87
 814 0009 69        		.byte	105
 815 000a 99        		.byte	-103
 816 000b 59        		.byte	89
 817 000c A5        		.byte	-91
 818 000d 65        		.byte	101
 819 000e 95        		.byte	-107
 820 000f 55        		.byte	85
 821               		.comm	ETchecksum,2,1
 822               		.comm	sendbaseaddress,2,1
 823               		.comm	ETsendplace,2,1
 824               		.comm	ETbuffer,324,1
 825               		.comm	MyMAC,6,1
 832               		.text
 834               	.Letext0:
 835               		.ident	"GCC: (GNU) 4.8.2"
 836               	.global __do_copy_data
 837               	.global __do_clear_bss
GAS LISTING /tmp/ccMP3Ntm.s 			page 16


DEFINED SYMBOLS
                            *ABS*:0000000000000000 net_compat.c
     /tmp/ccMP3Ntm.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccMP3Ntm.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccMP3Ntm.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccMP3Ntm.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccMP3Ntm.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccMP3Ntm.s:110    .text:0000000000000000 et_push8
                            *COM*:0000000000000002 ETsendplace
                            *COM*:0000000000000144 ETbuffer
     /tmp/ccMP3Ntm.s:145    .text:0000000000000020 GotPack
     /tmp/ccMP3Ntm.s:170    .text:0000000000000024 waitforpacket
     /tmp/ccMP3Ntm.s:345    .text:00000000000000c8 et_popblob
     /tmp/ccMP3Ntm.s:399    .text:00000000000000f4 et_pushpgmstr
     /tmp/ccMP3Ntm.s:453    .text:0000000000000110 et_pushpgmblob
     /tmp/ccMP3Ntm.s:516    .text:0000000000000142 et_pushstr
     /tmp/ccMP3Ntm.s:553    .text:0000000000000158 et_pushblob
     /tmp/ccMP3Ntm.s:605    .text:0000000000000188 et_init
                            *COM*:0000000000000006 MyMAC
     /tmp/ccMP3Ntm.s:692    .text:00000000000001d6 et_xmitpacket
     /tmp/ccMP3Ntm.s:711    .text:00000000000001d8 et_recvpack
     /tmp/ccMP3Ntm.s:763    .text:00000000000001fc et_start_checksum
     /tmp/ccMP3Ntm.s:785    .text:00000000000001fe et_copy_memory
     /tmp/ccMP3Ntm.s:804    .data:0000000000000000 ManchesterTable
                            *COM*:0000000000000002 ETchecksum
                            *COM*:0000000000000002 sendbaseaddress

UNDEFINED SYMBOLS
Demanchestrate
MaybeHaveDataASM
__do_copy_data
__do_clear_bss
